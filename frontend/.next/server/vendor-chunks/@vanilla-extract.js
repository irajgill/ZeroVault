"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vanilla-extract";
exports.ids = ["vendor-chunks/@vanilla-extract"];
exports.modules = {

/***/ "(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendCss: () => (/* binding */ appendCss),\n/* harmony export */   getIdentOption: () => (/* binding */ getIdentOption),\n/* harmony export */   markCompositionUsed: () => (/* binding */ markCompositionUsed),\n/* harmony export */   mockAdapter: () => (/* binding */ mockAdapter),\n/* harmony export */   onBeginFileScope: () => (/* binding */ onBeginFileScope),\n/* harmony export */   onEndFileScope: () => (/* binding */ onEndFileScope),\n/* harmony export */   registerClassName: () => (/* binding */ registerClassName),\n/* harmony export */   registerComposition: () => (/* binding */ registerComposition),\n/* harmony export */   removeAdapter: () => (/* binding */ removeAdapter),\n/* harmony export */   setAdapter: () => (/* binding */ setAdapter),\n/* harmony export */   setAdapterIfNotSet: () => (/* binding */ setAdapterIfNotSet)\n/* harmony export */ });\nvar mockAdapter = {\n  appendCss: () => {},\n  registerClassName: () => {},\n  onEndFileScope: () => {},\n  registerComposition: () => {},\n  markCompositionUsed: () => {},\n  getIdentOption: () =>  false ? 0 : 'debug'\n};\nvar adapterStack = [mockAdapter];\nvar currentAdapter = () => {\n  if (adapterStack.length < 1) {\n    throw new Error('No adapter configured');\n  }\n  return adapterStack[adapterStack.length - 1];\n};\nvar hasConfiguredAdapter = false;\nvar setAdapterIfNotSet = newAdapter => {\n  if (!hasConfiguredAdapter) {\n    setAdapter(newAdapter);\n  }\n};\nvar setAdapter = newAdapter => {\n  if (!newAdapter) {\n    throw new Error('No adapter provided when calling \"setAdapter\"');\n  }\n  hasConfiguredAdapter = true;\n  adapterStack.push(newAdapter);\n};\nvar removeAdapter = () => {\n  adapterStack.pop();\n};\nvar appendCss = function appendCss() {\n  return currentAdapter().appendCss(...arguments);\n};\nvar registerClassName = function registerClassName() {\n  return currentAdapter().registerClassName(...arguments);\n};\nvar registerComposition = function registerComposition() {\n  return currentAdapter().registerComposition(...arguments);\n};\nvar markCompositionUsed = function markCompositionUsed() {\n  return currentAdapter().markCompositionUsed(...arguments);\n};\nvar onBeginFileScope = function onBeginFileScope() {\n  var _currentAdapter$onBeg, _currentAdapter;\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  return (_currentAdapter$onBeg = (_currentAdapter = currentAdapter()).onBeginFileScope) === null || _currentAdapter$onBeg === void 0 ? void 0 : _currentAdapter$onBeg.call(_currentAdapter, ...props);\n};\nvar onEndFileScope = function onEndFileScope() {\n  return currentAdapter().onEndFileScope(...arguments);\n};\nvar getIdentOption = function getIdentOption() {\n  var adapter = currentAdapter();\n\n  // Backwards compatibility with old versions of the integration package\n  if (!('getIdentOption' in adapter)) {\n    return  false ? 0 : 'debug';\n  }\n  return adapter.getIdentOption(...arguments);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2FkYXB0ZXIvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLWFkYXB0ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHdCQUF3QixNQUFxQyxHQUFHLENBQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU87QUFDMUQ7QUFDQTtBQUNBOztBQUVnTSIsInNvdXJjZXMiOlsid2VicGFjazovL3plcm92YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3MvYWRhcHRlci9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtYWRhcHRlci5lc20uanM/ZDIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbW9ja0FkYXB0ZXIgPSB7XG4gIGFwcGVuZENzczogKCkgPT4ge30sXG4gIHJlZ2lzdGVyQ2xhc3NOYW1lOiAoKSA9PiB7fSxcbiAgb25FbmRGaWxlU2NvcGU6ICgpID0+IHt9LFxuICByZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgbWFya0NvbXBvc2l0aW9uVXNlZDogKCkgPT4ge30sXG4gIGdldElkZW50T3B0aW9uOiAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gJ3Nob3J0JyA6ICdkZWJ1Zydcbn07XG52YXIgYWRhcHRlclN0YWNrID0gW21vY2tBZGFwdGVyXTtcbnZhciBjdXJyZW50QWRhcHRlciA9ICgpID0+IHtcbiAgaWYgKGFkYXB0ZXJTdGFjay5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhZGFwdGVyIGNvbmZpZ3VyZWQnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlclN0YWNrW2FkYXB0ZXJTdGFjay5sZW5ndGggLSAxXTtcbn07XG52YXIgaGFzQ29uZmlndXJlZEFkYXB0ZXIgPSBmYWxzZTtcbnZhciBzZXRBZGFwdGVySWZOb3RTZXQgPSBuZXdBZGFwdGVyID0+IHtcbiAgaWYgKCFoYXNDb25maWd1cmVkQWRhcHRlcikge1xuICAgIHNldEFkYXB0ZXIobmV3QWRhcHRlcik7XG4gIH1cbn07XG52YXIgc2V0QWRhcHRlciA9IG5ld0FkYXB0ZXIgPT4ge1xuICBpZiAoIW5ld0FkYXB0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFkYXB0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIFwic2V0QWRhcHRlclwiJyk7XG4gIH1cbiAgaGFzQ29uZmlndXJlZEFkYXB0ZXIgPSB0cnVlO1xuICBhZGFwdGVyU3RhY2sucHVzaChuZXdBZGFwdGVyKTtcbn07XG52YXIgcmVtb3ZlQWRhcHRlciA9ICgpID0+IHtcbiAgYWRhcHRlclN0YWNrLnBvcCgpO1xufTtcbnZhciBhcHBlbmRDc3MgPSBmdW5jdGlvbiBhcHBlbmRDc3MoKSB7XG4gIHJldHVybiBjdXJyZW50QWRhcHRlcigpLmFwcGVuZENzcyguLi5hcmd1bWVudHMpO1xufTtcbnZhciByZWdpc3RlckNsYXNzTmFtZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ2xhc3NOYW1lKCkge1xuICByZXR1cm4gY3VycmVudEFkYXB0ZXIoKS5yZWdpc3RlckNsYXNzTmFtZSguLi5hcmd1bWVudHMpO1xufTtcbnZhciByZWdpc3RlckNvbXBvc2l0aW9uID0gZnVuY3Rpb24gcmVnaXN0ZXJDb21wb3NpdGlvbigpIHtcbiAgcmV0dXJuIGN1cnJlbnRBZGFwdGVyKCkucmVnaXN0ZXJDb21wb3NpdGlvbiguLi5hcmd1bWVudHMpO1xufTtcbnZhciBtYXJrQ29tcG9zaXRpb25Vc2VkID0gZnVuY3Rpb24gbWFya0NvbXBvc2l0aW9uVXNlZCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBZGFwdGVyKCkubWFya0NvbXBvc2l0aW9uVXNlZCguLi5hcmd1bWVudHMpO1xufTtcbnZhciBvbkJlZ2luRmlsZVNjb3BlID0gZnVuY3Rpb24gb25CZWdpbkZpbGVTY29wZSgpIHtcbiAgdmFyIF9jdXJyZW50QWRhcHRlciRvbkJlZywgX2N1cnJlbnRBZGFwdGVyO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIChfY3VycmVudEFkYXB0ZXIkb25CZWcgPSAoX2N1cnJlbnRBZGFwdGVyID0gY3VycmVudEFkYXB0ZXIoKSkub25CZWdpbkZpbGVTY29wZSkgPT09IG51bGwgfHwgX2N1cnJlbnRBZGFwdGVyJG9uQmVnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudEFkYXB0ZXIkb25CZWcuY2FsbChfY3VycmVudEFkYXB0ZXIsIC4uLnByb3BzKTtcbn07XG52YXIgb25FbmRGaWxlU2NvcGUgPSBmdW5jdGlvbiBvbkVuZEZpbGVTY29wZSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBZGFwdGVyKCkub25FbmRGaWxlU2NvcGUoLi4uYXJndW1lbnRzKTtcbn07XG52YXIgZ2V0SWRlbnRPcHRpb24gPSBmdW5jdGlvbiBnZXRJZGVudE9wdGlvbigpIHtcbiAgdmFyIGFkYXB0ZXIgPSBjdXJyZW50QWRhcHRlcigpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHZlcnNpb25zIG9mIHRoZSBpbnRlZ3JhdGlvbiBwYWNrYWdlXG4gIGlmICghKCdnZXRJZGVudE9wdGlvbicgaW4gYWRhcHRlcikpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/ICdzaG9ydCcgOiAnZGVidWcnO1xuICB9XG4gIHJldHVybiBhZGFwdGVyLmdldElkZW50T3B0aW9uKC4uLmFyZ3VtZW50cyk7XG59O1xuXG5leHBvcnQgeyBhcHBlbmRDc3MsIGdldElkZW50T3B0aW9uLCBtYXJrQ29tcG9zaXRpb25Vc2VkLCBtb2NrQWRhcHRlciwgb25CZWdpbkZpbGVTY29wZSwgb25FbmRGaWxlU2NvcGUsIHJlZ2lzdGVyQ2xhc3NOYW1lLCByZWdpc3RlckNvbXBvc2l0aW9uLCByZW1vdmVBZGFwdGVyLCBzZXRBZGFwdGVyLCBzZXRBZGFwdGVySWZOb3RTZXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _taggedTemplateLiteral)\n/* harmony export */ });\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdGFnZ2VkVGVtcGxhdGVMaXRlcmFsLTEwOTk4MzE1LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXJvdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdGFnZ2VkVGVtcGxhdGVMaXRlcmFsLTEwOTk4MzE1LmVzbS5qcz83NTgwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gIGlmICghcmF3KSB7XG4gICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgcmF3OiB7XG4gICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpXG4gICAgfVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwgYXMgXyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _objectWithoutProperties),\n/* harmony export */   d: () => (/* binding */ dudupeAndJoinClassList),\n/* harmony export */   t: () => (/* binding */ transformCss)\n/* harmony export */ });\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cssesc */ \"(ssr)/../node_modules/cssesc/cssesc.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cssesc__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var modern_ahocorasick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modern-ahocorasick */ \"(ssr)/../node_modules/modern-ahocorasick/dist/index.js\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n/* harmony import */ var _taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var css_what__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-what */ \"(ssr)/../node_modules/css-what/lib/es/parse.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var media_query_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! media-query-parser */ \"(ssr)/../node_modules/media-query-parser/dist/media-query-parser.esm.js\");\n\n\n\n\n\n\n\n\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction forEach(obj, fn) {\n  for (var _key in obj) {\n    fn(obj[_key], _key);\n  }\n}\nfunction omit(obj, omitKeys) {\n  var result = {};\n  for (var _key2 in obj) {\n    if (omitKeys.indexOf(_key2) === -1) {\n      result[_key2] = obj[_key2];\n    }\n  }\n  return result;\n}\nfunction mapKeys(obj, fn) {\n  var result = {};\n  for (var _key3 in obj) {\n    result[fn(obj[_key3], _key3)] = obj[_key3];\n  }\n  return result;\n}\nfunction composeStylesIntoSet(set) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    classNames[_key5 - 1] = arguments[_key5];\n  }\n  for (var className of classNames) {\n    if (className.length === 0) {\n      continue;\n    }\n    if (typeof className === 'string') {\n      if (className.includes(' ')) {\n        composeStylesIntoSet(set, ...className.trim().split(' '));\n      } else {\n        set.add(className);\n      }\n    } else if (Array.isArray(className)) {\n      composeStylesIntoSet(set, ...className);\n    }\n  }\n}\nfunction dudupeAndJoinClassList(classNames) {\n  var set = new Set();\n  composeStylesIntoSet(set, ...classNames);\n  return Array.from(set).join(' ');\n}\n\nvar _templateObject$1;\n\n// https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nvar validateSelector = (selector, targetClassName) => {\n  var replaceTarget = () => {\n    var targetRegex = new RegExp(\".\".concat(escapeRegex(cssesc__WEBPACK_IMPORTED_MODULE_0___default()(targetClassName, {\n      isIdentifier: true\n    }))), 'g');\n    return selector.replace(targetRegex, '&');\n  };\n  var selectorParts;\n  try {\n    selectorParts = (0,css_what__WEBPACK_IMPORTED_MODULE_5__.parse)(selector);\n  } catch (err) {\n    throw new Error(\"Invalid selector: \".concat(replaceTarget()));\n  }\n  selectorParts.forEach(tokens => {\n    try {\n      for (var i = tokens.length - 1; i >= -1; i--) {\n        if (!tokens[i]) {\n          throw new Error();\n        }\n        var token = tokens[i];\n        if (token.type === 'child' || token.type === 'parent' || token.type === 'sibling' || token.type === 'adjacent' || token.type === 'descendant') {\n          throw new Error();\n        }\n        if (token.type === 'attribute' && token.name === 'class' && token.value === targetClassName) {\n          return; // Found it\n        }\n      }\n    } catch (err) {\n      throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject$1 || (_templateObject$1 = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__._)([\"\\n        Invalid selector: \", \"\\n    \\n        Style selectors must target the '&' character (along with any modifiers), e.g. \", \" or \", \".\\n        \\n        This is to ensure that each style block only affects the styling of a single class.\\n        \\n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of \", \") to 'parent', you should add \", \" to 'child').\\n        \\n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write \", \", you should instead write 'globalStyle(\", \", { ... })'\\n      \"])), replaceTarget(), '`${parent} &`', '`${parent} &:hover`', '`& ${child}`', '`${parent} &`', '`& h1`', '`${parent} h1`'));\n    }\n  });\n};\n\n/** e.g. @media screen and (min-width: 500px) */\n\nclass ConditionalRuleset {\n  /**\n   * Stores information about where conditions must be in relation to other conditions\n   *\n   * e.g. mobile -> tablet, desktop\n   */\n\n  constructor() {\n    this.ruleset = new Map();\n    this.precedenceLookup = new Map();\n  }\n  findOrCreateCondition(conditionQuery) {\n    var targetCondition = this.ruleset.get(conditionQuery);\n    if (!targetCondition) {\n      // No target condition so create one\n      targetCondition = {\n        query: conditionQuery,\n        rules: [],\n        children: new ConditionalRuleset()\n      };\n      this.ruleset.set(conditionQuery, targetCondition);\n    }\n    return targetCondition;\n  }\n  getConditionalRulesetByPath(conditionPath) {\n    var currRuleset = this;\n    for (var query of conditionPath) {\n      var condition = currRuleset.findOrCreateCondition(query);\n      currRuleset = condition.children;\n    }\n    return currRuleset;\n  }\n  addRule(rule, conditionQuery, conditionPath) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);\n    if (!targetCondition) {\n      throw new Error('Failed to add conditional rule');\n    }\n    targetCondition.rules.push(rule);\n  }\n  addConditionPrecedence(conditionPath, conditionOrder) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    for (var i = 0; i < conditionOrder.length; i++) {\n      var _ruleset$precedenceLo;\n      var query = conditionOrder[i];\n      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : new Set();\n      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {\n        conditionPrecedence.add(lowerPrecedenceCondition);\n      }\n      ruleset.precedenceLookup.set(query, conditionPrecedence);\n    }\n  }\n  isCompatible(incomingRuleset) {\n    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {\n      for (var lowerPrecedenceCondition of orderPrecedence) {\n        var _incomingRuleset$prec;\n        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that children are compatible\n    for (var {\n      query,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  merge(incomingRuleset) {\n    // Merge rulesets into one array\n    for (var {\n      query,\n      rules,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition) {\n        matchingCondition.rules.push(...rules);\n        matchingCondition.children.merge(children);\n      } else {\n        this.ruleset.set(query, {\n          query,\n          rules,\n          children\n        });\n      }\n    }\n\n    // Merge order precedences\n    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {\n      var _this$precedenceLooku;\n      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : new Set();\n      this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));\n    }\n  }\n\n  /**\n   * Merge another ConditionalRuleset into this one if they are compatible\n   *\n   * @returns true if successful, false if the ruleset is incompatible\n   */\n  mergeIfCompatible(incomingRuleset) {\n    if (!this.isCompatible(incomingRuleset)) {\n      return false;\n    }\n    this.merge(incomingRuleset);\n    return true;\n  }\n  getSortedRuleset() {\n    var _this = this;\n    var sortedRuleset = [];\n\n    // Loop through all queries and add them to the sorted ruleset\n    var _loop = function _loop(dependents) {\n      var conditionForQuery = _this.ruleset.get(query);\n      if (!conditionForQuery) {\n        throw new Error(\"Can't find condition for \".concat(query));\n      }\n\n      // Find the location of the first dependent condition in the sortedRuleset\n      // A dependent condition is a condition that must be placed *after* the current one\n      var firstMatchingDependent = sortedRuleset.findIndex(condition => dependents.has(condition.query));\n      if (firstMatchingDependent > -1) {\n        // Insert the condition before the dependent one\n        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);\n      } else {\n        // No match, just insert at the end\n        sortedRuleset.push(conditionForQuery);\n      }\n    };\n    for (var [query, dependents] of this.precedenceLookup.entries()) {\n      _loop(dependents);\n    }\n    return sortedRuleset;\n  }\n  renderToArray() {\n    var arr = [];\n    for (var {\n      query,\n      rules,\n      children\n    } of this.getSortedRuleset()) {\n      var selectors = {};\n      for (var rule of rules) {\n        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);\n      }\n      Object.assign(selectors, ...children.renderToArray());\n      arr.push({\n        [query]: selectors\n      });\n    }\n    return arr;\n  }\n}\n\nvar simplePseudoMap = {\n  ':-moz-any-link': true,\n  ':-moz-full-screen': true,\n  ':-moz-placeholder': true,\n  ':-moz-read-only': true,\n  ':-moz-read-write': true,\n  ':-ms-fullscreen': true,\n  ':-ms-input-placeholder': true,\n  ':-webkit-any-link': true,\n  ':-webkit-full-screen': true,\n  '::-moz-color-swatch': true,\n  '::-moz-list-bullet': true,\n  '::-moz-list-number': true,\n  '::-moz-page-sequence': true,\n  '::-moz-page': true,\n  '::-moz-placeholder': true,\n  '::-moz-progress-bar': true,\n  '::-moz-range-progress': true,\n  '::-moz-range-thumb': true,\n  '::-moz-range-track': true,\n  '::-moz-scrolled-page-sequence': true,\n  '::-moz-selection': true,\n  '::-ms-backdrop': true,\n  '::-ms-browse': true,\n  '::-ms-check': true,\n  '::-ms-clear': true,\n  '::-ms-fill-lower': true,\n  '::-ms-fill-upper': true,\n  '::-ms-fill': true,\n  '::-ms-reveal': true,\n  '::-ms-thumb': true,\n  '::-ms-ticks-after': true,\n  '::-ms-ticks-before': true,\n  '::-ms-tooltip': true,\n  '::-ms-track': true,\n  '::-ms-value': true,\n  '::-webkit-backdrop': true,\n  '::-webkit-calendar-picker-indicator': true,\n  '::-webkit-inner-spin-button': true,\n  '::-webkit-input-placeholder': true,\n  '::-webkit-meter-bar': true,\n  '::-webkit-meter-even-less-good-value': true,\n  '::-webkit-meter-inner-element': true,\n  '::-webkit-meter-optimum-value': true,\n  '::-webkit-meter-suboptimum-value': true,\n  '::-webkit-outer-spin-button': true,\n  '::-webkit-progress-bar': true,\n  '::-webkit-progress-inner-element': true,\n  '::-webkit-progress-inner-value': true,\n  '::-webkit-progress-value': true,\n  '::-webkit-resizer': true,\n  '::-webkit-scrollbar-button': true,\n  '::-webkit-scrollbar-corner': true,\n  '::-webkit-scrollbar-thumb': true,\n  '::-webkit-scrollbar-track-piece': true,\n  '::-webkit-scrollbar-track': true,\n  '::-webkit-scrollbar': true,\n  '::-webkit-search-cancel-button': true,\n  '::-webkit-search-results-button': true,\n  '::-webkit-slider-runnable-track': true,\n  '::-webkit-slider-thumb': true,\n  '::after': true,\n  '::backdrop': true,\n  '::before': true,\n  '::cue': true,\n  '::file-selector-button': true,\n  '::first-letter': true,\n  '::first-line': true,\n  '::grammar-error': true,\n  '::marker': true,\n  '::placeholder': true,\n  '::selection': true,\n  '::spelling-error': true,\n  '::target-text': true,\n  '::view-transition-group': true,\n  '::view-transition-image-pair': true,\n  '::view-transition-new': true,\n  '::view-transition-old': true,\n  '::view-transition': true,\n  ':active': true,\n  ':after': true,\n  ':any-link': true,\n  ':before': true,\n  ':blank': true,\n  ':checked': true,\n  ':default': true,\n  ':defined': true,\n  ':disabled': true,\n  ':empty': true,\n  ':enabled': true,\n  ':first-child': true,\n  ':first-letter': true,\n  ':first-line': true,\n  ':first-of-type': true,\n  ':first': true,\n  ':focus-visible': true,\n  ':focus-within': true,\n  ':focus': true,\n  ':fullscreen': true,\n  ':hover': true,\n  ':in-range': true,\n  ':indeterminate': true,\n  ':invalid': true,\n  ':last-child': true,\n  ':last-of-type': true,\n  ':left': true,\n  ':link': true,\n  ':only-child': true,\n  ':only-of-type': true,\n  ':optional': true,\n  ':out-of-range': true,\n  ':placeholder-shown': true,\n  ':read-only': true,\n  ':read-write': true,\n  ':required': true,\n  ':right': true,\n  ':root': true,\n  ':scope': true,\n  ':target': true,\n  ':valid': true,\n  ':visited': true\n};\nvar simplePseudos = Object.keys(simplePseudoMap);\nvar simplePseudoLookup = simplePseudoMap;\n\nvar _templateObject;\nvar createMediaQueryError = (mediaQuery, msg) => new Error((0,dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject || (_templateObject = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__._)([\"\\n    Invalid media query: \\\"\", \"\\\"\\n\\n    \", \"\\n\\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\\n  \"])), mediaQuery, msg));\nvar validateMediaQuery = mediaQuery => {\n  // Empty queries will start with '@media '\n  if (mediaQuery === '@media ') {\n    throw createMediaQueryError(mediaQuery, 'Query is empty');\n  }\n  try {\n    (0,media_query_parser__WEBPACK_IMPORTED_MODULE_4__.toAST)(mediaQuery);\n  } catch (e) {\n    throw createMediaQueryError(mediaQuery, e.message);\n  }\n};\n\nvar _excluded = [\"vars\"],\n  _excluded2 = [\"content\"];\nvar DECLARATION = '__DECLARATION';\nvar UNITLESS = {\n  animationIterationCount: true,\n  borderImage: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  initialLetter: true,\n  lineClamp: true,\n  lineHeight: true,\n  maxLines: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  scale: true,\n  tabSize: true,\n  WebkitLineClamp: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // svg properties\n  fillOpacity: true,\n  floodOpacity: true,\n  maskBorder: true,\n  maskBorderOutset: true,\n  maskBorderSlice: true,\n  maskBorderWidth: true,\n  shapeImageThreshold: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nfunction dashify(str) {\n  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();\n}\nfunction replaceBetweenIndexes(target, startIndex, endIndex, replacement) {\n  var start = target.slice(0, startIndex);\n  var end = target.slice(endIndex);\n  return \"\".concat(start).concat(replacement).concat(end);\n}\nvar DOUBLE_SPACE = '  ';\nvar specialKeys = [...simplePseudos, '@layer', '@media', '@supports', '@container', 'selectors'];\nclass Stylesheet {\n  constructor(localClassNames, composedClassLists) {\n    this.rules = [];\n    this.conditionalRulesets = [new ConditionalRuleset()];\n    this.fontFaceRules = [];\n    this.keyframesRules = [];\n    this.propertyRules = [];\n    this.localClassNamesMap = new Map(localClassNames.map(localClassName => [localClassName, localClassName]));\n    this.localClassNamesSearch = new modern_ahocorasick__WEBPACK_IMPORTED_MODULE_1__[\"default\"](localClassNames);\n    this.layers = new Map();\n\n    // Class list compositions should be priortized by Newer > Older\n    // Therefore we reverse the array as they are added in sequence\n    this.composedClassLists = composedClassLists.map(_ref => {\n      var {\n        identifier,\n        classList\n      } = _ref;\n      return {\n        identifier,\n        regex: RegExp(\"(\".concat(classList, \")\"), 'g')\n      };\n    }).reverse();\n  }\n  processCssObj(root) {\n    if (root.type === 'fontFace') {\n      this.fontFaceRules.push(root.rule);\n      return;\n    }\n    if (root.type === 'property') {\n      this.propertyRules.push(root);\n      return;\n    }\n    if (root.type === 'keyframes') {\n      root.rule = Object.fromEntries(Object.entries(root.rule).map(_ref2 => {\n        var [keyframe, rule] = _ref2;\n        return [keyframe, this.transformVars(this.transformProperties(rule))];\n      }));\n      this.keyframesRules.push(root);\n      return;\n    }\n    this.currConditionalRuleset = new ConditionalRuleset();\n    if (root.type === 'layer') {\n      var layerDefinition = \"@layer \".concat(root.name);\n      this.addLayer([layerDefinition]);\n    } else {\n      // Add main styles\n      var mainRule = omit(root.rule, specialKeys);\n      this.addRule({\n        selector: root.selector,\n        rule: mainRule\n      });\n      this.transformLayer(root, root.rule['@layer']);\n      this.transformMedia(root, root.rule['@media']);\n      this.transformSupports(root, root.rule['@supports']);\n      this.transformContainer(root, root.rule['@container']);\n      this.transformSimplePseudos(root, root.rule);\n      this.transformSelectors(root, root.rule);\n    }\n    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];\n    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {\n      // Ruleset merge failed due to incompatibility. We now deopt by starting a fresh ConditionalRuleset\n      this.conditionalRulesets.push(this.currConditionalRuleset);\n    }\n  }\n  addConditionalRule(cssRule, conditions) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    if (!this.currConditionalRuleset) {\n      throw new Error(\"Couldn't add conditional rule\");\n    }\n    var conditionQuery = conditions[conditions.length - 1];\n    var parentConditions = conditions.slice(0, conditions.length - 1);\n    this.currConditionalRuleset.addRule({\n      selector,\n      rule\n    }, conditionQuery, parentConditions);\n  }\n  addRule(cssRule) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    this.rules.push({\n      selector,\n      rule\n    });\n  }\n  addLayer(layer) {\n    var uniqueLayerKey = layer.join(' - ');\n    this.layers.set(uniqueLayerKey, layer);\n  }\n  transformProperties(cssRule) {\n    return this.transformContent(this.pixelifyProperties(cssRule));\n  }\n  pixelifyProperties(cssRule) {\n    forEach(cssRule, (value, key) => {\n      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {\n        // @ts-expect-error Any ideas?\n        cssRule[key] = \"\".concat(value, \"px\");\n      }\n    });\n    return cssRule;\n  }\n  transformVars(_ref3) {\n    var {\n        vars\n      } = _ref3,\n      rest = _objectWithoutProperties(_ref3, _excluded);\n    if (!vars) {\n      return rest;\n    }\n    return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_6__.getVarName)(key))), rest);\n  }\n  transformContent(_ref4) {\n    var {\n        content\n      } = _ref4,\n      rest = _objectWithoutProperties(_ref4, _excluded2);\n    if (typeof content === 'undefined') {\n      return rest;\n    }\n\n    // Handle fallback arrays:\n    var contentArray = Array.isArray(content) ? content : [content];\n    return _objectSpread2({\n      content: contentArray.map(value =>\n      // This logic was adapted from Stitches :)\n      value && (value.includes('\"') || value.includes(\"'\") || /^([A-Za-z\\-]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\\s|$)/.test(value)) ? value : \"\\\"\".concat(value, \"\\\"\"))\n    }, rest);\n  }\n  transformClassname(identifier) {\n    return \".\".concat(cssesc__WEBPACK_IMPORTED_MODULE_0___default()(identifier, {\n      isIdentifier: true\n    }));\n  }\n  transformSelector(selector) {\n    // Map class list compositions to single identifiers\n    var transformedSelector = selector;\n    var _loop = function _loop(identifier) {\n      transformedSelector = transformedSelector.replace(regex, () => {\n        (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_7__.markCompositionUsed)(identifier);\n        return identifier;\n      });\n    };\n    for (var {\n      identifier,\n      regex\n    } of this.composedClassLists) {\n      _loop(identifier);\n    }\n    if (this.localClassNamesMap.has(transformedSelector)) {\n      return this.transformClassname(transformedSelector);\n    }\n    var results = this.localClassNamesSearch.search(transformedSelector);\n    var lastReplaceIndex = transformedSelector.length;\n\n    // Perform replacements backwards to simplify index handling\n    for (var i = results.length - 1; i >= 0; i--) {\n      var [endIndex, [firstMatch]] = results[i];\n      var startIndex = endIndex - firstMatch.length + 1;\n\n      // Class names can be substrings of other class names\n      // e.g. '_1g1ptzo1' and '_1g1ptzo10'\n      //\n      // Additionally, concatenated classnames can contain substrings equal to other classnames\n      // e.g. '&&' where '&' is 'debugName_hash1' and 'debugName_hash1d' is also a local classname\n      // Before transforming the selector, this would look like `debugName_hash1debugName_hash1`\n      // which contains the substring `debugName_hash1d`â€™.\n      //\n      // In either of these cases, the last replace index will occur either before or within the\n      // current replacement range (from `startIndex` to `endIndex`).\n      // If this occurs, we skip the replacement to avoid transforming the selector incorrectly.\n      var skipReplacement = lastReplaceIndex <= endIndex;\n      if (skipReplacement) {\n        continue;\n      }\n      lastReplaceIndex = startIndex;\n\n      // If class names already starts with a '.' then skip\n      if (transformedSelector[startIndex - 1] !== '.') {\n        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));\n      }\n    }\n    return transformedSelector;\n  }\n  transformSelectors(root, rule, conditions) {\n    forEach(rule.selectors, (selectorRule, selector) => {\n      if (root.type !== 'local') {\n        throw new Error(\"Selectors are not allowed within \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n      }\n      var transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));\n      validateSelector(transformedSelector, root.selector);\n      var rule = {\n        selector: transformedSelector,\n        rule: omit(selectorRule, specialKeys)\n      };\n      if (conditions) {\n        this.addConditionalRule(rule, conditions);\n      } else {\n        this.addRule(rule);\n      }\n      var selectorRoot = {\n        type: 'selector',\n        selector: transformedSelector,\n        rule: selectorRule\n      };\n      this.transformLayer(selectorRoot, selectorRule['@layer'], conditions);\n      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);\n      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);\n      this.transformContainer(selectorRoot, selectorRule['@container'], conditions);\n    });\n  }\n  transformMedia(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional;\n      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@media \".concat(query)));\n      for (var [query, mediaRule] of Object.entries(rules)) {\n        var mediaQuery = \"@media \".concat(query);\n        validateMediaQuery(mediaQuery);\n        var conditions = [...parentConditions, mediaQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(mediaRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, mediaRule, conditions);\n          this.transformSelectors(root, mediaRule, conditions);\n        }\n        this.transformLayer(root, mediaRule['@layer'], conditions);\n        this.transformSupports(root, mediaRule['@supports'], conditions);\n        this.transformContainer(root, mediaRule['@container'], conditions);\n      }\n    }\n  }\n  transformContainer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional2;\n      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@container \".concat(query)));\n      forEach(rules, (containerRule, query) => {\n        var containerQuery = \"@container \".concat(query);\n        var conditions = [...parentConditions, containerQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(containerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, containerRule, conditions);\n          this.transformSelectors(root, containerRule, conditions);\n        }\n        this.transformLayer(root, containerRule['@layer'], conditions);\n        this.transformSupports(root, containerRule['@supports'], conditions);\n        this.transformMedia(root, containerRule['@media'], conditions);\n      });\n    }\n  }\n  transformLayer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional3;\n      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map(name => \"@layer \".concat(name)));\n      forEach(rules, (layerRule, name) => {\n        var conditions = [...parentConditions, \"@layer \".concat(name)];\n        this.addLayer(conditions);\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(layerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, layerRule, conditions);\n          this.transformSelectors(root, layerRule, conditions);\n        }\n        this.transformMedia(root, layerRule['@media'], conditions);\n        this.transformSupports(root, layerRule['@supports'], conditions);\n        this.transformContainer(root, layerRule['@container'], conditions);\n      });\n    }\n  }\n  transformSupports(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional4;\n      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@supports \".concat(query)));\n      forEach(rules, (supportsRule, query) => {\n        var conditions = [...parentConditions, \"@supports \".concat(query)];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(supportsRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, supportsRule, conditions);\n          this.transformSelectors(root, supportsRule, conditions);\n        }\n        this.transformLayer(root, supportsRule['@layer'], conditions);\n        this.transformMedia(root, supportsRule['@media'], conditions);\n        this.transformContainer(root, supportsRule['@container'], conditions);\n      });\n    }\n  }\n  transformSimplePseudos(root, rule, conditions) {\n    for (var key of Object.keys(rule)) {\n      // Process simple pseudos\n      if (simplePseudoLookup[key]) {\n        if (root.type !== 'local') {\n          throw new Error(\"Simple pseudos are not valid in \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n        }\n        if (conditions) {\n          this.addConditionalRule({\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          }, conditions);\n        } else {\n          this.addRule({\n            conditions,\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          });\n        }\n      }\n    }\n  }\n  toCss() {\n    var css = [];\n\n    // Render font-face rules\n    for (var fontFaceRule of this.fontFaceRules) {\n      css.push(renderCss({\n        '@font-face': fontFaceRule\n      }));\n    }\n\n    // Render property rules\n    for (var property of this.propertyRules) {\n      css.push(renderCss({\n        [\"@property \".concat(property.name)]: property.rule\n      }));\n    }\n\n    // Render keyframes\n    for (var keyframe of this.keyframesRules) {\n      css.push(renderCss({\n        [\"@keyframes \".concat(keyframe.name)]: keyframe.rule\n      }));\n    }\n\n    // Render layer definitions\n    for (var layer of this.layers.values()) {\n      var [definition, ...nesting] = layer.reverse();\n      var cssObj = {\n        [definition]: DECLARATION\n      };\n      for (var part of nesting) {\n        cssObj = {\n          [part]: cssObj\n        };\n      }\n      css.push(renderCss(cssObj));\n    }\n\n    // Render unconditional rules\n    for (var rule of this.rules) {\n      css.push(renderCss({\n        [rule.selector]: rule.rule\n      }));\n    }\n\n    // Render conditional rules\n    for (var conditionalRuleset of this.conditionalRulesets) {\n      for (var conditionalRule of conditionalRuleset.renderToArray()) {\n        css.push(renderCss(conditionalRule));\n      }\n    }\n    return css.filter(Boolean);\n  }\n}\nfunction renderCss(v) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var rules = [];\n  var _loop2 = function _loop2(key) {\n    var value = v[key];\n    if (value && Array.isArray(value)) {\n      rules.push(...value.map(v => renderCss({\n        [key]: v\n      }, indent)));\n    } else if (value && typeof value === 'object') {\n      var isEmpty = Object.keys(value).length === 0;\n      if (!isEmpty) {\n        rules.push(\"\".concat(indent).concat(key, \" {\\n\").concat(renderCss(value, indent + DOUBLE_SPACE), \"\\n\").concat(indent, \"}\"));\n      }\n    } else if (value === DECLARATION) {\n      rules.push(\"\".concat(indent).concat(key, \";\"));\n    } else {\n      rules.push(\"\".concat(indent).concat(key.startsWith('--') ? key : dashify(key), \": \").concat(value, \";\"));\n    }\n  };\n  for (var key of Object.keys(v)) {\n    _loop2(key);\n  }\n  return rules.join('\\n');\n}\nfunction transformCss(_ref5) {\n  var {\n    localClassNames,\n    cssObjs,\n    composedClassLists\n  } = _ref5;\n  var stylesheet = new Stylesheet(localClassNames, composedClassLists);\n  for (var root of cssObjs) {\n    stylesheet.processCssObj(root);\n  }\n  return stylesheet.toCss();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdHJhbnNmb3JtQ3NzLTBkYmEzNmJmLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQzFCO0FBQ2lCO0FBQzRDO0FBQ0g7QUFDckQ7QUFDTDtBQUNlOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csY0FBYztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkNBQU07QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQUs7QUFDekIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixrREFBTSwyQ0FBMkMseUVBQXNCLDhyQkFBOHJCLEtBQUsscUNBQXFDLFFBQVEsU0FBUyxRQUFRLGlCQUFpQixNQUFNLFFBQVEsUUFBUSxtQkFBbUIsUUFBUTtBQUNoNkI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGtEQUFNLHVDQUF1Qyx5RUFBc0I7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBSztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBEQUFXO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDLG9FQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUdBQW1CO0FBQzNCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvREFBb0QsNEVBQTRFO0FBQ2hJO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRDtBQUNqRCxNQUFNO0FBQ04sMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVyb3ZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L2Nzcy9kaXN0L3RyYW5zZm9ybUNzcy0wZGJhMzZiZi5lc20uanM/MDMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRWYXJOYW1lIH0gZnJvbSAnQHZhbmlsbGEtZXh0cmFjdC9wcml2YXRlJztcbmltcG9ydCBjc3Nlc2MgZnJvbSAnY3NzZXNjJztcbmltcG9ydCBBaG9Db3Jhc2ljayBmcm9tICdtb2Rlcm4tYWhvY29yYXNpY2snO1xuaW1wb3J0IHsgbWFya0NvbXBvc2l0aW9uVXNlZCB9IGZyb20gJy4uL2FkYXB0ZXIvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLWFkYXB0ZXIuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbCB9IGZyb20gJy4vdGFnZ2VkVGVtcGxhdGVMaXRlcmFsLTEwOTk4MzE1LmVzbS5qcyc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ2Nzcy13aGF0JztcbmltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcbmltcG9ydCB7IHRvQVNUIH0gZnJvbSAnbWVkaWEtcXVlcnktcGFyc2VyJztcblxuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogU3RyaW5nKGkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgZm4ob2JqW19rZXldLCBfa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gb21pdChvYmosIG9taXRLZXlzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgX2tleTIgaW4gb2JqKSB7XG4gICAgaWYgKG9taXRLZXlzLmluZGV4T2YoX2tleTIpID09PSAtMSkge1xuICAgICAgcmVzdWx0W19rZXkyXSA9IG9ialtfa2V5Ml07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBLZXlzKG9iaiwgZm4pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBfa2V5MyBpbiBvYmopIHtcbiAgICByZXN1bHRbZm4ob2JqW19rZXkzXSwgX2tleTMpXSA9IG9ialtfa2V5M107XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VTdHlsZXNJbnRvU2V0KHNldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2xhc3NOYW1lcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuOyBfa2V5NSsrKSB7XG4gICAgY2xhc3NOYW1lc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuICBmb3IgKHZhciBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgY29tcG9zZVN0eWxlc0ludG9TZXQoc2V0LCAuLi5jbGFzc05hbWUudHJpbSgpLnNwbGl0KCcgJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjbGFzc05hbWUpKSB7XG4gICAgICBjb21wb3NlU3R5bGVzSW50b1NldChzZXQsIC4uLmNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkdWR1cGVBbmRKb2luQ2xhc3NMaXN0KGNsYXNzTmFtZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQoKTtcbiAgY29tcG9zZVN0eWxlc0ludG9TZXQoc2V0LCAuLi5jbGFzc05hbWVzKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KS5qb2luKCcgJyk7XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG52YXIgdmFsaWRhdGVTZWxlY3RvciA9IChzZWxlY3RvciwgdGFyZ2V0Q2xhc3NOYW1lKSA9PiB7XG4gIHZhciByZXBsYWNlVGFyZ2V0ID0gKCkgPT4ge1xuICAgIHZhciB0YXJnZXRSZWdleCA9IG5ldyBSZWdFeHAoXCIuXCIuY29uY2F0KGVzY2FwZVJlZ2V4KGNzc2VzYyh0YXJnZXRDbGFzc05hbWUsIHtcbiAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICAgIH0pKSksICdnJyk7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UodGFyZ2V0UmVnZXgsICcmJyk7XG4gIH07XG4gIHZhciBzZWxlY3RvclBhcnRzO1xuICB0cnkge1xuICAgIHNlbGVjdG9yUGFydHMgPSBwYXJzZShzZWxlY3Rvcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3I6IFwiLmNvbmNhdChyZXBsYWNlVGFyZ2V0KCkpKTtcbiAgfVxuICBzZWxlY3RvclBhcnRzLmZvckVhY2godG9rZW5zID0+IHtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgaWYgKCF0b2tlbnNbaV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY2hpbGQnIHx8IHRva2VuLnR5cGUgPT09ICdwYXJlbnQnIHx8IHRva2VuLnR5cGUgPT09ICdzaWJsaW5nJyB8fCB0b2tlbi50eXBlID09PSAnYWRqYWNlbnQnIHx8IHRva2VuLnR5cGUgPT09ICdkZXNjZW5kYW50Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnYXR0cmlidXRlJyAmJiB0b2tlbi5uYW1lID09PSAnY2xhc3MnICYmIHRva2VuLnZhbHVlID09PSB0YXJnZXRDbGFzc05hbWUpIHtcbiAgICAgICAgICByZXR1cm47IC8vIEZvdW5kIGl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihkZWRlbnQoX3RlbXBsYXRlT2JqZWN0JDEgfHwgKF90ZW1wbGF0ZU9iamVjdCQxID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICAgIEludmFsaWQgc2VsZWN0b3I6IFwiLCBcIlxcbiAgICBcXG4gICAgICAgIFN0eWxlIHNlbGVjdG9ycyBtdXN0IHRhcmdldCB0aGUgJyYnIGNoYXJhY3RlciAoYWxvbmcgd2l0aCBhbnkgbW9kaWZpZXJzKSwgZS5nLiBcIiwgXCIgb3IgXCIsIFwiLlxcbiAgICAgICAgXFxuICAgICAgICBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IGVhY2ggc3R5bGUgYmxvY2sgb25seSBhZmZlY3RzIHRoZSBzdHlsaW5nIG9mIGEgc2luZ2xlIGNsYXNzLlxcbiAgICAgICAgXFxuICAgICAgICBJZiB5b3VyIHNlbGVjdG9yIGlzIHRhcmdldGluZyBhbm90aGVyIGNsYXNzLCB5b3Ugc2hvdWxkIG1vdmUgaXQgdG8gdGhlIHN0eWxlIGRlZmluaXRpb24gZm9yIHRoYXQgY2xhc3MsIGUuZy4gZ2l2ZW4gd2UgaGF2ZSBzdHlsZXMgZm9yICdwYXJlbnQnIGFuZCAnY2hpbGQnIGVsZW1lbnRzLCBpbnN0ZWFkIG9mIGFkZGluZyBhIHNlbGVjdG9yIG9mIFwiLCBcIikgdG8gJ3BhcmVudCcsIHlvdSBzaG91bGQgYWRkIFwiLCBcIiB0byAnY2hpbGQnKS5cXG4gICAgICAgIFxcbiAgICAgICAgSWYgeW91ciBzZWxlY3RvciBpcyB0YXJnZXRpbmcgc29tZXRoaW5nIGdsb2JhbCwgdXNlIHRoZSAnZ2xvYmFsU3R5bGUnIGZ1bmN0aW9uIGluc3RlYWQsIGUuZy4gaWYgeW91IHdhbnRlZCB0byB3cml0ZSBcIiwgXCIsIHlvdSBzaG91bGQgaW5zdGVhZCB3cml0ZSAnZ2xvYmFsU3R5bGUoXCIsIFwiLCB7IC4uLiB9KSdcXG4gICAgICBcIl0pKSwgcmVwbGFjZVRhcmdldCgpLCAnYCR7cGFyZW50fSAmYCcsICdgJHtwYXJlbnR9ICY6aG92ZXJgJywgJ2AmICR7Y2hpbGR9YCcsICdgJHtwYXJlbnR9ICZgJywgJ2AmIGgxYCcsICdgJHtwYXJlbnR9IGgxYCcpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqIGUuZy4gQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNTAwcHgpICovXG5cbmNsYXNzIENvbmRpdGlvbmFsUnVsZXNldCB7XG4gIC8qKlxuICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgY29uZGl0aW9ucyBtdXN0IGJlIGluIHJlbGF0aW9uIHRvIG90aGVyIGNvbmRpdGlvbnNcbiAgICpcbiAgICogZS5nLiBtb2JpbGUgLT4gdGFibGV0LCBkZXNrdG9wXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucnVsZXNldCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZWNlZGVuY2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZmluZE9yQ3JlYXRlQ29uZGl0aW9uKGNvbmRpdGlvblF1ZXJ5KSB7XG4gICAgdmFyIHRhcmdldENvbmRpdGlvbiA9IHRoaXMucnVsZXNldC5nZXQoY29uZGl0aW9uUXVlcnkpO1xuICAgIGlmICghdGFyZ2V0Q29uZGl0aW9uKSB7XG4gICAgICAvLyBObyB0YXJnZXQgY29uZGl0aW9uIHNvIGNyZWF0ZSBvbmVcbiAgICAgIHRhcmdldENvbmRpdGlvbiA9IHtcbiAgICAgICAgcXVlcnk6IGNvbmRpdGlvblF1ZXJ5LFxuICAgICAgICBydWxlczogW10sXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgQ29uZGl0aW9uYWxSdWxlc2V0KClcbiAgICAgIH07XG4gICAgICB0aGlzLnJ1bGVzZXQuc2V0KGNvbmRpdGlvblF1ZXJ5LCB0YXJnZXRDb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0Q29uZGl0aW9uO1xuICB9XG4gIGdldENvbmRpdGlvbmFsUnVsZXNldEJ5UGF0aChjb25kaXRpb25QYXRoKSB7XG4gICAgdmFyIGN1cnJSdWxlc2V0ID0gdGhpcztcbiAgICBmb3IgKHZhciBxdWVyeSBvZiBjb25kaXRpb25QYXRoKSB7XG4gICAgICB2YXIgY29uZGl0aW9uID0gY3VyclJ1bGVzZXQuZmluZE9yQ3JlYXRlQ29uZGl0aW9uKHF1ZXJ5KTtcbiAgICAgIGN1cnJSdWxlc2V0ID0gY29uZGl0aW9uLmNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gY3VyclJ1bGVzZXQ7XG4gIH1cbiAgYWRkUnVsZShydWxlLCBjb25kaXRpb25RdWVyeSwgY29uZGl0aW9uUGF0aCkge1xuICAgIHZhciBydWxlc2V0ID0gdGhpcy5nZXRDb25kaXRpb25hbFJ1bGVzZXRCeVBhdGgoY29uZGl0aW9uUGF0aCk7XG4gICAgdmFyIHRhcmdldENvbmRpdGlvbiA9IHJ1bGVzZXQuZmluZE9yQ3JlYXRlQ29uZGl0aW9uKGNvbmRpdGlvblF1ZXJ5KTtcbiAgICBpZiAoIXRhcmdldENvbmRpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYWRkIGNvbmRpdGlvbmFsIHJ1bGUnKTtcbiAgICB9XG4gICAgdGFyZ2V0Q29uZGl0aW9uLnJ1bGVzLnB1c2gocnVsZSk7XG4gIH1cbiAgYWRkQ29uZGl0aW9uUHJlY2VkZW5jZShjb25kaXRpb25QYXRoLCBjb25kaXRpb25PcmRlcikge1xuICAgIHZhciBydWxlc2V0ID0gdGhpcy5nZXRDb25kaXRpb25hbFJ1bGVzZXRCeVBhdGgoY29uZGl0aW9uUGF0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25kaXRpb25PcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ydWxlc2V0JHByZWNlZGVuY2VMbztcbiAgICAgIHZhciBxdWVyeSA9IGNvbmRpdGlvbk9yZGVyW2ldO1xuICAgICAgdmFyIGNvbmRpdGlvblByZWNlZGVuY2UgPSAoX3J1bGVzZXQkcHJlY2VkZW5jZUxvID0gcnVsZXNldC5wcmVjZWRlbmNlTG9va3VwLmdldChxdWVyeSkpICE9PSBudWxsICYmIF9ydWxlc2V0JHByZWNlZGVuY2VMbyAhPT0gdm9pZCAwID8gX3J1bGVzZXQkcHJlY2VkZW5jZUxvIDogbmV3IFNldCgpO1xuICAgICAgZm9yICh2YXIgbG93ZXJQcmVjZWRlbmNlQ29uZGl0aW9uIG9mIGNvbmRpdGlvbk9yZGVyLnNsaWNlKGkgKyAxKSkge1xuICAgICAgICBjb25kaXRpb25QcmVjZWRlbmNlLmFkZChsb3dlclByZWNlZGVuY2VDb25kaXRpb24pO1xuICAgICAgfVxuICAgICAgcnVsZXNldC5wcmVjZWRlbmNlTG9va3VwLnNldChxdWVyeSwgY29uZGl0aW9uUHJlY2VkZW5jZSk7XG4gICAgfVxuICB9XG4gIGlzQ29tcGF0aWJsZShpbmNvbWluZ1J1bGVzZXQpIHtcbiAgICBmb3IgKHZhciBbY29uZGl0aW9uLCBvcmRlclByZWNlZGVuY2VdIG9mIHRoaXMucHJlY2VkZW5jZUxvb2t1cC5lbnRyaWVzKCkpIHtcbiAgICAgIGZvciAodmFyIGxvd2VyUHJlY2VkZW5jZUNvbmRpdGlvbiBvZiBvcmRlclByZWNlZGVuY2UpIHtcbiAgICAgICAgdmFyIF9pbmNvbWluZ1J1bGVzZXQkcHJlYztcbiAgICAgICAgaWYgKChfaW5jb21pbmdSdWxlc2V0JHByZWMgPSBpbmNvbWluZ1J1bGVzZXQucHJlY2VkZW5jZUxvb2t1cC5nZXQobG93ZXJQcmVjZWRlbmNlQ29uZGl0aW9uKSkgIT09IG51bGwgJiYgX2luY29taW5nUnVsZXNldCRwcmVjICE9PSB2b2lkIDAgJiYgX2luY29taW5nUnVsZXNldCRwcmVjLmhhcyhjb25kaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBjaGlsZHJlbiBhcmUgY29tcGF0aWJsZVxuICAgIGZvciAodmFyIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgY2hpbGRyZW5cbiAgICB9IG9mIGluY29taW5nUnVsZXNldC5ydWxlc2V0LnZhbHVlcygpKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdDb25kaXRpb24gPSB0aGlzLnJ1bGVzZXQuZ2V0KHF1ZXJ5KTtcbiAgICAgIGlmIChtYXRjaGluZ0NvbmRpdGlvbiAmJiAhbWF0Y2hpbmdDb25kaXRpb24uY2hpbGRyZW4uaXNDb21wYXRpYmxlKGNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG1lcmdlKGluY29taW5nUnVsZXNldCkge1xuICAgIC8vIE1lcmdlIHJ1bGVzZXRzIGludG8gb25lIGFycmF5XG4gICAgZm9yICh2YXIge1xuICAgICAgcXVlcnksXG4gICAgICBydWxlcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSBvZiBpbmNvbWluZ1J1bGVzZXQucnVsZXNldC52YWx1ZXMoKSkge1xuICAgICAgdmFyIG1hdGNoaW5nQ29uZGl0aW9uID0gdGhpcy5ydWxlc2V0LmdldChxdWVyeSk7XG4gICAgICBpZiAobWF0Y2hpbmdDb25kaXRpb24pIHtcbiAgICAgICAgbWF0Y2hpbmdDb25kaXRpb24ucnVsZXMucHVzaCguLi5ydWxlcyk7XG4gICAgICAgIG1hdGNoaW5nQ29uZGl0aW9uLmNoaWxkcmVuLm1lcmdlKGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVsZXNldC5zZXQocXVlcnksIHtcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICBydWxlcyxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJnZSBvcmRlciBwcmVjZWRlbmNlc1xuICAgIGZvciAodmFyIFtjb25kaXRpb24sIGluY29taW5nT3JkZXJQcmVjZWRlbmNlXSBvZiBpbmNvbWluZ1J1bGVzZXQucHJlY2VkZW5jZUxvb2t1cC5lbnRyaWVzKCkpIHtcbiAgICAgIHZhciBfdGhpcyRwcmVjZWRlbmNlTG9va3U7XG4gICAgICB2YXIgb3JkZXJQcmVjZWRlbmNlID0gKF90aGlzJHByZWNlZGVuY2VMb29rdSA9IHRoaXMucHJlY2VkZW5jZUxvb2t1cC5nZXQoY29uZGl0aW9uKSkgIT09IG51bGwgJiYgX3RoaXMkcHJlY2VkZW5jZUxvb2t1ICE9PSB2b2lkIDAgPyBfdGhpcyRwcmVjZWRlbmNlTG9va3UgOiBuZXcgU2V0KCk7XG4gICAgICB0aGlzLnByZWNlZGVuY2VMb29rdXAuc2V0KGNvbmRpdGlvbiwgbmV3IFNldChbLi4ub3JkZXJQcmVjZWRlbmNlLCAuLi5pbmNvbWluZ09yZGVyUHJlY2VkZW5jZV0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW5vdGhlciBDb25kaXRpb25hbFJ1bGVzZXQgaW50byB0aGlzIG9uZSBpZiB0aGV5IGFyZSBjb21wYXRpYmxlXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2UgaWYgdGhlIHJ1bGVzZXQgaXMgaW5jb21wYXRpYmxlXG4gICAqL1xuICBtZXJnZUlmQ29tcGF0aWJsZShpbmNvbWluZ1J1bGVzZXQpIHtcbiAgICBpZiAoIXRoaXMuaXNDb21wYXRpYmxlKGluY29taW5nUnVsZXNldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5tZXJnZShpbmNvbWluZ1J1bGVzZXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFNvcnRlZFJ1bGVzZXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgc29ydGVkUnVsZXNldCA9IFtdO1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBxdWVyaWVzIGFuZCBhZGQgdGhlbSB0byB0aGUgc29ydGVkIHJ1bGVzZXRcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChkZXBlbmRlbnRzKSB7XG4gICAgICB2YXIgY29uZGl0aW9uRm9yUXVlcnkgPSBfdGhpcy5ydWxlc2V0LmdldChxdWVyeSk7XG4gICAgICBpZiAoIWNvbmRpdGlvbkZvclF1ZXJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgY29uZGl0aW9uIGZvciBcIi5jb25jYXQocXVlcnkpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IGRlcGVuZGVudCBjb25kaXRpb24gaW4gdGhlIHNvcnRlZFJ1bGVzZXRcbiAgICAgIC8vIEEgZGVwZW5kZW50IGNvbmRpdGlvbiBpcyBhIGNvbmRpdGlvbiB0aGF0IG11c3QgYmUgcGxhY2VkICphZnRlciogdGhlIGN1cnJlbnQgb25lXG4gICAgICB2YXIgZmlyc3RNYXRjaGluZ0RlcGVuZGVudCA9IHNvcnRlZFJ1bGVzZXQuZmluZEluZGV4KGNvbmRpdGlvbiA9PiBkZXBlbmRlbnRzLmhhcyhjb25kaXRpb24ucXVlcnkpKTtcbiAgICAgIGlmIChmaXJzdE1hdGNoaW5nRGVwZW5kZW50ID4gLTEpIHtcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBjb25kaXRpb24gYmVmb3JlIHRoZSBkZXBlbmRlbnQgb25lXG4gICAgICAgIHNvcnRlZFJ1bGVzZXQuc3BsaWNlKGZpcnN0TWF0Y2hpbmdEZXBlbmRlbnQsIDAsIGNvbmRpdGlvbkZvclF1ZXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIG1hdGNoLCBqdXN0IGluc2VydCBhdCB0aGUgZW5kXG4gICAgICAgIHNvcnRlZFJ1bGVzZXQucHVzaChjb25kaXRpb25Gb3JRdWVyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBbcXVlcnksIGRlcGVuZGVudHNdIG9mIHRoaXMucHJlY2VkZW5jZUxvb2t1cC5lbnRyaWVzKCkpIHtcbiAgICAgIF9sb29wKGRlcGVuZGVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkUnVsZXNldDtcbiAgfVxuICByZW5kZXJUb0FycmF5KCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciB7XG4gICAgICBxdWVyeSxcbiAgICAgIHJ1bGVzLFxuICAgICAgY2hpbGRyZW5cbiAgICB9IG9mIHRoaXMuZ2V0U29ydGVkUnVsZXNldCgpKSB7XG4gICAgICB2YXIgc2VsZWN0b3JzID0ge307XG4gICAgICBmb3IgKHZhciBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgIHNlbGVjdG9yc1tydWxlLnNlbGVjdG9yXSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzZWxlY3RvcnNbcnVsZS5zZWxlY3Rvcl0pLCBydWxlLnJ1bGUpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihzZWxlY3RvcnMsIC4uLmNoaWxkcmVuLnJlbmRlclRvQXJyYXkoKSk7XG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIFtxdWVyeV06IHNlbGVjdG9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cbn1cblxudmFyIHNpbXBsZVBzZXVkb01hcCA9IHtcbiAgJzotbW96LWFueS1saW5rJzogdHJ1ZSxcbiAgJzotbW96LWZ1bGwtc2NyZWVuJzogdHJ1ZSxcbiAgJzotbW96LXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgJzotbW96LXJlYWQtb25seSc6IHRydWUsXG4gICc6LW1vei1yZWFkLXdyaXRlJzogdHJ1ZSxcbiAgJzotbXMtZnVsbHNjcmVlbic6IHRydWUsXG4gICc6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgJzotd2Via2l0LWFueS1saW5rJzogdHJ1ZSxcbiAgJzotd2Via2l0LWZ1bGwtc2NyZWVuJzogdHJ1ZSxcbiAgJzo6LW1vei1jb2xvci1zd2F0Y2gnOiB0cnVlLFxuICAnOjotbW96LWxpc3QtYnVsbGV0JzogdHJ1ZSxcbiAgJzo6LW1vei1saXN0LW51bWJlcic6IHRydWUsXG4gICc6Oi1tb3otcGFnZS1zZXF1ZW5jZSc6IHRydWUsXG4gICc6Oi1tb3otcGFnZSc6IHRydWUsXG4gICc6Oi1tb3otcGxhY2Vob2xkZXInOiB0cnVlLFxuICAnOjotbW96LXByb2dyZXNzLWJhcic6IHRydWUsXG4gICc6Oi1tb3otcmFuZ2UtcHJvZ3Jlc3MnOiB0cnVlLFxuICAnOjotbW96LXJhbmdlLXRodW1iJzogdHJ1ZSxcbiAgJzo6LW1vei1yYW5nZS10cmFjayc6IHRydWUsXG4gICc6Oi1tb3otc2Nyb2xsZWQtcGFnZS1zZXF1ZW5jZSc6IHRydWUsXG4gICc6Oi1tb3otc2VsZWN0aW9uJzogdHJ1ZSxcbiAgJzo6LW1zLWJhY2tkcm9wJzogdHJ1ZSxcbiAgJzo6LW1zLWJyb3dzZSc6IHRydWUsXG4gICc6Oi1tcy1jaGVjayc6IHRydWUsXG4gICc6Oi1tcy1jbGVhcic6IHRydWUsXG4gICc6Oi1tcy1maWxsLWxvd2VyJzogdHJ1ZSxcbiAgJzo6LW1zLWZpbGwtdXBwZXInOiB0cnVlLFxuICAnOjotbXMtZmlsbCc6IHRydWUsXG4gICc6Oi1tcy1yZXZlYWwnOiB0cnVlLFxuICAnOjotbXMtdGh1bWInOiB0cnVlLFxuICAnOjotbXMtdGlja3MtYWZ0ZXInOiB0cnVlLFxuICAnOjotbXMtdGlja3MtYmVmb3JlJzogdHJ1ZSxcbiAgJzo6LW1zLXRvb2x0aXAnOiB0cnVlLFxuICAnOjotbXMtdHJhY2snOiB0cnVlLFxuICAnOjotbXMtdmFsdWUnOiB0cnVlLFxuICAnOjotd2Via2l0LWJhY2tkcm9wJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1jYWxlbmRhci1waWNrZXItaW5kaWNhdG9yJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbic6IHRydWUsXG4gICc6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXInOiB0cnVlLFxuICAnOjotd2Via2l0LW1ldGVyLWJhcic6IHRydWUsXG4gICc6Oi13ZWJraXQtbWV0ZXItZXZlbi1sZXNzLWdvb2QtdmFsdWUnOiB0cnVlLFxuICAnOjotd2Via2l0LW1ldGVyLWlubmVyLWVsZW1lbnQnOiB0cnVlLFxuICAnOjotd2Via2l0LW1ldGVyLW9wdGltdW0tdmFsdWUnOiB0cnVlLFxuICAnOjotd2Via2l0LW1ldGVyLXN1Ym9wdGltdW0tdmFsdWUnOiB0cnVlLFxuICAnOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1wcm9ncmVzcy1iYXInOiB0cnVlLFxuICAnOjotd2Via2l0LXByb2dyZXNzLWlubmVyLWVsZW1lbnQnOiB0cnVlLFxuICAnOjotd2Via2l0LXByb2dyZXNzLWlubmVyLXZhbHVlJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1wcm9ncmVzcy12YWx1ZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtcmVzaXplcic6IHRydWUsXG4gICc6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbic6IHRydWUsXG4gICc6Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcic6IHRydWUsXG4gICc6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2UnOiB0cnVlLFxuICAnOjotd2Via2l0LXNjcm9sbGJhci10cmFjayc6IHRydWUsXG4gICc6Oi13ZWJraXQtc2Nyb2xsYmFyJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbic6IHRydWUsXG4gICc6Oi13ZWJraXQtc2VhcmNoLXJlc3VsdHMtYnV0dG9uJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2snOiB0cnVlLFxuICAnOjotd2Via2l0LXNsaWRlci10aHVtYic6IHRydWUsXG4gICc6OmFmdGVyJzogdHJ1ZSxcbiAgJzo6YmFja2Ryb3AnOiB0cnVlLFxuICAnOjpiZWZvcmUnOiB0cnVlLFxuICAnOjpjdWUnOiB0cnVlLFxuICAnOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbic6IHRydWUsXG4gICc6OmZpcnN0LWxldHRlcic6IHRydWUsXG4gICc6OmZpcnN0LWxpbmUnOiB0cnVlLFxuICAnOjpncmFtbWFyLWVycm9yJzogdHJ1ZSxcbiAgJzo6bWFya2VyJzogdHJ1ZSxcbiAgJzo6cGxhY2Vob2xkZXInOiB0cnVlLFxuICAnOjpzZWxlY3Rpb24nOiB0cnVlLFxuICAnOjpzcGVsbGluZy1lcnJvcic6IHRydWUsXG4gICc6OnRhcmdldC10ZXh0JzogdHJ1ZSxcbiAgJzo6dmlldy10cmFuc2l0aW9uLWdyb3VwJzogdHJ1ZSxcbiAgJzo6dmlldy10cmFuc2l0aW9uLWltYWdlLXBhaXInOiB0cnVlLFxuICAnOjp2aWV3LXRyYW5zaXRpb24tbmV3JzogdHJ1ZSxcbiAgJzo6dmlldy10cmFuc2l0aW9uLW9sZCc6IHRydWUsXG4gICc6OnZpZXctdHJhbnNpdGlvbic6IHRydWUsXG4gICc6YWN0aXZlJzogdHJ1ZSxcbiAgJzphZnRlcic6IHRydWUsXG4gICc6YW55LWxpbmsnOiB0cnVlLFxuICAnOmJlZm9yZSc6IHRydWUsXG4gICc6YmxhbmsnOiB0cnVlLFxuICAnOmNoZWNrZWQnOiB0cnVlLFxuICAnOmRlZmF1bHQnOiB0cnVlLFxuICAnOmRlZmluZWQnOiB0cnVlLFxuICAnOmRpc2FibGVkJzogdHJ1ZSxcbiAgJzplbXB0eSc6IHRydWUsXG4gICc6ZW5hYmxlZCc6IHRydWUsXG4gICc6Zmlyc3QtY2hpbGQnOiB0cnVlLFxuICAnOmZpcnN0LWxldHRlcic6IHRydWUsXG4gICc6Zmlyc3QtbGluZSc6IHRydWUsXG4gICc6Zmlyc3Qtb2YtdHlwZSc6IHRydWUsXG4gICc6Zmlyc3QnOiB0cnVlLFxuICAnOmZvY3VzLXZpc2libGUnOiB0cnVlLFxuICAnOmZvY3VzLXdpdGhpbic6IHRydWUsXG4gICc6Zm9jdXMnOiB0cnVlLFxuICAnOmZ1bGxzY3JlZW4nOiB0cnVlLFxuICAnOmhvdmVyJzogdHJ1ZSxcbiAgJzppbi1yYW5nZSc6IHRydWUsXG4gICc6aW5kZXRlcm1pbmF0ZSc6IHRydWUsXG4gICc6aW52YWxpZCc6IHRydWUsXG4gICc6bGFzdC1jaGlsZCc6IHRydWUsXG4gICc6bGFzdC1vZi10eXBlJzogdHJ1ZSxcbiAgJzpsZWZ0JzogdHJ1ZSxcbiAgJzpsaW5rJzogdHJ1ZSxcbiAgJzpvbmx5LWNoaWxkJzogdHJ1ZSxcbiAgJzpvbmx5LW9mLXR5cGUnOiB0cnVlLFxuICAnOm9wdGlvbmFsJzogdHJ1ZSxcbiAgJzpvdXQtb2YtcmFuZ2UnOiB0cnVlLFxuICAnOnBsYWNlaG9sZGVyLXNob3duJzogdHJ1ZSxcbiAgJzpyZWFkLW9ubHknOiB0cnVlLFxuICAnOnJlYWQtd3JpdGUnOiB0cnVlLFxuICAnOnJlcXVpcmVkJzogdHJ1ZSxcbiAgJzpyaWdodCc6IHRydWUsXG4gICc6cm9vdCc6IHRydWUsXG4gICc6c2NvcGUnOiB0cnVlLFxuICAnOnRhcmdldCc6IHRydWUsXG4gICc6dmFsaWQnOiB0cnVlLFxuICAnOnZpc2l0ZWQnOiB0cnVlXG59O1xudmFyIHNpbXBsZVBzZXVkb3MgPSBPYmplY3Qua2V5cyhzaW1wbGVQc2V1ZG9NYXApO1xudmFyIHNpbXBsZVBzZXVkb0xvb2t1cCA9IHNpbXBsZVBzZXVkb01hcDtcblxudmFyIF90ZW1wbGF0ZU9iamVjdDtcbnZhciBjcmVhdGVNZWRpYVF1ZXJ5RXJyb3IgPSAobWVkaWFRdWVyeSwgbXNnKSA9PiBuZXcgRXJyb3IoZGVkZW50KF90ZW1wbGF0ZU9iamVjdCB8fCAoX3RlbXBsYXRlT2JqZWN0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgSW52YWxpZCBtZWRpYSBxdWVyeTogXFxcIlwiLCBcIlxcXCJcXG5cXG4gICAgXCIsIFwiXFxuXFxuICAgIFJlYWQgbW9yZSBvbiBNRE46IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9NZWRpYV9RdWVyaWVzL1VzaW5nX21lZGlhX3F1ZXJpZXNcXG4gIFwiXSkpLCBtZWRpYVF1ZXJ5LCBtc2cpKTtcbnZhciB2YWxpZGF0ZU1lZGlhUXVlcnkgPSBtZWRpYVF1ZXJ5ID0+IHtcbiAgLy8gRW1wdHkgcXVlcmllcyB3aWxsIHN0YXJ0IHdpdGggJ0BtZWRpYSAnXG4gIGlmIChtZWRpYVF1ZXJ5ID09PSAnQG1lZGlhICcpIHtcbiAgICB0aHJvdyBjcmVhdGVNZWRpYVF1ZXJ5RXJyb3IobWVkaWFRdWVyeSwgJ1F1ZXJ5IGlzIGVtcHR5Jyk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0b0FTVChtZWRpYVF1ZXJ5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IGNyZWF0ZU1lZGlhUXVlcnlFcnJvcihtZWRpYVF1ZXJ5LCBlLm1lc3NhZ2UpO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1widmFyc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNvbnRlbnRcIl07XG52YXIgREVDTEFSQVRJT04gPSAnX19ERUNMQVJBVElPTic7XG52YXIgVU5JVExFU1MgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBncmlkQXJlYTogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGluaXRpYWxMZXR0ZXI6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgbWF4TGluZXM6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICBzY2FsZTogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgV2Via2l0TGluZUNsYW1wOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gc3ZnIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgbWFza0JvcmRlcjogdHJ1ZSxcbiAgbWFza0JvcmRlck91dHNldDogdHJ1ZSxcbiAgbWFza0JvcmRlclNsaWNlOiB0cnVlLFxuICBtYXNrQm9yZGVyV2lkdGg6IHRydWUsXG4gIHNoYXBlSW1hZ2VUaHJlc2hvbGQ6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGRhc2hpZnkoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykucmVwbGFjZSgvXm1zLS8sICctbXMtJykudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCZXR3ZWVuSW5kZXhlcyh0YXJnZXQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCByZXBsYWNlbWVudCkge1xuICB2YXIgc3RhcnQgPSB0YXJnZXQuc2xpY2UoMCwgc3RhcnRJbmRleCk7XG4gIHZhciBlbmQgPSB0YXJnZXQuc2xpY2UoZW5kSW5kZXgpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RhcnQpLmNvbmNhdChyZXBsYWNlbWVudCkuY29uY2F0KGVuZCk7XG59XG52YXIgRE9VQkxFX1NQQUNFID0gJyAgJztcbnZhciBzcGVjaWFsS2V5cyA9IFsuLi5zaW1wbGVQc2V1ZG9zLCAnQGxheWVyJywgJ0BtZWRpYScsICdAc3VwcG9ydHMnLCAnQGNvbnRhaW5lcicsICdzZWxlY3RvcnMnXTtcbmNsYXNzIFN0eWxlc2hlZXQge1xuICBjb25zdHJ1Y3Rvcihsb2NhbENsYXNzTmFtZXMsIGNvbXBvc2VkQ2xhc3NMaXN0cykge1xuICAgIHRoaXMucnVsZXMgPSBbXTtcbiAgICB0aGlzLmNvbmRpdGlvbmFsUnVsZXNldHMgPSBbbmV3IENvbmRpdGlvbmFsUnVsZXNldCgpXTtcbiAgICB0aGlzLmZvbnRGYWNlUnVsZXMgPSBbXTtcbiAgICB0aGlzLmtleWZyYW1lc1J1bGVzID0gW107XG4gICAgdGhpcy5wcm9wZXJ0eVJ1bGVzID0gW107XG4gICAgdGhpcy5sb2NhbENsYXNzTmFtZXNNYXAgPSBuZXcgTWFwKGxvY2FsQ2xhc3NOYW1lcy5tYXAobG9jYWxDbGFzc05hbWUgPT4gW2xvY2FsQ2xhc3NOYW1lLCBsb2NhbENsYXNzTmFtZV0pKTtcbiAgICB0aGlzLmxvY2FsQ2xhc3NOYW1lc1NlYXJjaCA9IG5ldyBBaG9Db3Jhc2ljayhsb2NhbENsYXNzTmFtZXMpO1xuICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQ2xhc3MgbGlzdCBjb21wb3NpdGlvbnMgc2hvdWxkIGJlIHByaW9ydGl6ZWQgYnkgTmV3ZXIgPiBPbGRlclxuICAgIC8vIFRoZXJlZm9yZSB3ZSByZXZlcnNlIHRoZSBhcnJheSBhcyB0aGV5IGFyZSBhZGRlZCBpbiBzZXF1ZW5jZVxuICAgIHRoaXMuY29tcG9zZWRDbGFzc0xpc3RzID0gY29tcG9zZWRDbGFzc0xpc3RzLm1hcChfcmVmID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICByZWdleDogUmVnRXhwKFwiKFwiLmNvbmNhdChjbGFzc0xpc3QsIFwiKVwiKSwgJ2cnKVxuICAgICAgfTtcbiAgICB9KS5yZXZlcnNlKCk7XG4gIH1cbiAgcHJvY2Vzc0Nzc09iaihyb290KSB7XG4gICAgaWYgKHJvb3QudHlwZSA9PT0gJ2ZvbnRGYWNlJykge1xuICAgICAgdGhpcy5mb250RmFjZVJ1bGVzLnB1c2gocm9vdC5ydWxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3QudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgdGhpcy5wcm9wZXJ0eVJ1bGVzLnB1c2gocm9vdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyb290LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByb290LnJ1bGUgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocm9vdC5ydWxlKS5tYXAoX3JlZjIgPT4ge1xuICAgICAgICB2YXIgW2tleWZyYW1lLCBydWxlXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gW2tleWZyYW1lLCB0aGlzLnRyYW5zZm9ybVZhcnModGhpcy50cmFuc2Zvcm1Qcm9wZXJ0aWVzKHJ1bGUpKV07XG4gICAgICB9KSk7XG4gICAgICB0aGlzLmtleWZyYW1lc1J1bGVzLnB1c2gocm9vdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCA9IG5ldyBDb25kaXRpb25hbFJ1bGVzZXQoKTtcbiAgICBpZiAocm9vdC50eXBlID09PSAnbGF5ZXInKSB7XG4gICAgICB2YXIgbGF5ZXJEZWZpbml0aW9uID0gXCJAbGF5ZXIgXCIuY29uY2F0KHJvb3QubmFtZSk7XG4gICAgICB0aGlzLmFkZExheWVyKFtsYXllckRlZmluaXRpb25dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIG1haW4gc3R5bGVzXG4gICAgICB2YXIgbWFpblJ1bGUgPSBvbWl0KHJvb3QucnVsZSwgc3BlY2lhbEtleXMpO1xuICAgICAgdGhpcy5hZGRSdWxlKHtcbiAgICAgICAgc2VsZWN0b3I6IHJvb3Quc2VsZWN0b3IsXG4gICAgICAgIHJ1bGU6IG1haW5SdWxlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTGF5ZXIocm9vdCwgcm9vdC5ydWxlWydAbGF5ZXInXSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybU1lZGlhKHJvb3QsIHJvb3QucnVsZVsnQG1lZGlhJ10pO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TdXBwb3J0cyhyb290LCByb290LnJ1bGVbJ0BzdXBwb3J0cyddKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ29udGFpbmVyKHJvb3QsIHJvb3QucnVsZVsnQGNvbnRhaW5lciddKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtU2ltcGxlUHNldWRvcyhyb290LCByb290LnJ1bGUpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TZWxlY3RvcnMocm9vdCwgcm9vdC5ydWxlKTtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZUNvbmRpdGlvbmFsUnVsZXNldCA9IHRoaXMuY29uZGl0aW9uYWxSdWxlc2V0c1t0aGlzLmNvbmRpdGlvbmFsUnVsZXNldHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFhY3RpdmVDb25kaXRpb25hbFJ1bGVzZXQubWVyZ2VJZkNvbXBhdGlibGUodGhpcy5jdXJyQ29uZGl0aW9uYWxSdWxlc2V0KSkge1xuICAgICAgLy8gUnVsZXNldCBtZXJnZSBmYWlsZWQgZHVlIHRvIGluY29tcGF0aWJpbGl0eS4gV2Ugbm93IGRlb3B0IGJ5IHN0YXJ0aW5nIGEgZnJlc2ggQ29uZGl0aW9uYWxSdWxlc2V0XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsUnVsZXNldHMucHVzaCh0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpO1xuICAgIH1cbiAgfVxuICBhZGRDb25kaXRpb25hbFJ1bGUoY3NzUnVsZSwgY29uZGl0aW9ucykge1xuICAgIC8vIFJ1biBgdHJhbnNmb3JtUHJvcGVydGllc2AgYmVmb3JlIGB0cmFuc2Zvcm1WYXJzYCBhcyB3ZSBkb24ndCB3YW50IHRvIHBpeGVsaWZ5IENTUyBWYXJzXG4gICAgdmFyIHJ1bGUgPSB0aGlzLnRyYW5zZm9ybVZhcnModGhpcy50cmFuc2Zvcm1Qcm9wZXJ0aWVzKGNzc1J1bGUucnVsZSkpO1xuICAgIHZhciBzZWxlY3RvciA9IHRoaXMudHJhbnNmb3JtU2VsZWN0b3IoY3NzUnVsZS5zZWxlY3Rvcik7XG4gICAgaWYgKCF0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGFkZCBjb25kaXRpb25hbCBydWxlXCIpO1xuICAgIH1cbiAgICB2YXIgY29uZGl0aW9uUXVlcnkgPSBjb25kaXRpb25zW2NvbmRpdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHBhcmVudENvbmRpdGlvbnMgPSBjb25kaXRpb25zLnNsaWNlKDAsIGNvbmRpdGlvbnMubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5jdXJyQ29uZGl0aW9uYWxSdWxlc2V0LmFkZFJ1bGUoe1xuICAgICAgc2VsZWN0b3IsXG4gICAgICBydWxlXG4gICAgfSwgY29uZGl0aW9uUXVlcnksIHBhcmVudENvbmRpdGlvbnMpO1xuICB9XG4gIGFkZFJ1bGUoY3NzUnVsZSkge1xuICAgIC8vIFJ1biBgdHJhbnNmb3JtUHJvcGVydGllc2AgYmVmb3JlIGB0cmFuc2Zvcm1WYXJzYCBhcyB3ZSBkb24ndCB3YW50IHRvIHBpeGVsaWZ5IENTUyBWYXJzXG4gICAgdmFyIHJ1bGUgPSB0aGlzLnRyYW5zZm9ybVZhcnModGhpcy50cmFuc2Zvcm1Qcm9wZXJ0aWVzKGNzc1J1bGUucnVsZSkpO1xuICAgIHZhciBzZWxlY3RvciA9IHRoaXMudHJhbnNmb3JtU2VsZWN0b3IoY3NzUnVsZS5zZWxlY3Rvcik7XG4gICAgdGhpcy5ydWxlcy5wdXNoKHtcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgcnVsZVxuICAgIH0pO1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdmFyIHVuaXF1ZUxheWVyS2V5ID0gbGF5ZXIuam9pbignIC0gJyk7XG4gICAgdGhpcy5sYXllcnMuc2V0KHVuaXF1ZUxheWVyS2V5LCBsYXllcik7XG4gIH1cbiAgdHJhbnNmb3JtUHJvcGVydGllcyhjc3NSdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQ29udGVudCh0aGlzLnBpeGVsaWZ5UHJvcGVydGllcyhjc3NSdWxlKSk7XG4gIH1cbiAgcGl4ZWxpZnlQcm9wZXJ0aWVzKGNzc1J1bGUpIHtcbiAgICBmb3JFYWNoKGNzc1J1bGUsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhVU5JVExFU1Nba2V5XSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEFueSBpZGVhcz9cbiAgICAgICAgY3NzUnVsZVtrZXldID0gXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzc1J1bGU7XG4gIH1cbiAgdHJhbnNmb3JtVmFycyhfcmVmMykge1xuICAgIHZhciB7XG4gICAgICAgIHZhcnNcbiAgICAgIH0gPSBfcmVmMyxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIF9leGNsdWRlZCk7XG4gICAgaWYgKCF2YXJzKSB7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBtYXBLZXlzKHZhcnMsIChfdmFsdWUsIGtleSkgPT4gZ2V0VmFyTmFtZShrZXkpKSksIHJlc3QpO1xuICB9XG4gIHRyYW5zZm9ybUNvbnRlbnQoX3JlZjQpIHtcbiAgICB2YXIge1xuICAgICAgICBjb250ZW50XG4gICAgICB9ID0gX3JlZjQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY0LCBfZXhjbHVkZWQyKTtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmFsbGJhY2sgYXJyYXlzOlxuICAgIHZhciBjb250ZW50QXJyYXkgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgICAgY29udGVudDogY29udGVudEFycmF5Lm1hcCh2YWx1ZSA9PlxuICAgICAgLy8gVGhpcyBsb2dpYyB3YXMgYWRhcHRlZCBmcm9tIFN0aXRjaGVzIDopXG4gICAgICB2YWx1ZSAmJiAodmFsdWUuaW5jbHVkZXMoJ1wiJykgfHwgdmFsdWUuaW5jbHVkZXMoXCInXCIpIHx8IC9eKFtBLVphLXpcXC1dK1xcKFteXSp8W15dKi1xdW90ZXxpbmhlcml0fGluaXRpYWx8bm9uZXxub3JtYWx8cmV2ZXJ0fHVuc2V0KShcXHN8JCkvLnRlc3QodmFsdWUpKSA/IHZhbHVlIDogXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpXG4gICAgfSwgcmVzdCk7XG4gIH1cbiAgdHJhbnNmb3JtQ2xhc3NuYW1lKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gXCIuXCIuY29uY2F0KGNzc2VzYyhpZGVudGlmaWVyLCB7XG4gICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICB9KSk7XG4gIH1cbiAgdHJhbnNmb3JtU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAvLyBNYXAgY2xhc3MgbGlzdCBjb21wb3NpdGlvbnMgdG8gc2luZ2xlIGlkZW50aWZpZXJzXG4gICAgdmFyIHRyYW5zZm9ybWVkU2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpZGVudGlmaWVyKSB7XG4gICAgICB0cmFuc2Zvcm1lZFNlbGVjdG9yID0gdHJhbnNmb3JtZWRTZWxlY3Rvci5yZXBsYWNlKHJlZ2V4LCAoKSA9PiB7XG4gICAgICAgIG1hcmtDb21wb3NpdGlvblVzZWQoaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciB7XG4gICAgICBpZGVudGlmaWVyLFxuICAgICAgcmVnZXhcbiAgICB9IG9mIHRoaXMuY29tcG9zZWRDbGFzc0xpc3RzKSB7XG4gICAgICBfbG9vcChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9jYWxDbGFzc05hbWVzTWFwLmhhcyh0cmFuc2Zvcm1lZFNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQ2xhc3NuYW1lKHRyYW5zZm9ybWVkU2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IHRoaXMubG9jYWxDbGFzc05hbWVzU2VhcmNoLnNlYXJjaCh0cmFuc2Zvcm1lZFNlbGVjdG9yKTtcbiAgICB2YXIgbGFzdFJlcGxhY2VJbmRleCA9IHRyYW5zZm9ybWVkU2VsZWN0b3IubGVuZ3RoO1xuXG4gICAgLy8gUGVyZm9ybSByZXBsYWNlbWVudHMgYmFja3dhcmRzIHRvIHNpbXBsaWZ5IGluZGV4IGhhbmRsaW5nXG4gICAgZm9yICh2YXIgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBbZW5kSW5kZXgsIFtmaXJzdE1hdGNoXV0gPSByZXN1bHRzW2ldO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBlbmRJbmRleCAtIGZpcnN0TWF0Y2gubGVuZ3RoICsgMTtcblxuICAgICAgLy8gQ2xhc3MgbmFtZXMgY2FuIGJlIHN1YnN0cmluZ3Mgb2Ygb3RoZXIgY2xhc3MgbmFtZXNcbiAgICAgIC8vIGUuZy4gJ18xZzFwdHpvMScgYW5kICdfMWcxcHR6bzEwJ1xuICAgICAgLy9cbiAgICAgIC8vIEFkZGl0aW9uYWxseSwgY29uY2F0ZW5hdGVkIGNsYXNzbmFtZXMgY2FuIGNvbnRhaW4gc3Vic3RyaW5ncyBlcXVhbCB0byBvdGhlciBjbGFzc25hbWVzXG4gICAgICAvLyBlLmcuICcmJicgd2hlcmUgJyYnIGlzICdkZWJ1Z05hbWVfaGFzaDEnIGFuZCAnZGVidWdOYW1lX2hhc2gxZCcgaXMgYWxzbyBhIGxvY2FsIGNsYXNzbmFtZVxuICAgICAgLy8gQmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc2VsZWN0b3IsIHRoaXMgd291bGQgbG9vayBsaWtlIGBkZWJ1Z05hbWVfaGFzaDFkZWJ1Z05hbWVfaGFzaDFgXG4gICAgICAvLyB3aGljaCBjb250YWlucyB0aGUgc3Vic3RyaW5nIGBkZWJ1Z05hbWVfaGFzaDFkYOKAmS5cbiAgICAgIC8vXG4gICAgICAvLyBJbiBlaXRoZXIgb2YgdGhlc2UgY2FzZXMsIHRoZSBsYXN0IHJlcGxhY2UgaW5kZXggd2lsbCBvY2N1ciBlaXRoZXIgYmVmb3JlIG9yIHdpdGhpbiB0aGVcbiAgICAgIC8vIGN1cnJlbnQgcmVwbGFjZW1lbnQgcmFuZ2UgKGZyb20gYHN0YXJ0SW5kZXhgIHRvIGBlbmRJbmRleGApLlxuICAgICAgLy8gSWYgdGhpcyBvY2N1cnMsIHdlIHNraXAgdGhlIHJlcGxhY2VtZW50IHRvIGF2b2lkIHRyYW5zZm9ybWluZyB0aGUgc2VsZWN0b3IgaW5jb3JyZWN0bHkuXG4gICAgICB2YXIgc2tpcFJlcGxhY2VtZW50ID0gbGFzdFJlcGxhY2VJbmRleCA8PSBlbmRJbmRleDtcbiAgICAgIGlmIChza2lwUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYXN0UmVwbGFjZUluZGV4ID0gc3RhcnRJbmRleDtcblxuICAgICAgLy8gSWYgY2xhc3MgbmFtZXMgYWxyZWFkeSBzdGFydHMgd2l0aCBhICcuJyB0aGVuIHNraXBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFNlbGVjdG9yW3N0YXJ0SW5kZXggLSAxXSAhPT0gJy4nKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkU2VsZWN0b3IgPSByZXBsYWNlQmV0d2VlbkluZGV4ZXModHJhbnNmb3JtZWRTZWxlY3Rvciwgc3RhcnRJbmRleCwgZW5kSW5kZXggKyAxLCB0aGlzLnRyYW5zZm9ybUNsYXNzbmFtZShmaXJzdE1hdGNoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZFNlbGVjdG9yO1xuICB9XG4gIHRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCBydWxlLCBjb25kaXRpb25zKSB7XG4gICAgZm9yRWFjaChydWxlLnNlbGVjdG9ycywgKHNlbGVjdG9yUnVsZSwgc2VsZWN0b3IpID0+IHtcbiAgICAgIGlmIChyb290LnR5cGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGFyZSBub3QgYWxsb3dlZCB3aXRoaW4gXCIuY29uY2F0KHJvb3QudHlwZSA9PT0gJ2dsb2JhbCcgPyAnXCJnbG9iYWxTdHlsZVwiJyA6ICdcInNlbGVjdG9yc1wiJykpO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zZm9ybWVkU2VsZWN0b3IgPSB0aGlzLnRyYW5zZm9ybVNlbGVjdG9yKHNlbGVjdG9yLnJlcGxhY2UoUmVnRXhwKCcmJywgJ2cnKSwgcm9vdC5zZWxlY3RvcikpO1xuICAgICAgdmFsaWRhdGVTZWxlY3Rvcih0cmFuc2Zvcm1lZFNlbGVjdG9yLCByb290LnNlbGVjdG9yKTtcbiAgICAgIHZhciBydWxlID0ge1xuICAgICAgICBzZWxlY3RvcjogdHJhbnNmb3JtZWRTZWxlY3RvcixcbiAgICAgICAgcnVsZTogb21pdChzZWxlY3RvclJ1bGUsIHNwZWNpYWxLZXlzKVxuICAgICAgfTtcbiAgICAgIGlmIChjb25kaXRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSdWxlKHJ1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRSdWxlKHJ1bGUpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGVjdG9yUm9vdCA9IHtcbiAgICAgICAgdHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgICAgc2VsZWN0b3I6IHRyYW5zZm9ybWVkU2VsZWN0b3IsXG4gICAgICAgIHJ1bGU6IHNlbGVjdG9yUnVsZVxuICAgICAgfTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTGF5ZXIoc2VsZWN0b3JSb290LCBzZWxlY3RvclJ1bGVbJ0BsYXllciddLCBjb25kaXRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtU3VwcG9ydHMoc2VsZWN0b3JSb290LCBzZWxlY3RvclJ1bGVbJ0BzdXBwb3J0cyddLCBjb25kaXRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWVkaWEoc2VsZWN0b3JSb290LCBzZWxlY3RvclJ1bGVbJ0BtZWRpYSddLCBjb25kaXRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ29udGFpbmVyKHNlbGVjdG9yUm9vdCwgc2VsZWN0b3JSdWxlWydAY29udGFpbmVyJ10sIGNvbmRpdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHRyYW5zZm9ybU1lZGlhKHJvb3QsIHJ1bGVzKSB7XG4gICAgdmFyIHBhcmVudENvbmRpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIGlmIChydWxlcykge1xuICAgICAgdmFyIF90aGlzJGN1cnJDb25kaXRpb25hbDtcbiAgICAgIChfdGhpcyRjdXJyQ29uZGl0aW9uYWwgPSB0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpID09PSBudWxsIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbCA9PT0gdm9pZCAwIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbC5hZGRDb25kaXRpb25QcmVjZWRlbmNlKHBhcmVudENvbmRpdGlvbnMsIE9iamVjdC5rZXlzKHJ1bGVzKS5tYXAocXVlcnkgPT4gXCJAbWVkaWEgXCIuY29uY2F0KHF1ZXJ5KSkpO1xuICAgICAgZm9yICh2YXIgW3F1ZXJ5LCBtZWRpYVJ1bGVdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bGVzKSkge1xuICAgICAgICB2YXIgbWVkaWFRdWVyeSA9IFwiQG1lZGlhIFwiLmNvbmNhdChxdWVyeSk7XG4gICAgICAgIHZhbGlkYXRlTWVkaWFRdWVyeShtZWRpYVF1ZXJ5KTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbLi4ucGFyZW50Q29uZGl0aW9ucywgbWVkaWFRdWVyeV07XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSdWxlKHtcbiAgICAgICAgICBzZWxlY3Rvcjogcm9vdC5zZWxlY3RvcixcbiAgICAgICAgICBydWxlOiBvbWl0KG1lZGlhUnVsZSwgc3BlY2lhbEtleXMpXG4gICAgICAgIH0sIGNvbmRpdGlvbnMpO1xuICAgICAgICBpZiAocm9vdC50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIG1lZGlhUnVsZSwgY29uZGl0aW9ucyk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TZWxlY3RvcnMocm9vdCwgbWVkaWFSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybUxheWVyKHJvb3QsIG1lZGlhUnVsZVsnQGxheWVyJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN1cHBvcnRzKHJvb3QsIG1lZGlhUnVsZVsnQHN1cHBvcnRzJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRhaW5lcihyb290LCBtZWRpYVJ1bGVbJ0Bjb250YWluZXInXSwgY29uZGl0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybUNvbnRhaW5lcihyb290LCBydWxlcykge1xuICAgIHZhciBwYXJlbnRDb25kaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgIHZhciBfdGhpcyRjdXJyQ29uZGl0aW9uYWwyO1xuICAgICAgKF90aGlzJGN1cnJDb25kaXRpb25hbDIgPSB0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpID09PSBudWxsIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbDIgPT09IHZvaWQgMCB8fCBfdGhpcyRjdXJyQ29uZGl0aW9uYWwyLmFkZENvbmRpdGlvblByZWNlZGVuY2UocGFyZW50Q29uZGl0aW9ucywgT2JqZWN0LmtleXMocnVsZXMpLm1hcChxdWVyeSA9PiBcIkBjb250YWluZXIgXCIuY29uY2F0KHF1ZXJ5KSkpO1xuICAgICAgZm9yRWFjaChydWxlcywgKGNvbnRhaW5lclJ1bGUsIHF1ZXJ5KSA9PiB7XG4gICAgICAgIHZhciBjb250YWluZXJRdWVyeSA9IFwiQGNvbnRhaW5lciBcIi5jb25jYXQocXVlcnkpO1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFsuLi5wYXJlbnRDb25kaXRpb25zLCBjb250YWluZXJRdWVyeV07XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSdWxlKHtcbiAgICAgICAgICBzZWxlY3Rvcjogcm9vdC5zZWxlY3RvcixcbiAgICAgICAgICBydWxlOiBvbWl0KGNvbnRhaW5lclJ1bGUsIHNwZWNpYWxLZXlzKVxuICAgICAgICB9LCBjb25kaXRpb25zKTtcbiAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtU2ltcGxlUHNldWRvcyhyb290LCBjb250YWluZXJSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCBjb250YWluZXJSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybUxheWVyKHJvb3QsIGNvbnRhaW5lclJ1bGVbJ0BsYXllciddLCBjb25kaXRpb25zKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdXBwb3J0cyhyb290LCBjb250YWluZXJSdWxlWydAc3VwcG9ydHMnXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWVkaWEocm9vdCwgY29udGFpbmVyUnVsZVsnQG1lZGlhJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybUxheWVyKHJvb3QsIHJ1bGVzKSB7XG4gICAgdmFyIHBhcmVudENvbmRpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIGlmIChydWxlcykge1xuICAgICAgdmFyIF90aGlzJGN1cnJDb25kaXRpb25hbDM7XG4gICAgICAoX3RoaXMkY3VyckNvbmRpdGlvbmFsMyA9IHRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCkgPT09IG51bGwgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsMyA9PT0gdm9pZCAwIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbDMuYWRkQ29uZGl0aW9uUHJlY2VkZW5jZShwYXJlbnRDb25kaXRpb25zLCBPYmplY3Qua2V5cyhydWxlcykubWFwKG5hbWUgPT4gXCJAbGF5ZXIgXCIuY29uY2F0KG5hbWUpKSk7XG4gICAgICBmb3JFYWNoKHJ1bGVzLCAobGF5ZXJSdWxlLCBuYW1lKSA9PiB7XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gWy4uLnBhcmVudENvbmRpdGlvbnMsIFwiQGxheWVyIFwiLmNvbmNhdChuYW1lKV07XG4gICAgICAgIHRoaXMuYWRkTGF5ZXIoY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSdWxlKHtcbiAgICAgICAgICBzZWxlY3Rvcjogcm9vdC5zZWxlY3RvcixcbiAgICAgICAgICBydWxlOiBvbWl0KGxheWVyUnVsZSwgc3BlY2lhbEtleXMpXG4gICAgICAgIH0sIGNvbmRpdGlvbnMpO1xuICAgICAgICBpZiAocm9vdC50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIGxheWVyUnVsZSwgY29uZGl0aW9ucyk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TZWxlY3RvcnMocm9vdCwgbGF5ZXJSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybU1lZGlhKHJvb3QsIGxheWVyUnVsZVsnQG1lZGlhJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN1cHBvcnRzKHJvb3QsIGxheWVyUnVsZVsnQHN1cHBvcnRzJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRhaW5lcihyb290LCBsYXllclJ1bGVbJ0Bjb250YWluZXInXSwgY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtU3VwcG9ydHMocm9vdCwgcnVsZXMpIHtcbiAgICB2YXIgcGFyZW50Q29uZGl0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICB2YXIgX3RoaXMkY3VyckNvbmRpdGlvbmFsNDtcbiAgICAgIChfdGhpcyRjdXJyQ29uZGl0aW9uYWw0ID0gdGhpcy5jdXJyQ29uZGl0aW9uYWxSdWxlc2V0KSA9PT0gbnVsbCB8fCBfdGhpcyRjdXJyQ29uZGl0aW9uYWw0ID09PSB2b2lkIDAgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsNC5hZGRDb25kaXRpb25QcmVjZWRlbmNlKHBhcmVudENvbmRpdGlvbnMsIE9iamVjdC5rZXlzKHJ1bGVzKS5tYXAocXVlcnkgPT4gXCJAc3VwcG9ydHMgXCIuY29uY2F0KHF1ZXJ5KSkpO1xuICAgICAgZm9yRWFjaChydWxlcywgKHN1cHBvcnRzUnVsZSwgcXVlcnkpID0+IHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbLi4ucGFyZW50Q29uZGl0aW9ucywgXCJAc3VwcG9ydHMgXCIuY29uY2F0KHF1ZXJ5KV07XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSdWxlKHtcbiAgICAgICAgICBzZWxlY3Rvcjogcm9vdC5zZWxlY3RvcixcbiAgICAgICAgICBydWxlOiBvbWl0KHN1cHBvcnRzUnVsZSwgc3BlY2lhbEtleXMpXG4gICAgICAgIH0sIGNvbmRpdGlvbnMpO1xuICAgICAgICBpZiAocm9vdC50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIHN1cHBvcnRzUnVsZSwgY29uZGl0aW9ucyk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TZWxlY3RvcnMocm9vdCwgc3VwcG9ydHNSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybUxheWVyKHJvb3QsIHN1cHBvcnRzUnVsZVsnQGxheWVyJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1lZGlhKHJvb3QsIHN1cHBvcnRzUnVsZVsnQG1lZGlhJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRhaW5lcihyb290LCBzdXBwb3J0c1J1bGVbJ0Bjb250YWluZXInXSwgY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtU2ltcGxlUHNldWRvcyhyb290LCBydWxlLCBjb25kaXRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKHJ1bGUpKSB7XG4gICAgICAvLyBQcm9jZXNzIHNpbXBsZSBwc2V1ZG9zXG4gICAgICBpZiAoc2ltcGxlUHNldWRvTG9va3VwW2tleV0pIHtcbiAgICAgICAgaWYgKHJvb3QudHlwZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpbXBsZSBwc2V1ZG9zIGFyZSBub3QgdmFsaWQgaW4gXCIuY29uY2F0KHJvb3QudHlwZSA9PT0gJ2dsb2JhbCcgPyAnXCJnbG9iYWxTdHlsZVwiJyA6ICdcInNlbGVjdG9yc1wiJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kaXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IFwiXCIuY29uY2F0KHJvb3Quc2VsZWN0b3IpLmNvbmNhdChrZXkpLFxuICAgICAgICAgICAgcnVsZTogcnVsZVtrZXldXG4gICAgICAgICAgfSwgY29uZGl0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRSdWxlKHtcbiAgICAgICAgICAgIGNvbmRpdGlvbnMsXG4gICAgICAgICAgICBzZWxlY3RvcjogXCJcIi5jb25jYXQocm9vdC5zZWxlY3RvcikuY29uY2F0KGtleSksXG4gICAgICAgICAgICBydWxlOiBydWxlW2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b0NzcygpIHtcbiAgICB2YXIgY3NzID0gW107XG5cbiAgICAvLyBSZW5kZXIgZm9udC1mYWNlIHJ1bGVzXG4gICAgZm9yICh2YXIgZm9udEZhY2VSdWxlIG9mIHRoaXMuZm9udEZhY2VSdWxlcykge1xuICAgICAgY3NzLnB1c2gocmVuZGVyQ3NzKHtcbiAgICAgICAgJ0Bmb250LWZhY2UnOiBmb250RmFjZVJ1bGVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgcHJvcGVydHkgcnVsZXNcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnR5UnVsZXMpIHtcbiAgICAgIGNzcy5wdXNoKHJlbmRlckNzcyh7XG4gICAgICAgIFtcIkBwcm9wZXJ0eSBcIi5jb25jYXQocHJvcGVydHkubmFtZSldOiBwcm9wZXJ0eS5ydWxlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGtleWZyYW1lc1xuICAgIGZvciAodmFyIGtleWZyYW1lIG9mIHRoaXMua2V5ZnJhbWVzUnVsZXMpIHtcbiAgICAgIGNzcy5wdXNoKHJlbmRlckNzcyh7XG4gICAgICAgIFtcIkBrZXlmcmFtZXMgXCIuY29uY2F0KGtleWZyYW1lLm5hbWUpXToga2V5ZnJhbWUucnVsZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBsYXllciBkZWZpbml0aW9uc1xuICAgIGZvciAodmFyIGxheWVyIG9mIHRoaXMubGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICB2YXIgW2RlZmluaXRpb24sIC4uLm5lc3RpbmddID0gbGF5ZXIucmV2ZXJzZSgpO1xuICAgICAgdmFyIGNzc09iaiA9IHtcbiAgICAgICAgW2RlZmluaXRpb25dOiBERUNMQVJBVElPTlxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHBhcnQgb2YgbmVzdGluZykge1xuICAgICAgICBjc3NPYmogPSB7XG4gICAgICAgICAgW3BhcnRdOiBjc3NPYmpcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNzcy5wdXNoKHJlbmRlckNzcyhjc3NPYmopKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdW5jb25kaXRpb25hbCBydWxlc1xuICAgIGZvciAodmFyIHJ1bGUgb2YgdGhpcy5ydWxlcykge1xuICAgICAgY3NzLnB1c2gocmVuZGVyQ3NzKHtcbiAgICAgICAgW3J1bGUuc2VsZWN0b3JdOiBydWxlLnJ1bGVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgY29uZGl0aW9uYWwgcnVsZXNcbiAgICBmb3IgKHZhciBjb25kaXRpb25hbFJ1bGVzZXQgb2YgdGhpcy5jb25kaXRpb25hbFJ1bGVzZXRzKSB7XG4gICAgICBmb3IgKHZhciBjb25kaXRpb25hbFJ1bGUgb2YgY29uZGl0aW9uYWxSdWxlc2V0LnJlbmRlclRvQXJyYXkoKSkge1xuICAgICAgICBjc3MucHVzaChyZW5kZXJDc3MoY29uZGl0aW9uYWxSdWxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3MuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJDc3Modikge1xuICB2YXIgaW5kZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgdmFyIHJ1bGVzID0gW107XG4gIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gdltrZXldO1xuICAgIGlmICh2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcnVsZXMucHVzaCguLi52YWx1ZS5tYXAodiA9PiByZW5kZXJDc3Moe1xuICAgICAgICBba2V5XTogdlxuICAgICAgfSwgaW5kZW50KSkpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGlzRW1wdHkgPSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIHJ1bGVzLnB1c2goXCJcIi5jb25jYXQoaW5kZW50KS5jb25jYXQoa2V5LCBcIiB7XFxuXCIpLmNvbmNhdChyZW5kZXJDc3ModmFsdWUsIGluZGVudCArIERPVUJMRV9TUEFDRSksIFwiXFxuXCIpLmNvbmNhdChpbmRlbnQsIFwifVwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gREVDTEFSQVRJT04pIHtcbiAgICAgIHJ1bGVzLnB1c2goXCJcIi5jb25jYXQoaW5kZW50KS5jb25jYXQoa2V5LCBcIjtcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBydWxlcy5wdXNoKFwiXCIuY29uY2F0KGluZGVudCkuY29uY2F0KGtleS5zdGFydHNXaXRoKCctLScpID8ga2V5IDogZGFzaGlmeShrZXkpLCBcIjogXCIpLmNvbmNhdCh2YWx1ZSwgXCI7XCIpKTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgIF9sb29wMihrZXkpO1xuICB9XG4gIHJldHVybiBydWxlcy5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNzcyhfcmVmNSkge1xuICB2YXIge1xuICAgIGxvY2FsQ2xhc3NOYW1lcyxcbiAgICBjc3NPYmpzLFxuICAgIGNvbXBvc2VkQ2xhc3NMaXN0c1xuICB9ID0gX3JlZjU7XG4gIHZhciBzdHlsZXNoZWV0ID0gbmV3IFN0eWxlc2hlZXQobG9jYWxDbGFzc05hbWVzLCBjb21wb3NlZENsYXNzTGlzdHMpO1xuICBmb3IgKHZhciByb290IG9mIGNzc09ianMpIHtcbiAgICBzdHlsZXNoZWV0LnByb2Nlc3NDc3NPYmoocm9vdCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlc2hlZXQudG9Dc3MoKTtcbn1cblxuZXhwb3J0IHsgX29iamVjdFNwcmVhZDIgYXMgXywgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGFzIGEsIGR1ZHVwZUFuZEpvaW5DbGFzc0xpc3QgYXMgZCwgdHJhbnNmb3JtQ3NzIGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertVarName: () => (/* binding */ assertVarName),\n/* harmony export */   assignVars: () => (/* binding */ assignVars),\n/* harmony export */   composeStyles: () => (/* binding */ composeStyles),\n/* harmony export */   createContainer: () => (/* binding */ createContainer),\n/* harmony export */   createGlobalTheme: () => (/* binding */ createGlobalTheme),\n/* harmony export */   createGlobalThemeContract: () => (/* binding */ createGlobalThemeContract),\n/* harmony export */   createGlobalVar: () => (/* binding */ createGlobalVar),\n/* harmony export */   createTheme: () => (/* binding */ createTheme),\n/* harmony export */   createThemeContract: () => (/* binding */ createThemeContract),\n/* harmony export */   createVar: () => (/* binding */ createVar),\n/* harmony export */   createViewTransition: () => (/* binding */ createViewTransition),\n/* harmony export */   fallbackVar: () => (/* binding */ fallbackVar),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   generateIdentifier: () => (/* binding */ generateIdentifier),\n/* harmony export */   globalFontFace: () => (/* binding */ globalFontFace),\n/* harmony export */   globalKeyframes: () => (/* binding */ globalKeyframes),\n/* harmony export */   globalLayer: () => (/* binding */ globalLayer),\n/* harmony export */   globalStyle: () => (/* binding */ globalStyle),\n/* harmony export */   keyframes: () => (/* binding */ keyframes),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   style: () => (/* binding */ style),\n/* harmony export */   styleVariants: () => (/* binding */ styleVariants)\n/* harmony export */ });\n/* harmony import */ var _injectStyles_dist_vanilla_extract_css_injectStyles_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../injectStyles/dist/vanilla-extract-css-injectStyles.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js\");\n/* harmony import */ var _transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformCss-0dba36bf.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n/* harmony import */ var _emotion_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/hash */ \"(ssr)/../node_modules/@emotion/hash/dist/emotion-hash.esm.js\");\n/* harmony import */ var _fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../fileScope/dist/vanilla-extract-css-fileScope.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lru-cache */ \"(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js\");\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cssesc */ \"(ssr)/../node_modules/cssesc/cssesc.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(cssesc__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var deep_object_diff__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! deep-object-diff */ \"(ssr)/../node_modules/deep-object-diff/mjs/index.js\");\n/* harmony import */ var picocolors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! picocolors */ \"(ssr)/../node_modules/picocolors/picocolors.js\");\n/* harmony import */ var picocolors__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(picocolors__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var modern_ahocorasick__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! modern-ahocorasick */ \"(ssr)/../node_modules/modern-ahocorasick/dist/index.js\");\n/* harmony import */ var media_query_parser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! media-query-parser */ \"(ssr)/../node_modules/media-query-parser/dist/media-query-parser.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar localClassNames = new Set();\nvar composedClassLists = [];\nvar bufferedCSSObjs = [];\nvar browserRuntimeAdapter = {\n  appendCss: cssObj => {\n    bufferedCSSObjs.push(cssObj);\n  },\n  registerClassName: className => {\n    localClassNames.add(className);\n  },\n  registerComposition: composition => {\n    composedClassLists.push(composition);\n  },\n  markCompositionUsed: () => {},\n  onEndFileScope: fileScope => {\n    var css = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)({\n      localClassNames: Array.from(localClassNames),\n      composedClassLists,\n      cssObjs: bufferedCSSObjs\n    }).join('\\n');\n    (0,_injectStyles_dist_vanilla_extract_css_injectStyles_esm_js__WEBPACK_IMPORTED_MODULE_0__.injectStyles)({\n      fileScope,\n      css\n    });\n    bufferedCSSObjs = [];\n  },\n  getIdentOption: () =>  false ? 0 : 'debug'\n};\nif (typeof window !== 'undefined') {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.setAdapterIfNotSet)(browserRuntimeAdapter);\n}\n\nvar getLastSlashBeforeIndex = (path, index) => {\n  var pathIndex = index - 1;\n  while (pathIndex >= 0) {\n    if (path[pathIndex] === '/') {\n      return pathIndex;\n    }\n    pathIndex--;\n  }\n  return -1;\n};\n\n/**\n * Assumptions:\n * - The path is always normalized to use posix file separators (/) (see `addFileScope`)\n * - The path is always relative to the project root, i.e. there will never be a leading slash (see `addFileScope`)\n * - As long as `.css` is there, we have a valid `.css.*` file path, because otherwise there wouldn't\n *   be a file scope to begin with\n *\n * The LRU cache we use can't cache undefined/null values, so we opt to return an empty string,\n * rather than using a custom Symbol or something similar.\n */\nvar _getDebugFileName = path => {\n  var file;\n  var lastIndexOfDotCss = path.lastIndexOf('.css');\n  if (lastIndexOfDotCss === -1) {\n    return '';\n  }\n  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);\n  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);\n\n  // There are no slashes, therefore theres no directory to extract\n  if (lastSlashIndex === -1) {\n    return file;\n  }\n  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);\n  // If secondLastSlashIndex is -1, it means that the path looks like `directory/file.css.ts`,\n  // in which case dir will still be sliced starting at 0, which is what we want\n  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);\n  var debugFileName = file !== 'index' ? file : dir;\n  return debugFileName;\n};\nvar memoizedGetDebugFileName = () => {\n  var cache = new lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n    max: 500\n  });\n  return path => {\n    var cachedResult = cache.get(path);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = _getDebugFileName(path);\n    cache.set(path, result);\n    return result;\n  };\n};\nvar getDebugFileName = memoizedGetDebugFileName();\n\nfunction getDevPrefix(_ref) {\n  var {\n    debugId,\n    debugFileName\n  } = _ref;\n  var parts = debugId ? [debugId.replace(/\\s/g, '_')] : [];\n  if (debugFileName) {\n    var {\n      filePath\n    } = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)();\n    var _debugFileName = getDebugFileName(filePath);\n\n    // debugFileName could be an empty string\n    if (_debugFileName) {\n      parts.unshift(_debugFileName);\n    }\n  }\n  return parts.join('_');\n}\nfunction normalizeIdentifier(identifier) {\n  return identifier.match(/^[0-9]/) ? \"_\".concat(identifier) : identifier;\n}\nfunction generateIdentifier(arg) {\n  var identOption = (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.getIdentOption)();\n  var {\n    debugId,\n    debugFileName = true\n  } = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, typeof arg === 'string' ? {\n    debugId: arg\n  } : null), typeof arg === 'object' ? arg : null);\n\n  // Convert ref count to base 36 for optimal hash lengths\n  var refCount = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getAndIncrementRefCounter)().toString(36);\n  var {\n    filePath,\n    packageName\n  } = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)();\n  var fileScopeHash = (0,_emotion_hash__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(packageName ? \"\".concat(packageName).concat(filePath) : filePath);\n  var identifier = \"\".concat(fileScopeHash).concat(refCount);\n  if (identOption === 'debug') {\n    var devPrefix = getDevPrefix({\n      debugId,\n      debugFileName\n    });\n    if (devPrefix) {\n      identifier = \"\".concat(devPrefix, \"__\").concat(identifier);\n    }\n    return normalizeIdentifier(identifier);\n  }\n  if (typeof identOption === 'function') {\n    identifier = identOption({\n      hash: identifier,\n      debugId,\n      filePath,\n      packageName\n    });\n    if (!identifier.match(/^[A-Z_][0-9A-Z_-]+$/i)) {\n      throw new Error(\"Identifier function returned invalid indentifier: \\\"\".concat(identifier, \"\\\"\"));\n    }\n    return identifier;\n  }\n  return normalizeIdentifier(identifier);\n}\n\nvar normaliseObject = obj => (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(obj, () => '');\nfunction validateContract(contract, tokens) {\n  var theDiff = (0,deep_object_diff__WEBPACK_IMPORTED_MODULE_5__.diff)(normaliseObject(contract), normaliseObject(tokens));\n  var valid = Object.keys(theDiff).length === 0;\n  return {\n    valid,\n    diffString: valid ? '' : renderDiff(contract, theDiff)\n  };\n}\nfunction diffLine(value, nesting, type) {\n  var whitespace = [...Array(nesting).keys()].map(() => '  ').join('');\n  var line = \"\".concat(type ? type : ' ').concat(whitespace).concat(value);\n  if (true) {\n    if (type === '-') {\n      return picocolors__WEBPACK_IMPORTED_MODULE_14___default().red(line);\n    }\n    if (type === '+') {\n      return picocolors__WEBPACK_IMPORTED_MODULE_14___default().green(line);\n    }\n  }\n  return line;\n}\nfunction renderDiff(orig, diff) {\n  var nesting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var lines = [];\n  if (nesting === 0) {\n    lines.push(diffLine('{', 0));\n  }\n  var innerNesting = nesting + 1;\n  var keys = Object.keys(diff).sort();\n  for (var key of keys) {\n    var value = diff[key];\n    if (!(key in orig)) {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '+'));\n    } else if (typeof value === 'object') {\n      lines.push(diffLine(\"\".concat(key, \": {\"), innerNesting));\n      lines.push(renderDiff(orig[key], diff[key], innerNesting));\n      lines.push(diffLine('}', innerNesting));\n    } else {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '-'));\n    }\n  }\n  if (nesting === 0) {\n    lines.push(diffLine('}', 0));\n  }\n  return lines.join('\\n');\n}\n\nvar buildPropertyRule = _ref => {\n  var {\n    syntax,\n    inherits,\n    initialValue\n  } = _ref;\n  return (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({\n    syntax: \"\\\"\".concat(Array.isArray(syntax) ? syntax.join(' | ') : syntax, \"\\\"\"),\n    inherits: inherits ? 'true' : 'false'\n  }, initialValue != null ? {\n    initialValue\n  } : {});\n};\nfunction createVar(debugIdOrDeclaration, debugId) {\n  var cssVarName = cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier({\n    debugId: typeof debugIdOrDeclaration === 'string' ? debugIdOrDeclaration : debugId,\n    debugFileName: false\n  }), {\n    isIdentifier: true\n  });\n  if (debugIdOrDeclaration && typeof debugIdOrDeclaration === 'object') {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'property',\n      name: \"--\".concat(cssVarName),\n      rule: buildPropertyRule(debugIdOrDeclaration)\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return \"var(--\".concat(cssVarName, \")\");\n}\nfunction createGlobalVar(name, declaration) {\n  if (declaration && typeof declaration === 'object') {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'property',\n      name: \"--\".concat(name),\n      rule: buildPropertyRule(declaration)\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return \"var(--\".concat(name, \")\");\n}\nfunction assertVarName(value) {\n  if (typeof value !== 'string' || !/^var\\(--.*\\)$/.test(value)) {\n    throw new Error(\"Invalid variable name: \".concat(value));\n  }\n}\nfunction fallbackVar() {\n  var finalValue = '';\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  values.reverse().forEach(value => {\n    if (finalValue === '') {\n      finalValue = String(value);\n    } else {\n      assertVarName(value);\n      finalValue = value.replace(/\\)$/, \", \".concat(finalValue, \")\"));\n    }\n  });\n  return finalValue;\n}\nfunction assignVars(varContract, tokens) {\n  var varSetters = {};\n  var {\n    valid,\n    diffString\n  } = validateContract(varContract, tokens);\n  if (!valid) {\n    throw new Error(\"Tokens don't match contract.\\n\".concat(diffString));\n  }\n  (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (value, path) => {\n    varSetters[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.get)(varContract, path)] = String(value);\n  });\n  return varSetters;\n}\nfunction createThemeContract(tokens) {\n  return (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (_value, path) => {\n    return createVar(path.join('-'));\n  });\n}\nfunction createGlobalThemeContract(tokens, mapFn) {\n  return (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (value, path) => {\n    var rawVarName = typeof mapFn === 'function' ? mapFn(value, path) : value;\n    var varName = typeof rawVarName === 'string' ? rawVarName.replace(/^\\-\\-/, '') : null;\n    if (typeof varName !== 'string' || varName !== cssesc__WEBPACK_IMPORTED_MODULE_4___default()(varName, {\n      isIdentifier: true\n    })) {\n      throw new Error(\"Invalid variable name for \\\"\".concat(path.join('.'), \"\\\": \").concat(varName));\n    }\n    return \"var(--\".concat(varName, \")\");\n  });\n}\n\nvar _excluded = [\"@layer\"];\nfunction createGlobalTheme(selector, arg2, arg3) {\n  var themeContractProvided = Boolean(arg3);\n  var tokenArg = themeContractProvided ? arg3 : arg2;\n  var {\n    layerName,\n    tokens\n  } = extractLayerFromTokens(tokenArg);\n  var themeContract = themeContractProvided ? arg2 : createThemeContract(tokens);\n  var rule = {\n    vars: assignVars(themeContract, tokens)\n  };\n  if (layerName) {\n    rule = {\n      '@layer': {\n        [layerName]: rule\n      }\n    };\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'global',\n    selector: selector,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  if (!themeContractProvided) {\n    return themeContract;\n  }\n}\nfunction createTheme(arg1, arg2, arg3) {\n  var themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(themeClassName, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  var vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);\n  return vars ? [themeClassName, vars] : themeClassName;\n}\nfunction extractLayerFromTokens(tokens) {\n  if ('@layer' in tokens) {\n    var {\n        '@layer': layerName\n      } = tokens,\n      rest = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(tokens, _excluded);\n    return {\n      layerName,\n      tokens: rest\n    };\n  }\n  return {\n    tokens\n  };\n}\n\nvar _templateObject;\nfunction composedStyle(rules, debugId) {\n  var className = generateIdentifier(debugId);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(className, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  var classList = [];\n  var styleRules = [];\n  for (var rule of rules) {\n    if (typeof rule === 'string') {\n      classList.push(rule);\n    } else {\n      styleRules.push(rule);\n    }\n  }\n  var result = className;\n  if (classList.length > 0) {\n    result = \"\".concat(className, \" \").concat((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(classList));\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerComposition)({\n      identifier: className,\n      classList: result\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n    if (styleRules.length > 0) {\n      // If there are styles attached to this composition then it is\n      // always used and should never be removed\n      (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.markCompositionUsed)(className);\n    }\n  }\n  if (styleRules.length > 0) {\n    var _rule = deepmerge__WEBPACK_IMPORTED_MODULE_8___default().all(styleRules, {\n      // Replace arrays rather than merging\n      arrayMerge: (_, sourceArray) => sourceArray\n    });\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'local',\n      selector: className,\n      rule: _rule\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return result;\n}\nfunction style(rule, debugId) {\n  if (Array.isArray(rule)) {\n    return composedStyle(rule, debugId);\n  }\n  var className = generateIdentifier(debugId);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(className, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'local',\n    selector: className,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return className;\n}\n\n/**\n * @deprecated The same functionality is now provided by the 'style' function when you pass it an array\n */\nfunction composeStyles() {\n  var compose = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.hasFileScope)() ? composedStyle : _transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d;\n  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classNames[_key] = arguments[_key];\n  }\n  return compose(classNames);\n}\nfunction globalStyle(selector, rule) {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'global',\n    selector,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n}\nfunction fontFace(rule, debugId) {\n  var fontFamily = \"\\\"\".concat(cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier(debugId), {\n    quotes: 'double'\n  }), \"\\\"\");\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    if ('fontFamily' in singleRule) {\n      throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_templateObject || (_templateObject = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_6__._)([\"\\n      This function creates and returns a hashed font-family name, so the \\\"fontFamily\\\" property should not be provided.\\n    \\n      If you'd like to define a globally scoped custom font, you can use the \\\"globalFontFace\\\" function instead.\\n    \"]))));\n    }\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'fontFace',\n      rule: (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, singleRule), {}, {\n        fontFamily\n      })\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return fontFamily;\n}\nfunction globalFontFace(fontFamily, rule) {\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'fontFace',\n      rule: (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, singleRule), {}, {\n        fontFamily\n      })\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n}\nfunction keyframes(rule, debugId) {\n  var name = cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier(debugId), {\n    isIdentifier: true\n  });\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'keyframes',\n    name,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\nfunction globalKeyframes(name, rule) {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'keyframes',\n    name,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n}\nfunction styleVariants() {\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n    var _data = arguments.length <= 0 ? undefined : arguments[0];\n    var _mapData = arguments.length <= 1 ? undefined : arguments[1];\n    var _debugId = arguments.length <= 2 ? undefined : arguments[2];\n    var _classMap = {};\n    for (var _key2 in _data) {\n      _classMap[_key2] = style(_mapData(_data[_key2], _key2), _debugId ? \"\".concat(_debugId, \"_\").concat(_key2) : _key2);\n    }\n    return _classMap;\n  }\n  var styleMap = arguments.length <= 0 ? undefined : arguments[0];\n  var debugId = arguments.length <= 1 ? undefined : arguments[1];\n  var classMap = {};\n  for (var _key3 in styleMap) {\n    classMap[_key3] = style(styleMap[_key3], debugId ? \"\".concat(debugId, \"_\").concat(_key3) : _key3);\n  }\n  return classMap;\n}\n\n// createContainer is used for local scoping of CSS containers\n// For now it is mostly just an alias of generateIdentifier\nvar createContainer = debugId => generateIdentifier(debugId);\n\n// createViewTransition is used for locally scoping CSS view transitions\n// For now it is mostly just an alias of generateIdentifier\nvar createViewTransition = debugId => generateIdentifier(debugId);\n\nvar defaultLayerOptions = {};\nvar merge = (obj1, obj2) => (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, obj1), obj2);\nvar getLayerArgs = function getLayerArgs() {\n  var options = defaultLayerOptions;\n  var debugId = arguments.length <= 0 ? undefined : arguments[0];\n  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    options = merge(defaultLayerOptions, arguments.length <= 0 ? undefined : arguments[0]);\n    debugId = arguments.length <= 1 ? undefined : arguments[1];\n  }\n  return [options, debugId];\n};\nfunction layer() {\n  var [options, debugId] = getLayerArgs(...arguments);\n  var name = generateIdentifier(debugId);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'layer',\n    name\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\nfunction globalLayer() {\n  var [options, name] = getLayerArgs(...arguments);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'layer',\n    name\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RjtBQUN3RDtBQUM0QjtBQUMvSTtBQUM4RjtBQUMxRjtBQUNzQjtBQUMvQjtBQUNZO0FBQ1o7QUFDMEQ7QUFDMUQ7QUFDTTtBQUNOO0FBQ1Y7QUFDVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0I7QUFDQSxjQUFjLGdFQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHdHQUFZO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLE1BQXFDLEdBQUcsQ0FBTztBQUN2RTtBQUNBO0FBQ0EsRUFBRSxxR0FBa0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLG1HQUFZO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUdBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLGdFQUFjLENBQUMsZ0VBQWMsR0FBRztBQUN0QztBQUNBLElBQUk7O0FBRUo7QUFDQSxpQkFBaUIsZ0hBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSxtR0FBWTtBQUNsQixzQkFBc0IseURBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixxRUFBVTtBQUN2QztBQUNBLGdCQUFnQixzREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQStCO0FBQ3JDO0FBQ0EsYUFBYSxzREFBTTtBQUNuQjtBQUNBO0FBQ0EsYUFBYSx3REFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QztBQUM3QztBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUyxnRUFBYztBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBTTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUVBQVU7QUFDWixlQUFlLDhEQUFHO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFVO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLHFFQUFVO0FBQ25CO0FBQ0E7QUFDQSxtREFBbUQsNkNBQU07QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0dBQWlCLGlCQUFpQixtR0FBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixhQUFhLGdFQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvR0FBaUIsWUFBWSxtR0FBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQXNCO0FBQ3BFLElBQUksc0dBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLLEVBQUUsbUdBQVk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzR0FBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFhO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvR0FBaUIsWUFBWSxtR0FBWTtBQUMzQyxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUdBQVkscUJBQXFCLDREQUFzQjtBQUN2RSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCLDZDQUFNO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBTSx1Q0FBdUMseUVBQXNCO0FBQ3pGO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0EsWUFBWSxnRUFBYyxDQUFDLGdFQUFjLEdBQUcsaUJBQWlCO0FBQzdEO0FBQ0EsT0FBTztBQUNQLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRGQUFTO0FBQ2I7QUFDQSxZQUFZLGdFQUFjLENBQUMsZ0VBQWMsR0FBRyxpQkFBaUI7QUFDN0Q7QUFDQSxPQUFPO0FBQ1AsS0FBSyxFQUFFLG1HQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQU07QUFDbkI7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnRUFBYyxDQUFDLGdFQUFjLEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHLEVBQUUsbUdBQVk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBOztBQUVxViIsInNvdXJjZXMiOlsid2VicGFjazovL3plcm92YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3MvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLmVzbS5qcz8xNWYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdFN0eWxlcyB9IGZyb20gJy4uL2luamVjdFN0eWxlcy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtaW5qZWN0U3R5bGVzLmVzbS5qcyc7XG5pbXBvcnQgeyB0IGFzIHRyYW5zZm9ybUNzcywgXyBhcyBfb2JqZWN0U3ByZWFkMiwgYSBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIGQgYXMgZHVkdXBlQW5kSm9pbkNsYXNzTGlzdCB9IGZyb20gJy4vdHJhbnNmb3JtQ3NzLTBkYmEzNmJmLmVzbS5qcyc7XG5pbXBvcnQgeyBzZXRBZGFwdGVySWZOb3RTZXQsIGdldElkZW50T3B0aW9uLCBhcHBlbmRDc3MsIHJlZ2lzdGVyQ2xhc3NOYW1lLCByZWdpc3RlckNvbXBvc2l0aW9uLCBtYXJrQ29tcG9zaXRpb25Vc2VkIH0gZnJvbSAnLi4vYWRhcHRlci9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtYWRhcHRlci5lc20uanMnO1xuaW1wb3J0IGhhc2ggZnJvbSAnQGVtb3Rpb24vaGFzaCc7XG5pbXBvcnQgeyBnZXRBbmRJbmNyZW1lbnRSZWZDb3VudGVyLCBnZXRGaWxlU2NvcGUsIGhhc0ZpbGVTY29wZSB9IGZyb20gJy4uL2ZpbGVTY29wZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtZmlsZVNjb3BlLmVzbS5qcyc7XG5pbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgeyB3YWxrT2JqZWN0LCBnZXQgfSBmcm9tICdAdmFuaWxsYS1leHRyYWN0L3ByaXZhdGUnO1xuaW1wb3J0IGNzc2VzYyBmcm9tICdjc3Nlc2MnO1xuaW1wb3J0IHsgZGlmZiB9IGZyb20gJ2RlZXAtb2JqZWN0LWRpZmYnO1xuaW1wb3J0IHBjIGZyb20gJ3BpY29jb2xvcnMnO1xuaW1wb3J0IHsgXyBhcyBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsIH0gZnJvbSAnLi90YWdnZWRUZW1wbGF0ZUxpdGVyYWwtMTA5OTgzMTUuZXNtLmpzJztcbmltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCAnbW9kZXJuLWFob2NvcmFzaWNrJztcbmltcG9ydCAnY3NzLXdoYXQnO1xuaW1wb3J0ICdtZWRpYS1xdWVyeS1wYXJzZXInO1xuXG52YXIgbG9jYWxDbGFzc05hbWVzID0gbmV3IFNldCgpO1xudmFyIGNvbXBvc2VkQ2xhc3NMaXN0cyA9IFtdO1xudmFyIGJ1ZmZlcmVkQ1NTT2JqcyA9IFtdO1xudmFyIGJyb3dzZXJSdW50aW1lQWRhcHRlciA9IHtcbiAgYXBwZW5kQ3NzOiBjc3NPYmogPT4ge1xuICAgIGJ1ZmZlcmVkQ1NTT2Jqcy5wdXNoKGNzc09iaik7XG4gIH0sXG4gIHJlZ2lzdGVyQ2xhc3NOYW1lOiBjbGFzc05hbWUgPT4ge1xuICAgIGxvY2FsQ2xhc3NOYW1lcy5hZGQoY2xhc3NOYW1lKTtcbiAgfSxcbiAgcmVnaXN0ZXJDb21wb3NpdGlvbjogY29tcG9zaXRpb24gPT4ge1xuICAgIGNvbXBvc2VkQ2xhc3NMaXN0cy5wdXNoKGNvbXBvc2l0aW9uKTtcbiAgfSxcbiAgbWFya0NvbXBvc2l0aW9uVXNlZDogKCkgPT4ge30sXG4gIG9uRW5kRmlsZVNjb3BlOiBmaWxlU2NvcGUgPT4ge1xuICAgIHZhciBjc3MgPSB0cmFuc2Zvcm1Dc3Moe1xuICAgICAgbG9jYWxDbGFzc05hbWVzOiBBcnJheS5mcm9tKGxvY2FsQ2xhc3NOYW1lcyksXG4gICAgICBjb21wb3NlZENsYXNzTGlzdHMsXG4gICAgICBjc3NPYmpzOiBidWZmZXJlZENTU09ianNcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgICBpbmplY3RTdHlsZXMoe1xuICAgICAgZmlsZVNjb3BlLFxuICAgICAgY3NzXG4gICAgfSk7XG4gICAgYnVmZmVyZWRDU1NPYmpzID0gW107XG4gIH0sXG4gIGdldElkZW50T3B0aW9uOiAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gJ3Nob3J0JyA6ICdkZWJ1Zydcbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgc2V0QWRhcHRlcklmTm90U2V0KGJyb3dzZXJSdW50aW1lQWRhcHRlcik7XG59XG5cbnZhciBnZXRMYXN0U2xhc2hCZWZvcmVJbmRleCA9IChwYXRoLCBpbmRleCkgPT4ge1xuICB2YXIgcGF0aEluZGV4ID0gaW5kZXggLSAxO1xuICB3aGlsZSAocGF0aEluZGV4ID49IDApIHtcbiAgICBpZiAocGF0aFtwYXRoSW5kZXhdID09PSAnLycpIHtcbiAgICAgIHJldHVybiBwYXRoSW5kZXg7XG4gICAgfVxuICAgIHBhdGhJbmRleC0tO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQXNzdW1wdGlvbnM6XG4gKiAtIFRoZSBwYXRoIGlzIGFsd2F5cyBub3JtYWxpemVkIHRvIHVzZSBwb3NpeCBmaWxlIHNlcGFyYXRvcnMgKC8pIChzZWUgYGFkZEZpbGVTY29wZWApXG4gKiAtIFRoZSBwYXRoIGlzIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgcHJvamVjdCByb290LCBpLmUuIHRoZXJlIHdpbGwgbmV2ZXIgYmUgYSBsZWFkaW5nIHNsYXNoIChzZWUgYGFkZEZpbGVTY29wZWApXG4gKiAtIEFzIGxvbmcgYXMgYC5jc3NgIGlzIHRoZXJlLCB3ZSBoYXZlIGEgdmFsaWQgYC5jc3MuKmAgZmlsZSBwYXRoLCBiZWNhdXNlIG90aGVyd2lzZSB0aGVyZSB3b3VsZG4ndFxuICogICBiZSBhIGZpbGUgc2NvcGUgdG8gYmVnaW4gd2l0aFxuICpcbiAqIFRoZSBMUlUgY2FjaGUgd2UgdXNlIGNhbid0IGNhY2hlIHVuZGVmaW5lZC9udWxsIHZhbHVlcywgc28gd2Ugb3B0IHRvIHJldHVybiBhbiBlbXB0eSBzdHJpbmcsXG4gKiByYXRoZXIgdGhhbiB1c2luZyBhIGN1c3RvbSBTeW1ib2wgb3Igc29tZXRoaW5nIHNpbWlsYXIuXG4gKi9cbnZhciBfZ2V0RGVidWdGaWxlTmFtZSA9IHBhdGggPT4ge1xuICB2YXIgZmlsZTtcbiAgdmFyIGxhc3RJbmRleE9mRG90Q3NzID0gcGF0aC5sYXN0SW5kZXhPZignLmNzcycpO1xuICBpZiAobGFzdEluZGV4T2ZEb3RDc3MgPT09IC0xKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0U2xhc2hJbmRleCA9IGdldExhc3RTbGFzaEJlZm9yZUluZGV4KHBhdGgsIGxhc3RJbmRleE9mRG90Q3NzKTtcbiAgZmlsZSA9IHBhdGguc2xpY2UobGFzdFNsYXNoSW5kZXggKyAxLCBsYXN0SW5kZXhPZkRvdENzcyk7XG5cbiAgLy8gVGhlcmUgYXJlIG5vIHNsYXNoZXMsIHRoZXJlZm9yZSB0aGVyZXMgbm8gZGlyZWN0b3J5IHRvIGV4dHJhY3RcbiAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIHZhciBzZWNvbmRMYXN0U2xhc2hJbmRleCA9IGdldExhc3RTbGFzaEJlZm9yZUluZGV4KHBhdGgsIGxhc3RTbGFzaEluZGV4IC0gMSk7XG4gIC8vIElmIHNlY29uZExhc3RTbGFzaEluZGV4IGlzIC0xLCBpdCBtZWFucyB0aGF0IHRoZSBwYXRoIGxvb2tzIGxpa2UgYGRpcmVjdG9yeS9maWxlLmNzcy50c2AsXG4gIC8vIGluIHdoaWNoIGNhc2UgZGlyIHdpbGwgc3RpbGwgYmUgc2xpY2VkIHN0YXJ0aW5nIGF0IDAsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuICB2YXIgZGlyID0gcGF0aC5zbGljZShzZWNvbmRMYXN0U2xhc2hJbmRleCArIDEsIGxhc3RTbGFzaEluZGV4KTtcbiAgdmFyIGRlYnVnRmlsZU5hbWUgPSBmaWxlICE9PSAnaW5kZXgnID8gZmlsZSA6IGRpcjtcbiAgcmV0dXJuIGRlYnVnRmlsZU5hbWU7XG59O1xudmFyIG1lbW9pemVkR2V0RGVidWdGaWxlTmFtZSA9ICgpID0+IHtcbiAgdmFyIGNhY2hlID0gbmV3IExSVUNhY2hlKHtcbiAgICBtYXg6IDUwMFxuICB9KTtcbiAgcmV0dXJuIHBhdGggPT4ge1xuICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQocGF0aCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IF9nZXREZWJ1Z0ZpbGVOYW1lKHBhdGgpO1xuICAgIGNhY2hlLnNldChwYXRoLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xudmFyIGdldERlYnVnRmlsZU5hbWUgPSBtZW1vaXplZEdldERlYnVnRmlsZU5hbWUoKTtcblxuZnVuY3Rpb24gZ2V0RGV2UHJlZml4KF9yZWYpIHtcbiAgdmFyIHtcbiAgICBkZWJ1Z0lkLFxuICAgIGRlYnVnRmlsZU5hbWVcbiAgfSA9IF9yZWY7XG4gIHZhciBwYXJ0cyA9IGRlYnVnSWQgPyBbZGVidWdJZC5yZXBsYWNlKC9cXHMvZywgJ18nKV0gOiBbXTtcbiAgaWYgKGRlYnVnRmlsZU5hbWUpIHtcbiAgICB2YXIge1xuICAgICAgZmlsZVBhdGhcbiAgICB9ID0gZ2V0RmlsZVNjb3BlKCk7XG4gICAgdmFyIF9kZWJ1Z0ZpbGVOYW1lID0gZ2V0RGVidWdGaWxlTmFtZShmaWxlUGF0aCk7XG5cbiAgICAvLyBkZWJ1Z0ZpbGVOYW1lIGNvdWxkIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgIGlmIChfZGVidWdGaWxlTmFtZSkge1xuICAgICAgcGFydHMudW5zaGlmdChfZGVidWdGaWxlTmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCdfJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIGlkZW50aWZpZXIubWF0Y2goL15bMC05XS8pID8gXCJfXCIuY29uY2F0KGlkZW50aWZpZXIpIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSWRlbnRpZmllcihhcmcpIHtcbiAgdmFyIGlkZW50T3B0aW9uID0gZ2V0SWRlbnRPcHRpb24oKTtcbiAgdmFyIHtcbiAgICBkZWJ1Z0lkLFxuICAgIGRlYnVnRmlsZU5hbWUgPSB0cnVlXG4gIH0gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyB7XG4gICAgZGVidWdJZDogYXJnXG4gIH0gOiBudWxsKSwgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgPyBhcmcgOiBudWxsKTtcblxuICAvLyBDb252ZXJ0IHJlZiBjb3VudCB0byBiYXNlIDM2IGZvciBvcHRpbWFsIGhhc2ggbGVuZ3Roc1xuICB2YXIgcmVmQ291bnQgPSBnZXRBbmRJbmNyZW1lbnRSZWZDb3VudGVyKCkudG9TdHJpbmcoMzYpO1xuICB2YXIge1xuICAgIGZpbGVQYXRoLFxuICAgIHBhY2thZ2VOYW1lXG4gIH0gPSBnZXRGaWxlU2NvcGUoKTtcbiAgdmFyIGZpbGVTY29wZUhhc2ggPSBoYXNoKHBhY2thZ2VOYW1lID8gXCJcIi5jb25jYXQocGFja2FnZU5hbWUpLmNvbmNhdChmaWxlUGF0aCkgOiBmaWxlUGF0aCk7XG4gIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoZmlsZVNjb3BlSGFzaCkuY29uY2F0KHJlZkNvdW50KTtcbiAgaWYgKGlkZW50T3B0aW9uID09PSAnZGVidWcnKSB7XG4gICAgdmFyIGRldlByZWZpeCA9IGdldERldlByZWZpeCh7XG4gICAgICBkZWJ1Z0lkLFxuICAgICAgZGVidWdGaWxlTmFtZVxuICAgIH0pO1xuICAgIGlmIChkZXZQcmVmaXgpIHtcbiAgICAgIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChkZXZQcmVmaXgsIFwiX19cIikuY29uY2F0KGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgfVxuICBpZiAodHlwZW9mIGlkZW50T3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWRlbnRpZmllciA9IGlkZW50T3B0aW9uKHtcbiAgICAgIGhhc2g6IGlkZW50aWZpZXIsXG4gICAgICBkZWJ1Z0lkLFxuICAgICAgZmlsZVBhdGgsXG4gICAgICBwYWNrYWdlTmFtZVxuICAgIH0pO1xuICAgIGlmICghaWRlbnRpZmllci5tYXRjaCgvXltBLVpfXVswLTlBLVpfLV0rJC9pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWRlbnRpZmllciBmdW5jdGlvbiByZXR1cm5lZCBpbnZhbGlkIGluZGVudGlmaWVyOiBcXFwiXCIuY29uY2F0KGlkZW50aWZpZXIsIFwiXFxcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xufVxuXG52YXIgbm9ybWFsaXNlT2JqZWN0ID0gb2JqID0+IHdhbGtPYmplY3Qob2JqLCAoKSA9PiAnJyk7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRyYWN0KGNvbnRyYWN0LCB0b2tlbnMpIHtcbiAgdmFyIHRoZURpZmYgPSBkaWZmKG5vcm1hbGlzZU9iamVjdChjb250cmFjdCksIG5vcm1hbGlzZU9iamVjdCh0b2tlbnMpKTtcbiAgdmFyIHZhbGlkID0gT2JqZWN0LmtleXModGhlRGlmZikubGVuZ3RoID09PSAwO1xuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGRpZmZTdHJpbmc6IHZhbGlkID8gJycgOiByZW5kZXJEaWZmKGNvbnRyYWN0LCB0aGVEaWZmKVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZkxpbmUodmFsdWUsIG5lc3RpbmcsIHR5cGUpIHtcbiAgdmFyIHdoaXRlc3BhY2UgPSBbLi4uQXJyYXkobmVzdGluZykua2V5cygpXS5tYXAoKCkgPT4gJyAgJykuam9pbignJyk7XG4gIHZhciBsaW5lID0gXCJcIi5jb25jYXQodHlwZSA/IHR5cGUgOiAnICcpLmNvbmNhdCh3aGl0ZXNwYWNlKS5jb25jYXQodmFsdWUpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xuICAgIGlmICh0eXBlID09PSAnLScpIHtcbiAgICAgIHJldHVybiBwYy5yZWQobGluZSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnKycpIHtcbiAgICAgIHJldHVybiBwYy5ncmVlbihsaW5lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiByZW5kZXJEaWZmKG9yaWcsIGRpZmYpIHtcbiAgdmFyIG5lc3RpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIHZhciBsaW5lcyA9IFtdO1xuICBpZiAobmVzdGluZyA9PT0gMCkge1xuICAgIGxpbmVzLnB1c2goZGlmZkxpbmUoJ3snLCAwKSk7XG4gIH1cbiAgdmFyIGlubmVyTmVzdGluZyA9IG5lc3RpbmcgKyAxO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRpZmYpLnNvcnQoKTtcbiAgZm9yICh2YXIga2V5IG9mIGtleXMpIHtcbiAgICB2YXIgdmFsdWUgPSBkaWZmW2tleV07XG4gICAgaWYgKCEoa2V5IGluIG9yaWcpKSB7XG4gICAgICBsaW5lcy5wdXNoKGRpZmZMaW5lKFwiXCIuY29uY2F0KGtleSwgXCI6IC4uLixcIiksIGlubmVyTmVzdGluZywgJysnKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBsaW5lcy5wdXNoKGRpZmZMaW5lKFwiXCIuY29uY2F0KGtleSwgXCI6IHtcIiksIGlubmVyTmVzdGluZykpO1xuICAgICAgbGluZXMucHVzaChyZW5kZXJEaWZmKG9yaWdba2V5XSwgZGlmZltrZXldLCBpbm5lck5lc3RpbmcpKTtcbiAgICAgIGxpbmVzLnB1c2goZGlmZkxpbmUoJ30nLCBpbm5lck5lc3RpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXMucHVzaChkaWZmTGluZShcIlwiLmNvbmNhdChrZXksIFwiOiAuLi4sXCIpLCBpbm5lck5lc3RpbmcsICctJykpO1xuICAgIH1cbiAgfVxuICBpZiAobmVzdGluZyA9PT0gMCkge1xuICAgIGxpbmVzLnB1c2goZGlmZkxpbmUoJ30nLCAwKSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG52YXIgYnVpbGRQcm9wZXJ0eVJ1bGUgPSBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBzeW50YXgsXG4gICAgaW5oZXJpdHMsXG4gICAgaW5pdGlhbFZhbHVlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgIHN5bnRheDogXCJcXFwiXCIuY29uY2F0KEFycmF5LmlzQXJyYXkoc3ludGF4KSA/IHN5bnRheC5qb2luKCcgfCAnKSA6IHN5bnRheCwgXCJcXFwiXCIpLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgfSwgaW5pdGlhbFZhbHVlICE9IG51bGwgPyB7XG4gICAgaW5pdGlhbFZhbHVlXG4gIH0gOiB7fSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlVmFyKGRlYnVnSWRPckRlY2xhcmF0aW9uLCBkZWJ1Z0lkKSB7XG4gIHZhciBjc3NWYXJOYW1lID0gY3NzZXNjKGdlbmVyYXRlSWRlbnRpZmllcih7XG4gICAgZGVidWdJZDogdHlwZW9mIGRlYnVnSWRPckRlY2xhcmF0aW9uID09PSAnc3RyaW5nJyA/IGRlYnVnSWRPckRlY2xhcmF0aW9uIDogZGVidWdJZCxcbiAgICBkZWJ1Z0ZpbGVOYW1lOiBmYWxzZVxuICB9KSwge1xuICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICB9KTtcbiAgaWYgKGRlYnVnSWRPckRlY2xhcmF0aW9uICYmIHR5cGVvZiBkZWJ1Z0lkT3JEZWNsYXJhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICBhcHBlbmRDc3Moe1xuICAgICAgdHlwZTogJ3Byb3BlcnR5JyxcbiAgICAgIG5hbWU6IFwiLS1cIi5jb25jYXQoY3NzVmFyTmFtZSksXG4gICAgICBydWxlOiBidWlsZFByb3BlcnR5UnVsZShkZWJ1Z0lkT3JEZWNsYXJhdGlvbilcbiAgICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIH1cbiAgcmV0dXJuIFwidmFyKC0tXCIuY29uY2F0KGNzc1Zhck5hbWUsIFwiKVwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFZhcihuYW1lLCBkZWNsYXJhdGlvbikge1xuICBpZiAoZGVjbGFyYXRpb24gJiYgdHlwZW9mIGRlY2xhcmF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIGFwcGVuZENzcyh7XG4gICAgICB0eXBlOiAncHJvcGVydHknLFxuICAgICAgbmFtZTogXCItLVwiLmNvbmNhdChuYW1lKSxcbiAgICAgIHJ1bGU6IGJ1aWxkUHJvcGVydHlSdWxlKGRlY2xhcmF0aW9uKVxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgfVxuICByZXR1cm4gXCJ2YXIoLS1cIi5jb25jYXQobmFtZSwgXCIpXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFyTmFtZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhL152YXJcXCgtLS4qXFwpJC8udGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhcmlhYmxlIG5hbWU6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICB9XG59XG5mdW5jdGlvbiBmYWxsYmFja1ZhcigpIHtcbiAgdmFyIGZpbmFsVmFsdWUgPSAnJztcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFsdWVzLnJldmVyc2UoKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAoZmluYWxWYWx1ZSA9PT0gJycpIHtcbiAgICAgIGZpbmFsVmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRWYXJOYW1lKHZhbHVlKTtcbiAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXCkkLywgXCIsIFwiLmNvbmNhdChmaW5hbFZhbHVlLCBcIilcIikpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaW5hbFZhbHVlO1xufVxuZnVuY3Rpb24gYXNzaWduVmFycyh2YXJDb250cmFjdCwgdG9rZW5zKSB7XG4gIHZhciB2YXJTZXR0ZXJzID0ge307XG4gIHZhciB7XG4gICAgdmFsaWQsXG4gICAgZGlmZlN0cmluZ1xuICB9ID0gdmFsaWRhdGVDb250cmFjdCh2YXJDb250cmFjdCwgdG9rZW5zKTtcbiAgaWYgKCF2YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRva2VucyBkb24ndCBtYXRjaCBjb250cmFjdC5cXG5cIi5jb25jYXQoZGlmZlN0cmluZykpO1xuICB9XG4gIHdhbGtPYmplY3QodG9rZW5zLCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICB2YXJTZXR0ZXJzW2dldCh2YXJDb250cmFjdCwgcGF0aCldID0gU3RyaW5nKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB2YXJTZXR0ZXJzO1xufVxuZnVuY3Rpb24gY3JlYXRlVGhlbWVDb250cmFjdCh0b2tlbnMpIHtcbiAgcmV0dXJuIHdhbGtPYmplY3QodG9rZW5zLCAoX3ZhbHVlLCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVZhcihwYXRoLmpvaW4oJy0nKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsVGhlbWVDb250cmFjdCh0b2tlbnMsIG1hcEZuKSB7XG4gIHJldHVybiB3YWxrT2JqZWN0KHRva2VucywgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgdmFyIHJhd1Zhck5hbWUgPSB0eXBlb2YgbWFwRm4gPT09ICdmdW5jdGlvbicgPyBtYXBGbih2YWx1ZSwgcGF0aCkgOiB2YWx1ZTtcbiAgICB2YXIgdmFyTmFtZSA9IHR5cGVvZiByYXdWYXJOYW1lID09PSAnc3RyaW5nJyA/IHJhd1Zhck5hbWUucmVwbGFjZSgvXlxcLVxcLS8sICcnKSA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiB2YXJOYW1lICE9PSAnc3RyaW5nJyB8fCB2YXJOYW1lICE9PSBjc3Nlc2ModmFyTmFtZSwge1xuICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFyaWFibGUgbmFtZSBmb3IgXFxcIlwiLmNvbmNhdChwYXRoLmpvaW4oJy4nKSwgXCJcXFwiOiBcIikuY29uY2F0KHZhck5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwidmFyKC0tXCIuY29uY2F0KHZhck5hbWUsIFwiKVwiKTtcbiAgfSk7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJAbGF5ZXJcIl07XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxUaGVtZShzZWxlY3RvciwgYXJnMiwgYXJnMykge1xuICB2YXIgdGhlbWVDb250cmFjdFByb3ZpZGVkID0gQm9vbGVhbihhcmczKTtcbiAgdmFyIHRva2VuQXJnID0gdGhlbWVDb250cmFjdFByb3ZpZGVkID8gYXJnMyA6IGFyZzI7XG4gIHZhciB7XG4gICAgbGF5ZXJOYW1lLFxuICAgIHRva2Vuc1xuICB9ID0gZXh0cmFjdExheWVyRnJvbVRva2Vucyh0b2tlbkFyZyk7XG4gIHZhciB0aGVtZUNvbnRyYWN0ID0gdGhlbWVDb250cmFjdFByb3ZpZGVkID8gYXJnMiA6IGNyZWF0ZVRoZW1lQ29udHJhY3QodG9rZW5zKTtcbiAgdmFyIHJ1bGUgPSB7XG4gICAgdmFyczogYXNzaWduVmFycyh0aGVtZUNvbnRyYWN0LCB0b2tlbnMpXG4gIH07XG4gIGlmIChsYXllck5hbWUpIHtcbiAgICBydWxlID0ge1xuICAgICAgJ0BsYXllcic6IHtcbiAgICAgICAgW2xheWVyTmFtZV06IHJ1bGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFwcGVuZENzcyh7XG4gICAgdHlwZTogJ2dsb2JhbCcsXG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHJ1bGVcbiAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xuICBpZiAoIXRoZW1lQ29udHJhY3RQcm92aWRlZCkge1xuICAgIHJldHVybiB0aGVtZUNvbnRyYWN0O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUaGVtZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gIHZhciB0aGVtZUNsYXNzTmFtZSA9IGdlbmVyYXRlSWRlbnRpZmllcih0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgPyBhcmczIDogYXJnMik7XG4gIHJlZ2lzdGVyQ2xhc3NOYW1lKHRoZW1lQ2xhc3NOYW1lLCBnZXRGaWxlU2NvcGUoKSk7XG4gIHZhciB2YXJzID0gdHlwZW9mIGFyZzIgPT09ICdvYmplY3QnID8gY3JlYXRlR2xvYmFsVGhlbWUodGhlbWVDbGFzc05hbWUsIGFyZzEsIGFyZzIpIDogY3JlYXRlR2xvYmFsVGhlbWUodGhlbWVDbGFzc05hbWUsIGFyZzEpO1xuICByZXR1cm4gdmFycyA/IFt0aGVtZUNsYXNzTmFtZSwgdmFyc10gOiB0aGVtZUNsYXNzTmFtZTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RMYXllckZyb21Ub2tlbnModG9rZW5zKSB7XG4gIGlmICgnQGxheWVyJyBpbiB0b2tlbnMpIHtcbiAgICB2YXIge1xuICAgICAgICAnQGxheWVyJzogbGF5ZXJOYW1lXG4gICAgICB9ID0gdG9rZW5zLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyh0b2tlbnMsIF9leGNsdWRlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIHRva2VuczogcmVzdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnNcbiAgfTtcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdDtcbmZ1bmN0aW9uIGNvbXBvc2VkU3R5bGUocnVsZXMsIGRlYnVnSWQpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IGdlbmVyYXRlSWRlbnRpZmllcihkZWJ1Z0lkKTtcbiAgcmVnaXN0ZXJDbGFzc05hbWUoY2xhc3NOYW1lLCBnZXRGaWxlU2NvcGUoKSk7XG4gIHZhciBjbGFzc0xpc3QgPSBbXTtcbiAgdmFyIHN0eWxlUnVsZXMgPSBbXTtcbiAgZm9yICh2YXIgcnVsZSBvZiBydWxlcykge1xuICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKHJ1bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVJ1bGVzLnB1c2gocnVsZSk7XG4gICAgfVxuICB9XG4gIHZhciByZXN1bHQgPSBjbGFzc05hbWU7XG4gIGlmIChjbGFzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCA9IFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdChkdWR1cGVBbmRKb2luQ2xhc3NMaXN0KGNsYXNzTGlzdCkpO1xuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24oe1xuICAgICAgaWRlbnRpZmllcjogY2xhc3NOYW1lLFxuICAgICAgY2xhc3NMaXN0OiByZXN1bHRcbiAgICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gICAgaWYgKHN0eWxlUnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHN0eWxlcyBhdHRhY2hlZCB0byB0aGlzIGNvbXBvc2l0aW9uIHRoZW4gaXQgaXNcbiAgICAgIC8vIGFsd2F5cyB1c2VkIGFuZCBzaG91bGQgbmV2ZXIgYmUgcmVtb3ZlZFxuICAgICAgbWFya0NvbXBvc2l0aW9uVXNlZChjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIF9ydWxlID0gZGVlcG1lcmdlLmFsbChzdHlsZVJ1bGVzLCB7XG4gICAgICAvLyBSZXBsYWNlIGFycmF5cyByYXRoZXIgdGhhbiBtZXJnaW5nXG4gICAgICBhcnJheU1lcmdlOiAoXywgc291cmNlQXJyYXkpID0+IHNvdXJjZUFycmF5XG4gICAgfSk7XG4gICAgYXBwZW5kQ3NzKHtcbiAgICAgIHR5cGU6ICdsb2NhbCcsXG4gICAgICBzZWxlY3RvcjogY2xhc3NOYW1lLFxuICAgICAgcnVsZTogX3J1bGVcbiAgICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHN0eWxlKHJ1bGUsIGRlYnVnSWQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkpIHtcbiAgICByZXR1cm4gY29tcG9zZWRTdHlsZShydWxlLCBkZWJ1Z0lkKTtcbiAgfVxuICB2YXIgY2xhc3NOYW1lID0gZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpO1xuICByZWdpc3RlckNsYXNzTmFtZShjbGFzc05hbWUsIGdldEZpbGVTY29wZSgpKTtcbiAgYXBwZW5kQ3NzKHtcbiAgICB0eXBlOiAnbG9jYWwnLFxuICAgIHNlbGVjdG9yOiBjbGFzc05hbWUsXG4gICAgcnVsZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBpcyBub3cgcHJvdmlkZWQgYnkgdGhlICdzdHlsZScgZnVuY3Rpb24gd2hlbiB5b3UgcGFzcyBpdCBhbiBhcnJheVxuICovXG5mdW5jdGlvbiBjb21wb3NlU3R5bGVzKCkge1xuICB2YXIgY29tcG9zZSA9IGhhc0ZpbGVTY29wZSgpID8gY29tcG9zZWRTdHlsZSA6IGR1ZHVwZUFuZEpvaW5DbGFzc0xpc3Q7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc05hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNsYXNzTmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2UoY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBnbG9iYWxTdHlsZShzZWxlY3RvciwgcnVsZSkge1xuICBhcHBlbmRDc3Moe1xuICAgIHR5cGU6ICdnbG9iYWwnLFxuICAgIHNlbGVjdG9yLFxuICAgIHJ1bGVcbiAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xufVxuZnVuY3Rpb24gZm9udEZhY2UocnVsZSwgZGVidWdJZCkge1xuICB2YXIgZm9udEZhbWlseSA9IFwiXFxcIlwiLmNvbmNhdChjc3Nlc2MoZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpLCB7XG4gICAgcXVvdGVzOiAnZG91YmxlJ1xuICB9KSwgXCJcXFwiXCIpO1xuICB2YXIgcnVsZXMgPSBBcnJheS5pc0FycmF5KHJ1bGUpID8gcnVsZSA6IFtydWxlXTtcbiAgZm9yICh2YXIgc2luZ2xlUnVsZSBvZiBydWxlcykge1xuICAgIGlmICgnZm9udEZhbWlseScgaW4gc2luZ2xlUnVsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGRlZGVudChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgaGFzaGVkIGZvbnQtZmFtaWx5IG5hbWUsIHNvIHRoZSBcXFwiZm9udEZhbWlseVxcXCIgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBwcm92aWRlZC5cXG4gICAgXFxuICAgICAgSWYgeW91J2QgbGlrZSB0byBkZWZpbmUgYSBnbG9iYWxseSBzY29wZWQgY3VzdG9tIGZvbnQsIHlvdSBjYW4gdXNlIHRoZSBcXFwiZ2xvYmFsRm9udEZhY2VcXFwiIGZ1bmN0aW9uIGluc3RlYWQuXFxuICAgIFwiXSkpKSk7XG4gICAgfVxuICAgIGFwcGVuZENzcyh7XG4gICAgICB0eXBlOiAnZm9udEZhY2UnLFxuICAgICAgcnVsZTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNpbmdsZVJ1bGUpLCB7fSwge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9KVxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgfVxuICByZXR1cm4gZm9udEZhbWlseTtcbn1cbmZ1bmN0aW9uIGdsb2JhbEZvbnRGYWNlKGZvbnRGYW1pbHksIHJ1bGUpIHtcbiAgdmFyIHJ1bGVzID0gQXJyYXkuaXNBcnJheShydWxlKSA/IHJ1bGUgOiBbcnVsZV07XG4gIGZvciAodmFyIHNpbmdsZVJ1bGUgb2YgcnVsZXMpIHtcbiAgICBhcHBlbmRDc3Moe1xuICAgICAgdHlwZTogJ2ZvbnRGYWNlJyxcbiAgICAgIHJ1bGU6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzaW5nbGVSdWxlKSwge30sIHtcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgfSlcbiAgICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyhydWxlLCBkZWJ1Z0lkKSB7XG4gIHZhciBuYW1lID0gY3NzZXNjKGdlbmVyYXRlSWRlbnRpZmllcihkZWJ1Z0lkKSwge1xuICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICB9KTtcbiAgYXBwZW5kQ3NzKHtcbiAgICB0eXBlOiAna2V5ZnJhbWVzJyxcbiAgICBuYW1lLFxuICAgIHJ1bGVcbiAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGdsb2JhbEtleWZyYW1lcyhuYW1lLCBydWxlKSB7XG4gIGFwcGVuZENzcyh7XG4gICAgdHlwZTogJ2tleWZyYW1lcycsXG4gICAgbmFtZSxcbiAgICBydWxlXG4gIH0sIGdldEZpbGVTY29wZSgpKTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFyaWFudHMoKSB7XG4gIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgX2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIF9tYXBEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBfZGVidWdJZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgX2NsYXNzTWFwID0ge307XG4gICAgZm9yICh2YXIgX2tleTIgaW4gX2RhdGEpIHtcbiAgICAgIF9jbGFzc01hcFtfa2V5Ml0gPSBzdHlsZShfbWFwRGF0YShfZGF0YVtfa2V5Ml0sIF9rZXkyKSwgX2RlYnVnSWQgPyBcIlwiLmNvbmNhdChfZGVidWdJZCwgXCJfXCIpLmNvbmNhdChfa2V5MikgOiBfa2V5Mik7XG4gICAgfVxuICAgIHJldHVybiBfY2xhc3NNYXA7XG4gIH1cbiAgdmFyIHN0eWxlTWFwID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICB2YXIgZGVidWdJZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGNsYXNzTWFwID0ge307XG4gIGZvciAodmFyIF9rZXkzIGluIHN0eWxlTWFwKSB7XG4gICAgY2xhc3NNYXBbX2tleTNdID0gc3R5bGUoc3R5bGVNYXBbX2tleTNdLCBkZWJ1Z0lkID8gXCJcIi5jb25jYXQoZGVidWdJZCwgXCJfXCIpLmNvbmNhdChfa2V5MykgOiBfa2V5Myk7XG4gIH1cbiAgcmV0dXJuIGNsYXNzTWFwO1xufVxuXG4vLyBjcmVhdGVDb250YWluZXIgaXMgdXNlZCBmb3IgbG9jYWwgc2NvcGluZyBvZiBDU1MgY29udGFpbmVyc1xuLy8gRm9yIG5vdyBpdCBpcyBtb3N0bHkganVzdCBhbiBhbGlhcyBvZiBnZW5lcmF0ZUlkZW50aWZpZXJcbnZhciBjcmVhdGVDb250YWluZXIgPSBkZWJ1Z0lkID0+IGdlbmVyYXRlSWRlbnRpZmllcihkZWJ1Z0lkKTtcblxuLy8gY3JlYXRlVmlld1RyYW5zaXRpb24gaXMgdXNlZCBmb3IgbG9jYWxseSBzY29waW5nIENTUyB2aWV3IHRyYW5zaXRpb25zXG4vLyBGb3Igbm93IGl0IGlzIG1vc3RseSBqdXN0IGFuIGFsaWFzIG9mIGdlbmVyYXRlSWRlbnRpZmllclxudmFyIGNyZWF0ZVZpZXdUcmFuc2l0aW9uID0gZGVidWdJZCA9PiBnZW5lcmF0ZUlkZW50aWZpZXIoZGVidWdJZCk7XG5cbnZhciBkZWZhdWx0TGF5ZXJPcHRpb25zID0ge307XG52YXIgbWVyZ2UgPSAob2JqMSwgb2JqMikgPT4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9iajEpLCBvYmoyKTtcbnZhciBnZXRMYXllckFyZ3MgPSBmdW5jdGlvbiBnZXRMYXllckFyZ3MoKSB7XG4gIHZhciBvcHRpb25zID0gZGVmYXVsdExheWVyT3B0aW9ucztcbiAgdmFyIGRlYnVnSWQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRMYXllck9wdGlvbnMsIGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgZGVidWdJZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgfVxuICByZXR1cm4gW29wdGlvbnMsIGRlYnVnSWRdO1xufTtcbmZ1bmN0aW9uIGxheWVyKCkge1xuICB2YXIgW29wdGlvbnMsIGRlYnVnSWRdID0gZ2V0TGF5ZXJBcmdzKC4uLmFyZ3VtZW50cyk7XG4gIHZhciBuYW1lID0gZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpO1xuICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICBuYW1lID0gXCJcIi5jb25jYXQob3B0aW9ucy5wYXJlbnQsIFwiLlwiKS5jb25jYXQobmFtZSk7XG4gIH1cbiAgYXBwZW5kQ3NzKHtcbiAgICB0eXBlOiAnbGF5ZXInLFxuICAgIG5hbWVcbiAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGdsb2JhbExheWVyKCkge1xuICB2YXIgW29wdGlvbnMsIG5hbWVdID0gZ2V0TGF5ZXJBcmdzKC4uLmFyZ3VtZW50cyk7XG4gIGlmIChvcHRpb25zLnBhcmVudCkge1xuICAgIG5hbWUgPSBcIlwiLmNvbmNhdChvcHRpb25zLnBhcmVudCwgXCIuXCIpLmNvbmNhdChuYW1lKTtcbiAgfVxuICBhcHBlbmRDc3Moe1xuICAgIHR5cGU6ICdsYXllcicsXG4gICAgbmFtZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgeyBhc3NlcnRWYXJOYW1lLCBhc3NpZ25WYXJzLCBjb21wb3NlU3R5bGVzLCBjcmVhdGVDb250YWluZXIsIGNyZWF0ZUdsb2JhbFRoZW1lLCBjcmVhdGVHbG9iYWxUaGVtZUNvbnRyYWN0LCBjcmVhdGVHbG9iYWxWYXIsIGNyZWF0ZVRoZW1lLCBjcmVhdGVUaGVtZUNvbnRyYWN0LCBjcmVhdGVWYXIsIGNyZWF0ZVZpZXdUcmFuc2l0aW9uLCBmYWxsYmFja1ZhciwgZm9udEZhY2UsIGdlbmVyYXRlSWRlbnRpZmllciwgZ2xvYmFsRm9udEZhY2UsIGdsb2JhbEtleWZyYW1lcywgZ2xvYmFsTGF5ZXIsIGdsb2JhbFN0eWxlLCBrZXlmcmFtZXMsIGxheWVyLCBzdHlsZSwgc3R5bGVWYXJpYW50cyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   endFileScope: () => (/* binding */ endFileScope),\n/* harmony export */   getAndIncrementRefCounter: () => (/* binding */ getAndIncrementRefCounter),\n/* harmony export */   getFileScope: () => (/* binding */ getFileScope),\n/* harmony export */   hasFileScope: () => (/* binding */ hasFileScope),\n/* harmony export */   setFileScope: () => (/* binding */ setFileScope)\n/* harmony export */ });\n/* harmony import */ var _dist_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n\n\n\n\nvar _templateObject;\nvar refCounter = 0;\nvar fileScopes = [];\nfunction setFileScope(filePath, packageName) {\n  refCounter = 0;\n  var fileScope = {\n    filePath,\n    packageName\n  };\n  fileScopes.unshift(fileScope);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__.onBeginFileScope)(fileScope);\n}\nfunction endFileScope() {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__.onEndFileScope)(getFileScope());\n  refCounter = 0;\n  fileScopes.splice(0, 1);\n}\nfunction hasFileScope() {\n  return fileScopes.length > 0;\n}\nfunction getFileScope() {\n  if (fileScopes.length === 0) {\n    throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject || (_templateObject = (0,_dist_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_0__._)([\"\\n        Styles were unable to be assigned to a file. This is generally caused by one of the following:\\n\\n        - You may have created styles outside of a '.css.ts' context\\n        - You may have incorrect configuration. See https://vanilla-extract.style/documentation/getting-started\\n      \"]))));\n  }\n  return fileScopes[0];\n}\nfunction getAndIncrementRefCounter() {\n  return refCounter++;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2ZpbGVTY29wZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtZmlsZVNjb3BlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErRjtBQUNuRTtBQUM2RTs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtHQUFnQjtBQUNsQjtBQUNBO0FBQ0EsRUFBRSxnR0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFNLHVDQUF1Qyw4RUFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RiIsInNvdXJjZXMiOlsid2VicGFjazovL3plcm92YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3MvZmlsZVNjb3BlL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1maWxlU2NvcGUuZXNtLmpzPzM3ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsIH0gZnJvbSAnLi4vLi4vZGlzdC90YWdnZWRUZW1wbGF0ZUxpdGVyYWwtMTA5OTgzMTUuZXNtLmpzJztcbmltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcbmltcG9ydCB7IG9uQmVnaW5GaWxlU2NvcGUsIG9uRW5kRmlsZVNjb3BlIH0gZnJvbSAnLi4vLi4vYWRhcHRlci9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtYWRhcHRlci5lc20uanMnO1xuXG52YXIgX3RlbXBsYXRlT2JqZWN0O1xudmFyIHJlZkNvdW50ZXIgPSAwO1xudmFyIGZpbGVTY29wZXMgPSBbXTtcbmZ1bmN0aW9uIHNldEZpbGVTY29wZShmaWxlUGF0aCwgcGFja2FnZU5hbWUpIHtcbiAgcmVmQ291bnRlciA9IDA7XG4gIHZhciBmaWxlU2NvcGUgPSB7XG4gICAgZmlsZVBhdGgsXG4gICAgcGFja2FnZU5hbWVcbiAgfTtcbiAgZmlsZVNjb3Blcy51bnNoaWZ0KGZpbGVTY29wZSk7XG4gIG9uQmVnaW5GaWxlU2NvcGUoZmlsZVNjb3BlKTtcbn1cbmZ1bmN0aW9uIGVuZEZpbGVTY29wZSgpIHtcbiAgb25FbmRGaWxlU2NvcGUoZ2V0RmlsZVNjb3BlKCkpO1xuICByZWZDb3VudGVyID0gMDtcbiAgZmlsZVNjb3Blcy5zcGxpY2UoMCwgMSk7XG59XG5mdW5jdGlvbiBoYXNGaWxlU2NvcGUoKSB7XG4gIHJldHVybiBmaWxlU2NvcGVzLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBnZXRGaWxlU2NvcGUoKSB7XG4gIGlmIChmaWxlU2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihkZWRlbnQoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgU3R5bGVzIHdlcmUgdW5hYmxlIHRvIGJlIGFzc2lnbmVkIHRvIGEgZmlsZS4gVGhpcyBpcyBnZW5lcmFsbHkgY2F1c2VkIGJ5IG9uZSBvZiB0aGUgZm9sbG93aW5nOlxcblxcbiAgICAgICAgLSBZb3UgbWF5IGhhdmUgY3JlYXRlZCBzdHlsZXMgb3V0c2lkZSBvZiBhICcuY3NzLnRzJyBjb250ZXh0XFxuICAgICAgICAtIFlvdSBtYXkgaGF2ZSBpbmNvcnJlY3QgY29uZmlndXJhdGlvbi4gU2VlIGh0dHBzOi8vdmFuaWxsYS1leHRyYWN0LnN0eWxlL2RvY3VtZW50YXRpb24vZ2V0dGluZy1zdGFydGVkXFxuICAgICAgXCJdKSkpKTtcbiAgfVxuICByZXR1cm4gZmlsZVNjb3Blc1swXTtcbn1cbmZ1bmN0aW9uIGdldEFuZEluY3JlbWVudFJlZkNvdW50ZXIoKSB7XG4gIHJldHVybiByZWZDb3VudGVyKys7XG59XG5cbmV4cG9ydCB7IGVuZEZpbGVTY29wZSwgZ2V0QW5kSW5jcmVtZW50UmVmQ291bnRlciwgZ2V0RmlsZVNjb3BlLCBoYXNGaWxlU2NvcGUsIHNldEZpbGVTY29wZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   injectStyles: () => (/* binding */ injectStyles)\n/* harmony export */ });\nvar stylesheets = {};\nvar injectStyles = _ref => {\n  var {\n    fileScope,\n    css\n  } = _ref;\n  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join('/') : fileScope.filePath;\n  var stylesheet = stylesheets[fileScopeId];\n  if (!stylesheet) {\n    var styleEl = document.createElement('style');\n    if (fileScope.packageName) {\n      styleEl.setAttribute('data-package', fileScope.packageName);\n    }\n    styleEl.setAttribute('data-file', fileScope.filePath);\n    styleEl.setAttribute('type', 'text/css');\n    stylesheet = stylesheets[fileScopeId] = styleEl;\n    document.head.appendChild(styleEl);\n  }\n  stylesheet.innerHTML = css;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2luamVjdFN0eWxlcy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtaW5qZWN0U3R5bGVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3plcm92YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3MvaW5qZWN0U3R5bGVzL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1pbmplY3RTdHlsZXMuZXNtLmpzP2YyM2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHN0eWxlc2hlZXRzID0ge307XG52YXIgaW5qZWN0U3R5bGVzID0gX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgZmlsZVNjb3BlLFxuICAgIGNzc1xuICB9ID0gX3JlZjtcbiAgdmFyIGZpbGVTY29wZUlkID0gZmlsZVNjb3BlLnBhY2thZ2VOYW1lID8gW2ZpbGVTY29wZS5wYWNrYWdlTmFtZSwgZmlsZVNjb3BlLmZpbGVQYXRoXS5qb2luKCcvJykgOiBmaWxlU2NvcGUuZmlsZVBhdGg7XG4gIHZhciBzdHlsZXNoZWV0ID0gc3R5bGVzaGVldHNbZmlsZVNjb3BlSWRdO1xuICBpZiAoIXN0eWxlc2hlZXQpIHtcbiAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaWYgKGZpbGVTY29wZS5wYWNrYWdlTmFtZSkge1xuICAgICAgc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFja2FnZScsIGZpbGVTY29wZS5wYWNrYWdlTmFtZSk7XG4gICAgfVxuICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLWZpbGUnLCBmaWxlU2NvcGUuZmlsZVBhdGgpO1xuICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgc3R5bGVzaGVldCA9IHN0eWxlc2hlZXRzW2ZpbGVTY29wZUlkXSA9IHN0eWxlRWw7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuICBzdHlsZXNoZWV0LmlubmVySFRNTCA9IGNzcztcbn07XG5cbmV4cG9ydCB7IGluamVjdFN0eWxlcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignInlineVars: () => (/* binding */ assignInlineVars),\n/* harmony export */   setElementVars: () => (/* binding */ setElementVars)\n/* harmony export */ });\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n\n\nfunction assignInlineVars(varsOrContract, tokens) {\n  var styles = {};\n  if (typeof tokens === 'object') {\n    var _contract = varsOrContract;\n    (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.walkObject)(tokens, (value, path) => {\n      if (value == null) {\n        return;\n      }\n      var varName = (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.get)(_contract, path);\n      styles[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(varName)] = String(value);\n    });\n  } else {\n    var _vars = varsOrContract;\n    for (var varName in _vars) {\n      var value = _vars[varName];\n      if (value == null) {\n        continue;\n      }\n      styles[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(varName)] = value;\n    }\n  }\n  Object.defineProperty(styles, 'toString', {\n    value: function value() {\n      return Object.keys(this).map(key => \"\".concat(key, \":\").concat(this[key])).join(';');\n    },\n    writable: false\n  });\n  return styles;\n}\n\nfunction setVar(element, variable, value) {\n  element.style.setProperty((0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(variable), value);\n}\nfunction setElementVars(element, varsOrContract, tokens) {\n  if (typeof tokens === 'object') {\n    var _contract = varsOrContract;\n    (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.walkObject)(tokens, (value, path) => {\n      if (value == null) {\n        return;\n      }\n      setVar(element, (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.get)(_contract, path), String(value));\n    });\n  } else {\n    var _vars = varsOrContract;\n    for (var varName in _vars) {\n      var value = _vars[varName];\n      if (value == null) {\n        continue;\n      }\n      setVar(element, varName, _vars[varName]);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvZHluYW1pYy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1keW5hbWljLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBRztBQUN2QixhQUFhLG9FQUFVO0FBQ3ZCLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvRUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQUc7QUFDekIsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXJvdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvZHluYW1pYy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1keW5hbWljLmVzbS5qcz8xN2ZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdhbGtPYmplY3QsIGdldCwgZ2V0VmFyTmFtZSB9IGZyb20gJ0B2YW5pbGxhLWV4dHJhY3QvcHJpdmF0ZSc7XG5cbmZ1bmN0aW9uIGFzc2lnbklubGluZVZhcnModmFyc09yQ29udHJhY3QsIHRva2Vucykge1xuICB2YXIgc3R5bGVzID0ge307XG4gIGlmICh0eXBlb2YgdG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBfY29udHJhY3QgPSB2YXJzT3JDb250cmFjdDtcbiAgICB3YWxrT2JqZWN0KHRva2VucywgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFyTmFtZSA9IGdldChfY29udHJhY3QsIHBhdGgpO1xuICAgICAgc3R5bGVzW2dldFZhck5hbWUodmFyTmFtZSldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3ZhcnMgPSB2YXJzT3JDb250cmFjdDtcbiAgICBmb3IgKHZhciB2YXJOYW1lIGluIF92YXJzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfdmFyc1t2YXJOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3R5bGVzW2dldFZhck5hbWUodmFyTmFtZSldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsICd0b1N0cmluZycsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubWFwKGtleSA9PiBcIlwiLmNvbmNhdChrZXksIFwiOlwiKS5jb25jYXQodGhpc1trZXldKSkuam9pbignOycpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBzZXRWYXIoZWxlbWVudCwgdmFyaWFibGUsIHZhbHVlKSB7XG4gIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoZ2V0VmFyTmFtZSh2YXJpYWJsZSksIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRWYXJzKGVsZW1lbnQsIHZhcnNPckNvbnRyYWN0LCB0b2tlbnMpIHtcbiAgaWYgKHR5cGVvZiB0b2tlbnMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9jb250cmFjdCA9IHZhcnNPckNvbnRyYWN0O1xuICAgIHdhbGtPYmplY3QodG9rZW5zLCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFZhcihlbGVtZW50LCBnZXQoX2NvbnRyYWN0LCBwYXRoKSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF92YXJzID0gdmFyc09yQ29udHJhY3Q7XG4gICAgZm9yICh2YXIgdmFyTmFtZSBpbiBfdmFycykge1xuICAgICAgdmFyIHZhbHVlID0gX3ZhcnNbdmFyTmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNldFZhcihlbGVtZW50LCB2YXJOYW1lLCBfdmFyc1t2YXJOYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGFzc2lnbklubGluZVZhcnMsIHNldEVsZW1lbnRWYXJzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getVarName: () => (/* binding */ getVarName),\n/* harmony export */   walkObject: () => (/* binding */ walkObject)\n/* harmony export */ });\nfunction getVarName(variable) {\n  var matches = variable.match(/^var\\((.*)\\)$/);\n  if (matches) {\n    return matches[1];\n  }\n  return variable;\n}\n\nfunction get(obj, path) {\n  var result = obj;\n  for (var key of path) {\n    if (!(key in result)) {\n      throw new Error(\"Path \".concat(path.join(' -> '), \" does not exist in object\"));\n    }\n    result = result[key];\n  }\n  return result;\n}\n\nfunction walkObject(obj, fn) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var clone = {};\n  for (var key in obj) {\n    var _value = obj[key];\n    var currentPath = [...path, key];\n    if (typeof _value === 'string' || typeof _value === 'number' || _value == null) {\n      clone[key] = fn(_value, currentPath);\n    } else if (typeof _value === 'object' && !Array.isArray(_value)) {\n      clone[key] = walkObject(_value, fn, currentPath);\n    } else {\n      console.warn(\"Skipping invalid key \\\"\".concat(currentPath.join('.'), \"\\\". Should be a string, number, null or object. Received: \\\"\").concat(Array.isArray(_value) ? 'Array' : typeof _value, \"\\\"\"));\n    }\n  }\n  return clone;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcHJpdmF0ZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1wcml2YXRlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVyb3ZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L3ByaXZhdGUvZGlzdC92YW5pbGxhLWV4dHJhY3QtcHJpdmF0ZS5lc20uanM/ZWNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRWYXJOYW1lKHZhcmlhYmxlKSB7XG4gIHZhciBtYXRjaGVzID0gdmFyaWFibGUubWF0Y2goL152YXJcXCgoLiopXFwpJC8pO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICB9XG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICB2YXIgcmVzdWx0ID0gb2JqO1xuICBmb3IgKHZhciBrZXkgb2YgcGF0aCkge1xuICAgIGlmICghKGtleSBpbiByZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIFwiLmNvbmNhdChwYXRoLmpvaW4oJyAtPiAnKSwgXCIgZG9lcyBub3QgZXhpc3QgaW4gb2JqZWN0XCIpKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0W2tleV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd2Fsa09iamVjdChvYmosIGZuKSB7XG4gIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgdmFyIGNsb25lID0ge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICB2YXIgX3ZhbHVlID0gb2JqW2tleV07XG4gICAgdmFyIGN1cnJlbnRQYXRoID0gWy4uLnBhdGgsIGtleV07XG4gICAgaWYgKHR5cGVvZiBfdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBfdmFsdWUgPT09ICdudW1iZXInIHx8IF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjbG9uZVtrZXldID0gZm4oX3ZhbHVlLCBjdXJyZW50UGF0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3ZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShfdmFsdWUpKSB7XG4gICAgICBjbG9uZVtrZXldID0gd2Fsa09iamVjdChfdmFsdWUsIGZuLCBjdXJyZW50UGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIGludmFsaWQga2V5IFxcXCJcIi5jb25jYXQoY3VycmVudFBhdGguam9pbignLicpLCBcIlxcXCIuIFNob3VsZCBiZSBhIHN0cmluZywgbnVtYmVyLCBudWxsIG9yIG9iamVjdC4gUmVjZWl2ZWQ6IFxcXCJcIikuY29uY2F0KEFycmF5LmlzQXJyYXkoX3ZhbHVlKSA/ICdBcnJheScgOiB0eXBlb2YgX3ZhbHVlLCBcIlxcXCJcIikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmV4cG9ydCB7IGdldCwgZ2V0VmFyTmFtZSwgd2Fsa09iamVjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRuntimeFn: () => (/* reexport safe */ _dist_createRuntimeFn_62c9670f_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)\n/* harmony export */ });\n/* harmony import */ var _dist_createRuntimeFn_62c9670f_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/createRuntimeFn-62c9670f.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9jcmVhdGVSdW50aW1lRm4vZGlzdC92YW5pbGxhLWV4dHJhY3QtcmVjaXBlcy1jcmVhdGVSdW50aW1lRm4uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVyb3ZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L3JlY2lwZXMvY3JlYXRlUnVudGltZUZuL2Rpc3QvdmFuaWxsYS1leHRyYWN0LXJlY2lwZXMtY3JlYXRlUnVudGltZUZuLmVzbS5qcz9mZmE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGMgYXMgY3JlYXRlUnVudGltZUZuIH0gZnJvbSAnLi4vLi4vZGlzdC9jcmVhdGVSdW50aW1lRm4tNjJjOTY3MGYuZXNtLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ createRuntimeFn),\n/* harmony export */   m: () => (/* binding */ mapValues)\n/* harmony export */ });\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction mapValues(input, fn) {\n  var result = {};\n  for (var _key in input) {\n    result[_key] = fn(input[_key], _key);\n  }\n  return result;\n}\n\nvar shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {\n  for (var key of Object.keys(compoundCheck)) {\n    var _selections$key;\n    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {\n      return false;\n    }\n  }\n  return true;\n};\nvar createRuntimeFn = config => {\n  var runtimeFn = options => {\n    var className = config.defaultClassName;\n    var selections = _objectSpread2(_objectSpread2({}, config.defaultVariants), options);\n    for (var variantName in selections) {\n      var _selections$variantNa;\n      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];\n      if (variantSelection != null) {\n        var selection = variantSelection;\n        if (typeof selection === 'boolean') {\n          // @ts-expect-error\n          selection = selection === true ? 'true' : 'false';\n        }\n        var selectionClassName =\n        // @ts-expect-error\n        config.variantClassNames[variantName][selection];\n        if (selectionClassName) {\n          className += ' ' + selectionClassName;\n        }\n      }\n    }\n    for (var [compoundCheck, compoundClassName] of config.compoundVariants) {\n      if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {\n        className += ' ' + compoundClassName;\n      }\n    }\n    return className;\n  };\n  runtimeFn.variants = () => Object.keys(config.variantClassNames);\n  runtimeFn.classNames = {\n    get base() {\n      return config.defaultClassName.split(' ')[0];\n    },\n    get variants() {\n      return mapValues(config.variantClassNames, classNames => mapValues(classNames, className => className.split(' ')[0]));\n    }\n  };\n  return runtimeFn;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9kaXN0L2NyZWF0ZVJ1bnRpbWVGbi02MmM5NjcwZi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXJvdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9kaXN0L2NyZWF0ZVJ1bnRpbWVGbi02MmM5NjcwZi5lc20uanM/ZmQyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBtYXBWYWx1ZXMoaW5wdXQsIGZuKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgX2tleSBpbiBpbnB1dCkge1xuICAgIHJlc3VsdFtfa2V5XSA9IGZuKGlucHV0W19rZXldLCBfa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgc2hvdWxkQXBwbHlDb21wb3VuZCA9IChjb21wb3VuZENoZWNrLCBzZWxlY3Rpb25zLCBkZWZhdWx0VmFyaWFudHMpID0+IHtcbiAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKGNvbXBvdW5kQ2hlY2spKSB7XG4gICAgdmFyIF9zZWxlY3Rpb25zJGtleTtcbiAgICBpZiAoY29tcG91bmRDaGVja1trZXldICE9PSAoKF9zZWxlY3Rpb25zJGtleSA9IHNlbGVjdGlvbnNba2V5XSkgIT09IG51bGwgJiYgX3NlbGVjdGlvbnMka2V5ICE9PSB2b2lkIDAgPyBfc2VsZWN0aW9ucyRrZXkgOiBkZWZhdWx0VmFyaWFudHNba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGNyZWF0ZVJ1bnRpbWVGbiA9IGNvbmZpZyA9PiB7XG4gIHZhciBydW50aW1lRm4gPSBvcHRpb25zID0+IHtcbiAgICB2YXIgY2xhc3NOYW1lID0gY29uZmlnLmRlZmF1bHRDbGFzc05hbWU7XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29uZmlnLmRlZmF1bHRWYXJpYW50cyksIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIHZhcmlhbnROYW1lIGluIHNlbGVjdGlvbnMpIHtcbiAgICAgIHZhciBfc2VsZWN0aW9ucyR2YXJpYW50TmE7XG4gICAgICB2YXIgdmFyaWFudFNlbGVjdGlvbiA9IChfc2VsZWN0aW9ucyR2YXJpYW50TmEgPSBzZWxlY3Rpb25zW3ZhcmlhbnROYW1lXSkgIT09IG51bGwgJiYgX3NlbGVjdGlvbnMkdmFyaWFudE5hICE9PSB2b2lkIDAgPyBfc2VsZWN0aW9ucyR2YXJpYW50TmEgOiBjb25maWcuZGVmYXVsdFZhcmlhbnRzW3ZhcmlhbnROYW1lXTtcbiAgICAgIGlmICh2YXJpYW50U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHZhcmlhbnRTZWxlY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0aW9uQ2xhc3NOYW1lID1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25maWcudmFyaWFudENsYXNzTmFtZXNbdmFyaWFudE5hbWVdW3NlbGVjdGlvbl07XG4gICAgICAgIGlmIChzZWxlY3Rpb25DbGFzc05hbWUpIHtcbiAgICAgICAgICBjbGFzc05hbWUgKz0gJyAnICsgc2VsZWN0aW9uQ2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIFtjb21wb3VuZENoZWNrLCBjb21wb3VuZENsYXNzTmFtZV0gb2YgY29uZmlnLmNvbXBvdW5kVmFyaWFudHMpIHtcbiAgICAgIGlmIChzaG91bGRBcHBseUNvbXBvdW5kKGNvbXBvdW5kQ2hlY2ssIHNlbGVjdGlvbnMsIGNvbmZpZy5kZWZhdWx0VmFyaWFudHMpKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBjb21wb3VuZENsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfTtcbiAgcnVudGltZUZuLnZhcmlhbnRzID0gKCkgPT4gT2JqZWN0LmtleXMoY29uZmlnLnZhcmlhbnRDbGFzc05hbWVzKTtcbiAgcnVudGltZUZuLmNsYXNzTmFtZXMgPSB7XG4gICAgZ2V0IGJhc2UoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmRlZmF1bHRDbGFzc05hbWUuc3BsaXQoJyAnKVswXTtcbiAgICB9LFxuICAgIGdldCB2YXJpYW50cygpIHtcbiAgICAgIHJldHVybiBtYXBWYWx1ZXMoY29uZmlnLnZhcmlhbnRDbGFzc05hbWVzLCBjbGFzc05hbWVzID0+IG1hcFZhbHVlcyhjbGFzc05hbWVzLCBjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnNwbGl0KCcgJylbMF0pKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBydW50aW1lRm47XG59O1xuXG5leHBvcnQgeyBjcmVhdGVSdW50aW1lRm4gYXMgYywgbWFwVmFsdWVzIGFzIG0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache)\n/* harmony export */ });\n/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nclass LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQXlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOFVBQThVO0FBQzlWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCLElBQUk7QUFDbkQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCLElBQUk7QUFDcEQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUF1QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtHQUErRztBQUMvSCxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0EsNEJBQTRCO0FBQzVCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVJBQWlSO0FBQ2pSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLDRIQUE0SDtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXJvdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9lc20vaW5kZXguanM/NzY3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgTFJVQ2FjaGVcbiAqL1xuY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICBwZXJmb3JtYW5jZSAmJlxuICAgIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbidcbiAgICA/IHBlcmZvcm1hbmNlXG4gICAgOiBEYXRlO1xuY29uc3Qgd2FybmVkID0gbmV3IFNldCgpO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBQUk9DRVNTID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiAhIXByb2Nlc3MgPyBwcm9jZXNzIDoge30pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBlbWl0V2FybmluZyA9IChtc2csIHR5cGUsIGNvZGUsIGZuKSA9PiB7XG4gICAgdHlwZW9mIFBST0NFU1MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBQUk9DRVNTLmVtaXRXYXJuaW5nKG1zZywgdHlwZSwgY29kZSwgZm4pXG4gICAgICAgIDogY29uc29sZS5lcnJvcihgWyR7Y29kZX1dICR7dHlwZX06ICR7bXNnfWApO1xufTtcbmxldCBBQyA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyO1xubGV0IEFTID0gZ2xvYmFsVGhpcy5BYm9ydFNpZ25hbDtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHR5cGVvZiBBQyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBBUyA9IGNsYXNzIEFib3J0U2lnbmFsIHtcbiAgICAgICAgb25hYm9ydDtcbiAgICAgICAgX29uYWJvcnQgPSBbXTtcbiAgICAgICAgcmVhc29uO1xuICAgICAgICBhYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXywgZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX29uYWJvcnQucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFDID0gY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB3YXJuQUNQb2x5ZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCA9IG5ldyBBUygpO1xuICAgICAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5zaWduYWwucmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLnNpZ25hbC5fb25hYm9ydCkge1xuICAgICAgICAgICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5vbmFib3J0Py4ocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHByaW50QUNQb2x5ZmlsbFdhcm5pbmcgPSBQUk9DRVNTLmVudj8uTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HICE9PSAnMSc7XG4gICAgY29uc3Qgd2FybkFDUG9seWZpbGwgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcHJpbnRBQ1BvbHlmaWxsV2FybmluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IGZhbHNlO1xuICAgICAgICBlbWl0V2FybmluZygnQWJvcnRDb250cm9sbGVyIGlzIG5vdCBkZWZpbmVkLiBJZiB1c2luZyBscnUtY2FjaGUgaW4gJyArXG4gICAgICAgICAgICAnbm9kZSAxNCwgbG9hZCBhbiBBYm9ydENvbnRyb2xsZXIgcG9seWZpbGwgZnJvbSB0aGUgJyArXG4gICAgICAgICAgICAnYG5vZGUtYWJvcnQtY29udHJvbGxlcmAgcGFja2FnZS4gQSBtaW5pbWFsIHBvbHlmaWxsIGlzICcgK1xuICAgICAgICAgICAgJ3Byb3ZpZGVkIGZvciB1c2UgYnkgTFJVQ2FjaGUuZmV0Y2goKSwgYnV0IGl0IHNob3VsZCBub3QgYmUgJyArXG4gICAgICAgICAgICAncmVsaWVkIHVwb24gaW4gb3RoZXIgY29udGV4dHMgKGVnLCBwYXNzaW5nIGl0IHRvIG90aGVyIEFQSXMgdGhhdCAnICtcbiAgICAgICAgICAgICd1c2UgQWJvcnRDb250cm9sbGVyL0Fib3J0U2lnbmFsIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cykuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgZGlzYWJsZSB0aGlzIHdpdGggTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HPTEgaW4gdGhlIGVudi4nLCAnTk9fQUJPUlRfQ09OVFJPTExFUicsICdFTk9UU1VQJywgd2FybkFDUG9seWZpbGwpO1xuICAgIH07XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY29uc3Qgc2hvdWxkV2FybiA9IChjb2RlKSA9PiAhd2FybmVkLmhhcyhjb2RlKTtcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKTtcbmNvbnN0IGlzUG9zSW50ID0gKG4pID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLy8gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuLy8gVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuLy8gQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbi8vIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4vLyBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbi8vIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbi8vIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuLy8gTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC5cbmNvbnN0IGdldFVpbnRBcnJheSA9IChtYXgpID0+ICFpc1Bvc0ludChtYXgpXG4gICAgPyBudWxsXG4gICAgOiBtYXggPD0gTWF0aC5wb3coMiwgOClcbiAgICAgICAgPyBVaW50OEFycmF5XG4gICAgICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDE2KVxuICAgICAgICAgICAgPyBVaW50MTZBcnJheVxuICAgICAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMzIpXG4gICAgICAgICAgICAgICAgPyBVaW50MzJBcnJheVxuICAgICAgICAgICAgICAgIDogbWF4IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICAgID8gWmVyb0FycmF5XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jbGFzcyBaZXJvQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcihzaXplKTtcbiAgICAgICAgdGhpcy5maWxsKDApO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrIHtcbiAgICBoZWFwO1xuICAgIGxlbmd0aDtcbiAgICAvLyBwcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgc3RhdGljICNjb25zdHJ1Y3RpbmcgPSBmYWxzZTtcbiAgICBzdGF0aWMgY3JlYXRlKG1heCkge1xuICAgICAgICBjb25zdCBIZWFwQ2xzID0gZ2V0VWludEFycmF5KG1heCk7XG4gICAgICAgIGlmICghSGVhcENscylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgU3RhY2suI2NvbnN0cnVjdGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgU3RhY2sobWF4LCBIZWFwQ2xzKTtcbiAgICAgICAgU3RhY2suI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWF4LCBIZWFwQ2xzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIVN0YWNrLiNjb25zdHJ1Y3RpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc3RhbnRpYXRlIFN0YWNrIHVzaW5nIFN0YWNrLmNyZWF0ZShuKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMuaGVhcCA9IG5ldyBIZWFwQ2xzKG1heCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcHVzaChuKSB7XG4gICAgICAgIHRoaXMuaGVhcFt0aGlzLmxlbmd0aCsrXSA9IG47XG4gICAgfVxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcFstLXRoaXMubGVuZ3RoXTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0LCB0aGUgdGhpbmcgeW91J3JlIHVzaW5nIHRoaXMgbW9kdWxlIHRvIGdldC5cbiAqXG4gKiBUaGUgYEtgIGFuZCBgVmAgdHlwZXMgZGVmaW5lIHRoZSBrZXkgYW5kIHZhbHVlIHR5cGVzLCByZXNwZWN0aXZlbHkuIFRoZVxuICogb3B0aW9uYWwgYEZDYCB0eXBlIGRlZmluZXMgdGhlIHR5cGUgb2YgdGhlIGBjb250ZXh0YCBvYmplY3QgcGFzc2VkIHRvXG4gKiBgY2FjaGUuZmV0Y2goKWAgYW5kIGBjYWNoZS5tZW1vKClgLlxuICpcbiAqIEtleXMgYW5kIHZhbHVlcyAqKm11c3Qgbm90KiogYmUgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0ICh3aXRoIHRoZSBleGNlcHRpb24gb2YgYG1heGAsXG4gKiBgbWF4U2l6ZWAsIGBmZXRjaE1ldGhvZGAsIGBtZW1vTWV0aG9kYCwgYGRpc3Bvc2VgIGFuZCBgZGlzcG9zZUFmdGVyYCkgYXJlXG4gKiBhZGRlZCBhcyBub3JtYWwgcHVibGljIG1lbWJlcnMuIChUaGUgbGlzdGVkIG9wdGlvbnMgYXJlIHJlYWQtb25seSBnZXR0ZXJzLilcbiAqXG4gKiBDaGFuZ2luZyBhbnkgb2YgdGhlc2Ugd2lsbCBhbHRlciB0aGUgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgbWV0aG9kIGNhbGxzLlxuICovXG5leHBvcnQgY2xhc3MgTFJVQ2FjaGUge1xuICAgIC8vIG9wdGlvbnMgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCB3aXRob3V0IGRpc2FzdGVyXG4gICAgI21heDtcbiAgICAjbWF4U2l6ZTtcbiAgICAjZGlzcG9zZTtcbiAgICAjZGlzcG9zZUFmdGVyO1xuICAgICNmZXRjaE1ldGhvZDtcbiAgICAjbWVtb01ldGhvZDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsfVxuICAgICAqL1xuICAgIHR0bDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsUmVzb2x1dGlvbn1cbiAgICAgKi9cbiAgICB0dGxSZXNvbHV0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxBdXRvcHVyZ2V9XG4gICAgICovXG4gICAgdHRsQXV0b3B1cmdlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkdldH1cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25IYXM7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EaXNwb3NlT25TZXR9XG4gICAgICovXG4gICAgbm9EaXNwb3NlT25TZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vVXBkYXRlVFRMfVxuICAgICAqL1xuICAgIG5vVXBkYXRlVFRMO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhFbnRyeVNpemV9XG4gICAgICovXG4gICAgbWF4RW50cnlTaXplO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5zaXplQ2FsY3VsYXRpb259XG4gICAgICovXG4gICAgc2l6ZUNhbGN1bGF0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uU3RhbGVHZXR9XG4gICAgICovXG4gICAgbm9EZWxldGVPblN0YWxlR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5pZ25vcmVGZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGlnbm9yZUZldGNoQWJvcnQ7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICNzaXplO1xuICAgICNjYWxjdWxhdGVkU2l6ZTtcbiAgICAja2V5TWFwO1xuICAgICNrZXlMaXN0O1xuICAgICN2YWxMaXN0O1xuICAgICNuZXh0O1xuICAgICNwcmV2O1xuICAgICNoZWFkO1xuICAgICN0YWlsO1xuICAgICNmcmVlO1xuICAgICNkaXNwb3NlZDtcbiAgICAjc2l6ZXM7XG4gICAgI3N0YXJ0cztcbiAgICAjdHRscztcbiAgICAjaGFzRGlzcG9zZTtcbiAgICAjaGFzRmV0Y2hNZXRob2Q7XG4gICAgI2hhc0Rpc3Bvc2VBZnRlcjtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCB1bmxlc3MgeW91IG5lZWQgdG8gaW5zcGVjdCB0aGVcbiAgICAgKiBpbm5lciB3b3JraW5ncyBvZiB0aGUgY2FjaGUuICBJZiBhbnl0aGluZyByZXR1cm5lZCBieSB0aGlzXG4gICAgICogb2JqZWN0IGlzIG1vZGlmaWVkIGluIGFueSB3YXksIHN0cmFuZ2UgYnJlYWthZ2UgbWF5IG9jY3VyLlxuICAgICAqXG4gICAgICogVGhlc2UgZmllbGRzIGFyZSBwcml2YXRlIGZvciBhIHJlYXNvbiFcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICAgICAgc3RhcnRzOiBjLiNzdGFydHMsXG4gICAgICAgICAgICB0dGxzOiBjLiN0dGxzLFxuICAgICAgICAgICAgc2l6ZXM6IGMuI3NpemVzLFxuICAgICAgICAgICAga2V5TWFwOiBjLiNrZXlNYXAsXG4gICAgICAgICAgICBrZXlMaXN0OiBjLiNrZXlMaXN0LFxuICAgICAgICAgICAgdmFsTGlzdDogYy4jdmFsTGlzdCxcbiAgICAgICAgICAgIG5leHQ6IGMuI25leHQsXG4gICAgICAgICAgICBwcmV2OiBjLiNwcmV2LFxuICAgICAgICAgICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI2hlYWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI3RhaWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJlZTogYy4jZnJlZSxcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZEZldGNoOiAocCkgPT4gYy4jaXNCYWNrZ3JvdW5kRmV0Y2gocCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmV0Y2g6IChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkgPT4gYy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSxcbiAgICAgICAgICAgIG1vdmVUb1RhaWw6IChpbmRleCkgPT4gYy4jbW92ZVRvVGFpbChpbmRleCksXG4gICAgICAgICAgICBpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIHJpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jcmluZGV4ZXMob3B0aW9ucyksXG4gICAgICAgICAgICBpc1N0YWxlOiAoaW5kZXgpID0+IGMuI2lzU3RhbGUoaW5kZXgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm90ZWN0ZWQgcmVhZC1vbmx5IG1lbWJlcnNcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4fSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhTaXplfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXhTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWF4U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvbXB1dGVkIHNpemUgb2YgaXRlbXMgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGNhbGN1bGF0ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluIHRoZSBjYWNoZSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmZldGNoTWV0aG9kfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBmZXRjaE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoTWV0aG9kO1xuICAgIH1cbiAgICBnZXQgbWVtb01ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21lbW9NZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmRpc3Bvc2VBZnRlcn0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZUFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4ID0gMCwgdHRsLCB0dGxSZXNvbHV0aW9uID0gMSwgdHRsQXV0b3B1cmdlLCB1cGRhdGVBZ2VPbkdldCwgdXBkYXRlQWdlT25IYXMsIGFsbG93U3RhbGUsIGRpc3Bvc2UsIGRpc3Bvc2VBZnRlciwgbm9EaXNwb3NlT25TZXQsIG5vVXBkYXRlVFRMLCBtYXhTaXplID0gMCwgbWF4RW50cnlTaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uLCBmZXRjaE1ldGhvZCwgbWVtb01ldGhvZCwgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBub0RlbGV0ZU9uU3RhbGVHZXQsIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaEFib3J0LCBpZ25vcmVGZXRjaEFib3J0LCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXk7XG4gICAgICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtYXggPSBtYXg7XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLm1heEVudHJ5U2l6ZSA9IG1heEVudHJ5U2l6ZSB8fCB0aGlzLiNtYXhTaXplO1xuICAgICAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI21heFNpemUgJiYgIXRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtb01ldGhvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbWVtb01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVtb01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21lbW9NZXRob2QgPSBtZW1vTWV0aG9kO1xuICAgICAgICBpZiAoZmV0Y2hNZXRob2QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4jaGFzRmV0Y2hNZXRob2QgPSAhIWZldGNoTWV0aG9kO1xuICAgICAgICB0aGlzLiNrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI25leHQgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI3ByZXYgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZSA9IFN0YWNrLmNyZWF0ZShtYXgpO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2UgPSBkaXNwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZUFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXI7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZSA9ICEhdGhpcy4jZGlzcG9zZTtcbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZUFmdGVyID0gISF0aGlzLiNkaXNwb3NlQWZ0ZXI7XG4gICAgICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0O1xuICAgICAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTDtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIW5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgdGhpcy5pZ25vcmVGZXRjaEFib3J0ID0gISFpZ25vcmVGZXRjaEFib3J0O1xuICAgICAgICAvLyBOQjogbWF4RW50cnlTaXplIGlzIHNldCB0byBtYXhTaXplIGlmIGl0J3Mgc2V0XG4gICAgICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMuI21heFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heEVudHJ5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlID0gISFhbGxvd1N0YWxlO1xuICAgICAgICB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCA9ICEhbm9EZWxldGVPblN0YWxlR2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFnZU9uR2V0ID0gISF1cGRhdGVBZ2VPbkdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXM7XG4gICAgICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9XG4gICAgICAgICAgICBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyB0dGxSZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlO1xuICAgICAgICB0aGlzLnR0bCA9IHR0bCB8fCAwO1xuICAgICAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHRsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90IGFsbG93IGNvbXBsZXRlbHkgdW5ib3VuZGVkIGNhY2hlc1xuICAgICAgICBpZiAodGhpcy4jbWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMuI21heFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMuI21heCAmJiAhdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJztcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybmVkLmFkZChjb2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXN1bHQgaW4gdW5ib3VuZGVkIG1lbW9yeSBjb25zdW1wdGlvbi4nO1xuICAgICAgICAgICAgICAgIGVtaXRXYXJuaW5nKG1zZywgJ1VuYm91bmRlZENhY2hlV2FybmluZycsIGNvZGUsIExSVUNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBtcyBsZWZ0IGluIHRoZSBpdGVtJ3MgVFRMLiBJZiBpdGVtIGlzIG5vdCBpbiBjYWNoZSxcbiAgICAgKiByZXR1cm5zIGAwYC4gUmV0dXJucyBgSW5maW5pdHlgIGlmIGl0ZW0gaXMgaW4gY2FjaGUgd2l0aG91dCBhIGRlZmluZWQgVFRMLlxuICAgICAqL1xuICAgIGdldFJlbWFpbmluZ1RUTChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2tleU1hcC5oYXMoa2V5KSA/IEluZmluaXR5IDogMDtcbiAgICB9XG4gICAgI2luaXRpYWxpemVUVExUcmFja2luZygpIHtcbiAgICAgICAgY29uc3QgdHRscyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgY29uc3Qgc3RhcnRzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICB0aGlzLiN0dGxzID0gdHRscztcbiAgICAgICAgdGhpcy4jc3RhcnRzID0gc3RhcnRzO1xuICAgICAgICB0aGlzLiNzZXRJdGVtVFRMID0gKGluZGV4LCB0dGwsIHN0YXJ0ID0gcGVyZi5ub3coKSkgPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bCAhPT0gMCA/IHN0YXJ0IDogMDtcbiAgICAgICAgICAgIHR0bHNbaW5kZXhdID0gdHRsO1xuICAgICAgICAgICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bEF1dG9wdXJnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUodGhpcy4ja2V5TGlzdFtpbmRleF0sICdleHBpcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHR0bCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bHNbaW5kZXhdICE9PSAwID8gcGVyZi5ub3coKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3N0YXR1c1RUTCA9IChzdGF0dXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHRsc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXR0bCB8fCAhc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0dXMudHRsID0gdHRsO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXR1cy5ub3cgPSBjYWNoZWROb3cgfHwgZ2V0Tm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gc3RhdHVzLm5vdyAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXR1cy5yZW1haW5pbmdUVEwgPSB0dGwgLSBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAgICAgLy8gdGhhdCBjb3N0bHkgY2FsbCByZXBlYXRlZGx5LlxuICAgICAgICBsZXQgY2FjaGVkTm93ID0gMDtcbiAgICAgICAgY29uc3QgZ2V0Tm93ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBlcmYubm93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE5vdyA9IG47XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4gKGNhY2hlZE5vdyA9IDApLCB0aGlzLnR0bFJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghdHRsIHx8ICFzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFnZSA9IChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gdHRsIC0gYWdlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNpc1N0YWxlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgY29uc3QgcyA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0ID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gISF0ICYmICEhcyAmJiAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHMgPiB0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBjb25kaXRpb25hbGx5IHNldCBwcml2YXRlIG1ldGhvZHMgcmVsYXRlZCB0byBUVExcbiAgICAjdXBkYXRlSXRlbUFnZSA9ICgpID0+IHsgfTtcbiAgICAjc3RhdHVzVFRMID0gKCkgPT4geyB9O1xuICAgICNzZXRJdGVtVFRMID0gKCkgPT4geyB9O1xuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgI2lzU3RhbGUgPSAoKSA9PiBmYWxzZTtcbiAgICAjaW5pdGlhbGl6ZVNpemVUcmFja2luZygpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy4jc2l6ZXMgPSBzaXplcztcbiAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSAtPSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICBzaXplc1tpbmRleF0gPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNyZXF1aXJlU2l6ZSA9IChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsbHkgYWNjZXB0IGJhY2tncm91bmQgZmV0Y2hlcy5cbiAgICAgICAgICAgIC8vIGFjdHVhbCB2YWx1ZSBzaXplIHdpbGwgYmUgY2hlY2tlZCB3aGVuIHRoZXkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzaXplQ2FsY3VsYXRpb24odiwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiByZXR1cm4gaW52YWxpZCAoZXhwZWN0IHBvc2l0aXZlIGludGVnZXIpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2hlbiBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBpcyB1c2VkLCBzaXplQ2FsY3VsYXRpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Igc2l6ZSBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUgPSAoaW5kZXgsIHNpemUsIHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgc2l6ZXNbaW5kZXhdID0gc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMuI21heFNpemUgLSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuI2NhbGN1bGF0ZWRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNldmljdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSArPSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmVudHJ5U2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnRvdGFsQ2FsY3VsYXRlZFNpemUgPSB0aGlzLiNjYWxjdWxhdGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgI3JlbW92ZUl0ZW1TaXplID0gX2kgPT4geyB9O1xuICAgICNhZGRJdGVtU2l6ZSA9IChfaSwgX3MsIF9zdCkgPT4geyB9O1xuICAgICNyZXF1aXJlU2l6ZSA9IChfaywgX3YsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgICBpZiAoc2l6ZSB8fCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgb24gY2FjaGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgICojaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jdGFpbDsgdHJ1ZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuI2hlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4jcHJldltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKiNyaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jaGVhZDsgdHJ1ZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4jbmV4dFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2lzVmFsaWRJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5nZXQodGhpcy4ja2V5TGlzdFtpbmRleF0pID09PSBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyBgW2tleSwgdmFsdWVdYCBwYWlycyxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICplbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RoaXMuI2tleUxpc3RbaV0sIHRoaXMuI3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUuZW50cmllc31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyBgW2tleSwgdmFsdWVdYCBwYWlycyxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpyZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGhpcy4ja2V5TGlzdFtpXSwgdGhpcy4jdmFsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBrZXlzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICprZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUua2V5c31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUga2V5cyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS52YWx1ZXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0aW5nIG92ZXIgdGhlIGNhY2hlIGl0c2VsZiB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0cyBhc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5lbnRyaWVzfVxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgU3RyaW5nIHZhbHVlIHRoYXQgaXMgdXNlZCBpbiB0aGUgY3JlYXRpb24gb2YgdGhlIGRlZmF1bHQgc3RyaW5nXG4gICAgICogZGVzY3JpcHRpb24gb2YgYW4gb2JqZWN0LiBDYWxsZWQgYnkgdGhlIGJ1aWx0LWluIG1ldGhvZFxuICAgICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdMUlVDYWNoZSc7XG4gICAgLyoqXG4gICAgICogRmluZCBhIHZhbHVlIGZvciB3aGljaCB0aGUgc3VwcGxpZWQgZm4gbWV0aG9kIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsXG4gICAgICogc2ltaWxhciB0byBgQXJyYXkuZmluZCgpYC4gZm4gaXMgY2FsbGVkIGFzIGBmbih2YWx1ZSwga2V5LCBjYWNoZSlgLlxuICAgICAqL1xuICAgIGZpbmQoZm4sIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmbih2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy4ja2V5TGlzdFtpXSwgZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBjYWNoZSwgaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICogcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqXG4gICAgICogYGZuYCBpcyBjYWxsZWQgYXMgYGZuKHZhbHVlLCBrZXksIGNhY2hlKWAuXG4gICAgICpcbiAgICAgKiBJZiBgdGhpc3BgIGlzIHByb3ZpZGVkLCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYHRoaXNgLWNvbnRleHQgb2ZcbiAgICAgKiB0aGUgcHJvdmlkZWQgb2JqZWN0LCBvciB0aGUgY2FjaGUgaWYgbm8gYHRoaXNwYCBvYmplY3QgaXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgYWdlIG9yIHJlY2VudHkgb2YgdXNlLCBvciBpdGVyYXRlIG92ZXIgc3RhbGUgdmFsdWVzLlxuICAgICAqL1xuICAgIGZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyB7QGxpbmsgTFJVQ2FjaGUuZm9yRWFjaH0gYnV0IGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGluXG4gICAgICogcmV2ZXJzZSBvcmRlci4gIChpZSwgbGVzcyByZWNlbnRseSB1c2VkIGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGZpcnN0LilcbiAgICAgKi9cbiAgICByZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW55IHN0YWxlIGVudHJpZXMuIFJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyB3YXMgcmVtb3ZlZCxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVyZ2VTdGFsZSgpIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUodGhpcy4ja2V5TGlzdFtpXSwgJ2V4cGlyZScpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV4dGVuZGVkIGluZm8gYWJvdXQgYSBnaXZlbiBlbnRyeSwgdG8gZ2V0IGl0cyB2YWx1ZSwgc2l6ZSwgYW5kXG4gICAgICogVFRMIGluZm8gc2ltdWx0YW5lb3VzbHkuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGtleSBpcyBub3QgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIFVubGlrZSB7QGxpbmsgTFJVQ2FjaGUjZHVtcH0sIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGJlIHBvcnRhYmxlIGFuZCBzdXJ2aXZlXG4gICAgICogc2VyaWFsaXphdGlvbiwgdGhlIGBzdGFydGAgdmFsdWUgaXMgYWx3YXlzIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgYW5kIHRoZVxuICAgICAqIGB0dGxgIGlzIGEgY2FsY3VsYXRlZCByZW1haW5pbmcgdGltZSB0byBsaXZlIChuZWdhdGl2ZSBpZiBleHBpcmVkKS5cbiAgICAgKlxuICAgICAqIEFsd2F5cyByZXR1cm5zIHN0YWxlIHZhbHVlcywgaWYgdGhlaXIgaW5mbyBpcyBmb3VuZCBpbiB0aGUgY2FjaGUsIHNvIGJlXG4gICAgICogc3VyZSB0byBjaGVjayBmb3IgZXhwaXJhdGlvbnMgKGllLCBhIG5lZ2F0aXZlIHtAbGluayBMUlVDYWNoZS5FbnRyeSN0dGx9KVxuICAgICAqIGlmIHJlbGV2YW50LlxuICAgICAqL1xuICAgIGluZm8oa2V5KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLiNrZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICA6IHY7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgY29uc3QgdHRsID0gdGhpcy4jdHRsc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4jc3RhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHR0bCAmJiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbiA9IHR0bCAtIChwZXJmLm5vdygpIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGVudHJ5LnR0bCA9IHJlbWFpbjtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICBlbnRyeS5zaXplID0gdGhpcy4jc2l6ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgW2tleSwge0BsaW5rIExSVUNhY2hlLkVudHJ5fV0gdHVwbGVzIHdoaWNoIGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byB7QGxpbmsgTFJMVUNhY2hlI2xvYWR9LlxuICAgICAqXG4gICAgICogVGhlIGBzdGFydGAgZmllbGRzIGFyZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGEgcG9ydGFibGUgYERhdGUubm93KClgXG4gICAgICogdGltZXN0YW1wLCBldmVuIGlmIGBwZXJmb3JtYW5jZS5ub3coKWAgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogU3RhbGUgZW50cmllcyBhcmUgYWx3YXlzIGluY2x1ZGVkIGluIHRoZSBgZHVtcGAsIGV2ZW4gaWZcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX0gaXMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIHJldHVybnMgYW4gYWN0dWFsIGFycmF5LCBub3QgYSBnZW5lcmF0b3IsIHNvIGl0IGNhbiBiZSBtb3JlXG4gICAgICogZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgICovXG4gICAgZHVtcCgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS50dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBkdW1wIHRoZSBzdGFydCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHBlcmYubm93KCkgLSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLSBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuI3NpemVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FjaGUgYW5kIGxvYWQgaW4gdGhlIGl0ZW1zIGluIGVudHJpZXMgaW4gdGhlIG9yZGVyIGxpc3RlZC5cbiAgICAgKlxuICAgICAqIFRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGNhY2hlIG1heSBiZSBkaWZmZXJlbnQgaWYgdGhlIHNhbWUgb3B0aW9ucyBhcmVcbiAgICAgKiBub3QgdXNlZCBpbiBib3RoIGNhY2hlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgc3RhcnRgIGZpZWxkcyBhcmUgYXNzdW1lZCB0byBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGEgcG9ydGFibGVcbiAgICAgKiBgRGF0ZS5ub3coKWAgdGltZXN0YW1wLCBldmVuIGlmIGBwZXJmb3JtYW5jZS5ub3coKWAgaXMgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGxvYWQoYXJyKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnRyeS5zdGFydCBpcyBhIHBvcnRhYmxlIHRpbWVzdGFtcCwgYnV0IHdlIG1heSBiZSB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBwZXJmb3JtYW5jZS5ub3coKSwgc28gY2FsY3VsYXRlIHRoZSBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgdGhlIGludGVuZGVkIHJlbWFpbmluZyBUVEwsIG5vIG1hdHRlciBob3cgbG9uZyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBvbiBpY2UuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gZW50cnkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBwZXJmLm5vdygpIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIGB1bmRlZmluZWRgIGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlLCB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIHtAbGluayBMUlVDYWNoZSNkZWxldGV9XG4gICAgICpcbiAgICAgKiBGaWVsZHMgb24gdGhlIHtAbGluayBMUlVDYWNoZS5TZXRPcHRpb25zfSBvcHRpb25zIHBhcmFtIHdpbGwgb3ZlcnJpZGVcbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlcyBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBmb3IgdGhlIHNjb3BlXG4gICAgICogb2YgdGhpcyBzaW5nbGUgYHNldCgpYCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgc3RhcnRgIGlzIHByb3ZpZGVkLCB0aGVuIHRoYXQgd2lsbCBzZXQgdGhlIGVmZmVjdGl2ZSBzdGFydFxuICAgICAqIHRpbWUgZm9yIHRoZSBUVEwgY2FsY3VsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG11c3QgYmUgYSBwcmV2aW91c1xuICAgICAqIHZhbHVlIG9mIGBwZXJmb3JtYW5jZS5ub3coKWAgaWYgc3VwcG9ydGVkLCBvciBhIHByZXZpb3VzIHZhbHVlIG9mXG4gICAgICogYERhdGUubm93KClgIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIE9wdGlvbnMgb2JqZWN0IG1heSBhbHNvIGluY2x1ZGUgYHNpemVgLCB3aGljaCB3aWxsIHByZXZlbnRcbiAgICAgKiBjYWxsaW5nIHRoZSBgc2l6ZUNhbGN1bGF0aW9uYCBmdW5jdGlvbiBhbmQganVzdCB1c2UgdGhlIHNwZWNpZmllZFxuICAgICAqIG51bWJlciBpZiBpdCBpcyBhIHBvc2l0aXZlIGludGVnZXIsIGFuZCBgbm9EaXNwb3NlT25TZXRgIHdoaWNoXG4gICAgICogd2lsbCBwcmV2ZW50IGNhbGxpbmcgYSBgZGlzcG9zZWAgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiBvdmVyd3JpdGVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGBzaXplYCAob3IgcmV0dXJuIHZhbHVlIG9mIGBzaXplQ2FsY3VsYXRpb25gKSBmb3IgYSBnaXZlblxuICAgICAqIGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiBgbWF4RW50cnlTaXplYCwgdGhlbiB0aGUgaXRlbSB3aWxsIG5vdCBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBlbnRyeS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlbiB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIGBjYWNoZS5kZWxldGUoa2V5KWAuIGB1bmRlZmluZWRgIGlzIG5ldmVyIHN0b3JlZCBpbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgc2V0KGssIHYsIHNldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHRsID0gdGhpcy50dGwsIHN0YXJ0LCBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBzdGF0dXMsIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBsZXQgeyBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLiNyZXF1aXJlU2l6ZShrLCB2LCBzZXRPcHRpb25zLnNpemUgfHwgMCwgc2l6ZUNhbGN1bGF0aW9uKTtcbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gZG9lc24ndCBmaXQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIE5COiBtYXhFbnRyeVNpemUgc2V0IHRvIG1heFNpemUgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgJiYgc2l6ZSA+IHRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdtaXNzJztcbiAgICAgICAgICAgICAgICBzdGF0dXMubWF4RW50cnlTaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBkZWxldGUsIGluIGNhc2Ugc29tZXRoaW5nIGlzIHRoZXJlIGFscmVhZHkuXG4gICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ3NldCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4jc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvblxuICAgICAgICAgICAgaW5kZXggPSAodGhpcy4jc2l6ZSA9PT0gMFxuICAgICAgICAgICAgICAgID8gdGhpcy4jdGFpbFxuICAgICAgICAgICAgICAgIDogdGhpcy4jZnJlZS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiNmcmVlLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4jc2l6ZSA9PT0gdGhpcy4jbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2V2aWN0KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplKTtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaW5kZXhdID0gaztcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5zZXQoaywgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jbmV4dFt0aGlzLiN0YWlsXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jcHJldltpbmRleF0gPSB0aGlzLiN0YWlsO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jc2l6ZSsrO1xuICAgICAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnYWRkJztcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodiAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcigncmVwbGFjZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IHMgfSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09IHVuZGVmaW5lZCAmJiAhbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHMsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbcywgaywgJ3NldCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/LihvbGRWYWwsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbb2xkVmFsLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3JlcGxhY2UnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZFZhbCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9sZFZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwgIT09IDAgJiYgIXRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0SXRlbVRUTChpbmRleCwgdHRsLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0ICYmIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW0sIHJldHVybmluZyBpdHMgdmFsdWUgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiBjYWNoZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuI3ZhbExpc3RbdGhpcy4jaGVhZF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2V2aWN0KGZyZWUpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuI2hlYWQ7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2hlYWRdO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtoZWFkXTtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZXZpY3RlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2V2aWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdldmljdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShoZWFkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICAgICAgaWYgKGZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtoZWFkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2YgdXNlLlxuICAgICAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseVxuICAgICAqIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGluIHRoZSBjYWNoZSwgd2l0aG91dCB1cGRhdGluZyB0aGUgcmVjZW5jeSBvZlxuICAgICAqIHVzZS4gQWdlIGlzIHVwZGF0ZWQgaWYge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXRcbiAgICAgKiB0byBgdHJ1ZWAgaW4gZWl0aGVyIHRoZSBvcHRpb25zIG9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIFdpbGwgcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIGV2ZW4gdGhvdWdoIGl0IGlzIHRlY2huaWNhbGx5IGluXG4gICAgICogdGhlIGNhY2hlLiBUaGUgZGlmZmVyZW5jZSBjYW4gYmUgZGV0ZXJtaW5lZCAoaWYgaXQgbWF0dGVycykgYnkgdXNpbmcgYVxuICAgICAqIGBzdGF0dXNgIGFyZ3VtZW50LCBhbmQgaW5zcGVjdGluZyB0aGUgYGhhc2AgZmllbGQuXG4gICAgICpcbiAgICAgKiBXaWxsIG5vdCB1cGRhdGUgaXRlbSBhZ2UgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXQuXG4gICAgICovXG4gICAgaGFzKGssIGhhc09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHVwZGF0ZUFnZU9uSGFzID0gdGhpcy51cGRhdGVBZ2VPbkhhcywgc3RhdHVzIH0gPSBoYXNPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgJiZcbiAgICAgICAgICAgICAgICB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUFnZU9uSGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIHtAbGluayBMUlVDYWNoZSNnZXR9IGJ1dCBkb2Vzbid0IHVwZGF0ZSByZWNlbmN5IG9yIGRlbGV0ZSBzdGFsZVxuICAgICAqIGl0ZW1zLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBzdGFsZSwgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9IGlzIHNldC5cbiAgICAgKi9cbiAgICBwZWVrKGssIHBlZWtPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSBwZWVrT3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKCFhbGxvd1N0YWxlICYmIHRoaXMuI2lzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgLy8gZWl0aGVyIHN0YWxlIGFuZCBhbGxvd2VkLCBvciBmb3JjaW5nIGEgcmVmcmVzaCBvZiBub24tc3RhbGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgfVxuICAgICNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYyA9IG5ldyBBQygpO1xuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gd2hlbi9pZiBvdXIgQUMgc2lnbmFscywgdGhlbiBzdG9wIGxpc3RlbmluZyB0byB0aGVpcnMuXG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYy5hYm9ydChzaWduYWwucmVhc29uKSwge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYiA9ICh2LCB1cGRhdGVDYWNoZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUFib3J0ID0gb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0ICYmIHYgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gYWMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUFib3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydElnbm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIWlnbm9yZUFib3J0ICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoYWMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgd2UgZGlkbid0IGFib3J0LCBhbmQgYXJlIHN0aWxsIGhlcmUsIG9yIHdlIGRpZCwgYW5kIGlnbm9yZWRcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdmZXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGViID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hGYWlsID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGVBYm9ydGVkID0gYWJvcnRlZCAmJiBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgICAgICBjb25zdCBhbGxvd1N0YWxlID0gYWxsb3dTdGFsZUFib3J0ZWQgfHwgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vRGVsZXRlID0gYWxsb3dTdGFsZSB8fCBvcHRpb25zLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFsbG93IHN0YWxlIG9uIGZldGNoIHJlamVjdGlvbnMsIHRoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGFsZSB2YWx1ZSBpcyBub3QgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSB3aGVuIHRoZSBmZXRjaCBmYWlscy5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWwgPSAhbm9EZWxldGUgfHwgYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnZmV0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsbG93U3RhbGVBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHJlcGxhY2UgdGhlICpwcm9taXNlKiB3aXRoIHRoZSBzdGFsZSB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgYXJlIGRvbmUgd2l0aCB0aGUgcHJvbWlzZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBpdCB1bnRvdWNoZWQgaWYgd2UncmUgc3RpbGwgd2FpdGluZyBmb3IgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvcnRlZCBiYWNrZ3JvdW5kIGZldGNoIHRoYXQgaGFzbid0IHlldCByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cyAmJiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZi5fX3JldHVybmVkID09PSBiZikge1xuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwY2FsbCA9IChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm1wID0gdGhpcy4jZmV0Y2hNZXRob2Q/LihrLCB2LCBmZXRjaE9wdHMpO1xuICAgICAgICAgICAgaWYgKGZtcCAmJiBmbXAgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZm1wLnRoZW4odiA9PiByZXModiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdiksIHJlaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZ25vcmVkLCB3ZSBnbyB1bnRpbCB3ZSBmaW5pc2gsIHJlZ2FyZGxlc3MuXG4gICAgICAgICAgICAvLyBkZWZlciBjaGVjayB1bnRpbCB3ZSBhcmUgYWN0dWFsbHkgYWJvcnRpbmcsXG4gICAgICAgICAgICAvLyBzbyBmZXRjaE1ldGhvZCBjYW4gb3ZlcnJpZGUuXG4gICAgICAgICAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IGV2ZW50dWFsbHkgcmVzb2x2ZXMsIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHYgPT4gY2IodiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKVxuICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hEaXNwYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHBjYWxsKS50aGVuKGNiLCBlYik7XG4gICAgICAgIGNvbnN0IGJmID0gT2JqZWN0LmFzc2lnbihwLCB7XG4gICAgICAgICAgICBfX2Fib3J0Q29udHJvbGxlcjogYWMsXG4gICAgICAgICAgICBfX3N0YWxlV2hpbGVGZXRjaGluZzogdixcbiAgICAgICAgICAgIF9fcmV0dXJuZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCwgZG9uJ3QgZXhwb3NlIHN0YXR1cy5cbiAgICAgICAgICAgIHRoaXMuc2V0KGssIGJmLCB7IC4uLmZldGNoT3B0cy5vcHRpb25zLCBzdGF0dXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAjaXNCYWNrZ3JvdW5kRmV0Y2gocCkge1xuICAgICAgICBpZiAoIXRoaXMuI2hhc0ZldGNoTWV0aG9kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBiID0gcDtcbiAgICAgICAgcmV0dXJuICghIWIgJiZcbiAgICAgICAgICAgIGIgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICBiLmhhc093blByb3BlcnR5KCdfX3N0YWxlV2hpbGVGZXRjaGluZycpICYmXG4gICAgICAgICAgICBiLl9fYWJvcnRDb250cm9sbGVyIGluc3RhbmNlb2YgQUMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaChrLCBmZXRjaE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAvLyBnZXQgb3B0aW9uc1xuICAgICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBcbiAgICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgICAgdHRsID0gdGhpcy50dGwsIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsIFxuICAgICAgICAvLyBmZXRjaCBleGNsdXNpdmUgb3B0aW9uc1xuICAgICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBpZ25vcmVGZXRjaEFib3J0ID0gdGhpcy5pZ25vcmVGZXRjaEFib3J0LCBhbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0LCBjb250ZXh0LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSwgc3RhdHVzLCBzaWduYWwsIH0gPSBmZXRjaE9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2dldCc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoaywge1xuICAgICAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGxvd1N0YWxlLFxuICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICAgICAgICBub1VwZGF0ZVRUTCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgICAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIGlnbm9yZUZldGNoQWJvcnQsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdtaXNzJztcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFsZSA9IGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2luZmxpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhbGUgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogKHYuX19yZXR1cm5lZCA9IHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZm9yY2UgYSByZWZyZXNoLCB0aGF0IG1lYW5zIGRvIE5PVCBzZXJ2ZSB0aGUgY2FjaGVkIHZhbHVlLFxuICAgICAgICAgICAgLy8gdW5sZXNzIHdlIGFyZSBhbHJlYWR5IGluIHRoZSBwcm9jZXNzIG9mIHJlZnJlc2hpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgaXNTdGFsZSA9IHRoaXMuI2lzU3RhbGUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgIWlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaGl0JztcbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9rLCBpdCBpcyBzdGFsZSBvciBhIGZvcmNlZCByZWZyZXNoLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmcuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3RhbGUgPSBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFsZVZhbCA9IGhhc1N0YWxlICYmIGFsbG93U3RhbGU7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gaXNTdGFsZSA/ICdzdGFsZScgOiAncmVmcmVzaCc7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlVmFsICYmIGlzU3RhbGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFsZVZhbCA/IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAocC5fX3JldHVybmVkID0gcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZm9yY2VGZXRjaChrLCBmZXRjaE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgdGhpcy5mZXRjaChrLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaCgpIHJldHVybmVkIHVuZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgbWVtbyhrLCBtZW1vT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1lbW9NZXRob2QgPSB0aGlzLiNtZW1vTWV0aG9kO1xuICAgICAgICBpZiAoIW1lbW9NZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWVtb01ldGhvZCBwcm92aWRlZCB0byBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgZm9yY2VSZWZyZXNoLCAuLi5vcHRpb25zIH0gPSBtZW1vT3B0aW9ucztcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0KGssIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiB2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY29uc3QgdnYgPSBtZW1vTWV0aG9kKGssIHYsIHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXQoaywgdnYsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZhbHVlIGZyb20gdGhlIGNhY2hlLiBXaWxsIHVwZGF0ZSB0aGUgcmVjZW5jeSBvZiB0aGUgY2FjaGVcbiAgICAgKiBlbnRyeSBmb3VuZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLCBnZXQoKSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBnZXQoaywgZ2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LCBub0RlbGV0ZU9uU3RhbGVHZXQgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCwgc3RhdHVzLCB9ID0gZ2V0T3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGZldGNoaW5nID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZ2V0ID0gJ3N0YWxlJztcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgb25seSBpZiBub3QgYW4gaW4tZmxpZ2h0IGJhY2tncm91bmQgZmV0Y2hcbiAgICAgICAgICAgICAgICBpZiAoIWZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9EZWxldGVPblN0YWxlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ2V4cGlyZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgYWxsb3dTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3RhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgZmV0Y2hpbmcgaXQsIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgaXQgeWV0XG4gICAgICAgICAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZy5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBzdGFsZSwgYW5kIGZldGNoaW5nLCBBTkQgaGFzIGEgX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSwgdGhlbiB0aGF0IG1lYW5zIHRoZSB1c2VyIGZldGNoZWQgd2l0aCB7Zm9yY2VSZWZyZXNoOnRydWV9LFxuICAgICAgICAgICAgICAgIC8vIHNvIGl0J3Mgc2FmZSB0byByZXR1cm4gdGhhdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2Nvbm5lY3QocCwgbikge1xuICAgICAgICB0aGlzLiNwcmV2W25dID0gcDtcbiAgICAgICAgdGhpcy4jbmV4dFtwXSA9IG47XG4gICAgfVxuICAgICNtb3ZlVG9UYWlsKGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgICAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgICAgICAvLyBwcmV2W2luZGV4XSA9IHRhaWxcbiAgICAgICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgICAgIC8vIHRhaWwgPSBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jcHJldltpbmRleF0sIHRoaXMuI25leHRbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jdGFpbCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBrZXkgb3V0IG9mIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHdhcyBkZWxldGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZGVsZXRlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2RlbGV0ZShrLCAnZGVsZXRlJyk7XG4gICAgfVxuICAgICNkZWxldGUoaywgcmVhc29uKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiNzaXplICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2NsZWFyKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgcmVhc29uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3RhaWwgPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGkgPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI25leHRbcGldID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuaSA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jcHJldltuaV0gPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2ZyZWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQ/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZSBlbnRpcmVseSwgdGhyb3dpbmcgYXdheSBhbGwgdmFsdWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2xlYXIoJ2RlbGV0ZScpO1xuICAgIH1cbiAgICAjY2xlYXIocmVhc29uKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy4jcmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgcmVhc29uXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2tleU1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy4ja2V5TGlzdC5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgdGhpcy4jdHRscy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy4jc3RhcnRzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICB0aGlzLiNzaXplcy5maWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemUgPSAwO1xuICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js\n");

/***/ })

};
;