"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vanilla-extract";
exports.ids = ["vendor-chunks/@vanilla-extract"];
exports.modules = {

/***/ "(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendCss: () => (/* binding */ appendCss),\n/* harmony export */   getIdentOption: () => (/* binding */ getIdentOption),\n/* harmony export */   markCompositionUsed: () => (/* binding */ markCompositionUsed),\n/* harmony export */   mockAdapter: () => (/* binding */ mockAdapter),\n/* harmony export */   onBeginFileScope: () => (/* binding */ onBeginFileScope),\n/* harmony export */   onEndFileScope: () => (/* binding */ onEndFileScope),\n/* harmony export */   registerClassName: () => (/* binding */ registerClassName),\n/* harmony export */   registerComposition: () => (/* binding */ registerComposition),\n/* harmony export */   removeAdapter: () => (/* binding */ removeAdapter),\n/* harmony export */   setAdapter: () => (/* binding */ setAdapter),\n/* harmony export */   setAdapterIfNotSet: () => (/* binding */ setAdapterIfNotSet)\n/* harmony export */ });\nvar mockAdapter = {\n  appendCss: () => {},\n  registerClassName: () => {},\n  onEndFileScope: () => {},\n  registerComposition: () => {},\n  markCompositionUsed: () => {},\n  getIdentOption: () =>  false ? 0 : 'debug'\n};\nvar adapterStack = [mockAdapter];\nvar currentAdapter = () => {\n  if (adapterStack.length < 1) {\n    throw new Error('No adapter configured');\n  }\n  return adapterStack[adapterStack.length - 1];\n};\nvar hasConfiguredAdapter = false;\nvar setAdapterIfNotSet = newAdapter => {\n  if (!hasConfiguredAdapter) {\n    setAdapter(newAdapter);\n  }\n};\nvar setAdapter = newAdapter => {\n  if (!newAdapter) {\n    throw new Error('No adapter provided when calling \"setAdapter\"');\n  }\n  hasConfiguredAdapter = true;\n  adapterStack.push(newAdapter);\n};\nvar removeAdapter = () => {\n  adapterStack.pop();\n};\nvar appendCss = function appendCss() {\n  return currentAdapter().appendCss(...arguments);\n};\nvar registerClassName = function registerClassName() {\n  return currentAdapter().registerClassName(...arguments);\n};\nvar registerComposition = function registerComposition() {\n  return currentAdapter().registerComposition(...arguments);\n};\nvar markCompositionUsed = function markCompositionUsed() {\n  return currentAdapter().markCompositionUsed(...arguments);\n};\nvar onBeginFileScope = function onBeginFileScope() {\n  var _currentAdapter$onBeg, _currentAdapter;\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  return (_currentAdapter$onBeg = (_currentAdapter = currentAdapter()).onBeginFileScope) === null || _currentAdapter$onBeg === void 0 ? void 0 : _currentAdapter$onBeg.call(_currentAdapter, ...props);\n};\nvar onEndFileScope = function onEndFileScope() {\n  return currentAdapter().onEndFileScope(...arguments);\n};\nvar getIdentOption = function getIdentOption() {\n  var adapter = currentAdapter();\n\n  // Backwards compatibility with old versions of the integration package\n  if (!('getIdentOption' in adapter)) {\n    return  false ? 0 : 'debug';\n  }\n  return adapter.getIdentOption(...arguments);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2FkYXB0ZXIvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLWFkYXB0ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHdCQUF3QixNQUFxQyxHQUFHLENBQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU87QUFDMUQ7QUFDQTtBQUNBOztBQUVnTSIsInNvdXJjZXMiOlsid2VicGFjazovL3prZGF0YXZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L2Nzcy9hZGFwdGVyL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1hZGFwdGVyLmVzbS5qcz9kMjFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtb2NrQWRhcHRlciA9IHtcbiAgYXBwZW5kQ3NzOiAoKSA9PiB7fSxcbiAgcmVnaXN0ZXJDbGFzc05hbWU6ICgpID0+IHt9LFxuICBvbkVuZEZpbGVTY29wZTogKCkgPT4ge30sXG4gIHJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHt9LFxuICBtYXJrQ29tcG9zaXRpb25Vc2VkOiAoKSA9PiB7fSxcbiAgZ2V0SWRlbnRPcHRpb246ICgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAnc2hvcnQnIDogJ2RlYnVnJ1xufTtcbnZhciBhZGFwdGVyU3RhY2sgPSBbbW9ja0FkYXB0ZXJdO1xudmFyIGN1cnJlbnRBZGFwdGVyID0gKCkgPT4ge1xuICBpZiAoYWRhcHRlclN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFkYXB0ZXIgY29uZmlndXJlZCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyU3RhY2tbYWRhcHRlclN0YWNrLmxlbmd0aCAtIDFdO1xufTtcbnZhciBoYXNDb25maWd1cmVkQWRhcHRlciA9IGZhbHNlO1xudmFyIHNldEFkYXB0ZXJJZk5vdFNldCA9IG5ld0FkYXB0ZXIgPT4ge1xuICBpZiAoIWhhc0NvbmZpZ3VyZWRBZGFwdGVyKSB7XG4gICAgc2V0QWRhcHRlcihuZXdBZGFwdGVyKTtcbiAgfVxufTtcbnZhciBzZXRBZGFwdGVyID0gbmV3QWRhcHRlciA9PiB7XG4gIGlmICghbmV3QWRhcHRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYWRhcHRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmcgXCJzZXRBZGFwdGVyXCInKTtcbiAgfVxuICBoYXNDb25maWd1cmVkQWRhcHRlciA9IHRydWU7XG4gIGFkYXB0ZXJTdGFjay5wdXNoKG5ld0FkYXB0ZXIpO1xufTtcbnZhciByZW1vdmVBZGFwdGVyID0gKCkgPT4ge1xuICBhZGFwdGVyU3RhY2sucG9wKCk7XG59O1xudmFyIGFwcGVuZENzcyA9IGZ1bmN0aW9uIGFwcGVuZENzcygpIHtcbiAgcmV0dXJuIGN1cnJlbnRBZGFwdGVyKCkuYXBwZW5kQ3NzKC4uLmFyZ3VtZW50cyk7XG59O1xudmFyIHJlZ2lzdGVyQ2xhc3NOYW1lID0gZnVuY3Rpb24gcmVnaXN0ZXJDbGFzc05hbWUoKSB7XG4gIHJldHVybiBjdXJyZW50QWRhcHRlcigpLnJlZ2lzdGVyQ2xhc3NOYW1lKC4uLmFyZ3VtZW50cyk7XG59O1xudmFyIHJlZ2lzdGVyQ29tcG9zaXRpb24gPSBmdW5jdGlvbiByZWdpc3RlckNvbXBvc2l0aW9uKCkge1xuICByZXR1cm4gY3VycmVudEFkYXB0ZXIoKS5yZWdpc3RlckNvbXBvc2l0aW9uKC4uLmFyZ3VtZW50cyk7XG59O1xudmFyIG1hcmtDb21wb3NpdGlvblVzZWQgPSBmdW5jdGlvbiBtYXJrQ29tcG9zaXRpb25Vc2VkKCkge1xuICByZXR1cm4gY3VycmVudEFkYXB0ZXIoKS5tYXJrQ29tcG9zaXRpb25Vc2VkKC4uLmFyZ3VtZW50cyk7XG59O1xudmFyIG9uQmVnaW5GaWxlU2NvcGUgPSBmdW5jdGlvbiBvbkJlZ2luRmlsZVNjb3BlKCkge1xuICB2YXIgX2N1cnJlbnRBZGFwdGVyJG9uQmVnLCBfY3VycmVudEFkYXB0ZXI7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gKF9jdXJyZW50QWRhcHRlciRvbkJlZyA9IChfY3VycmVudEFkYXB0ZXIgPSBjdXJyZW50QWRhcHRlcigpKS5vbkJlZ2luRmlsZVNjb3BlKSA9PT0gbnVsbCB8fCBfY3VycmVudEFkYXB0ZXIkb25CZWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50QWRhcHRlciRvbkJlZy5jYWxsKF9jdXJyZW50QWRhcHRlciwgLi4ucHJvcHMpO1xufTtcbnZhciBvbkVuZEZpbGVTY29wZSA9IGZ1bmN0aW9uIG9uRW5kRmlsZVNjb3BlKCkge1xuICByZXR1cm4gY3VycmVudEFkYXB0ZXIoKS5vbkVuZEZpbGVTY29wZSguLi5hcmd1bWVudHMpO1xufTtcbnZhciBnZXRJZGVudE9wdGlvbiA9IGZ1bmN0aW9uIGdldElkZW50T3B0aW9uKCkge1xuICB2YXIgYWRhcHRlciA9IGN1cnJlbnRBZGFwdGVyKCk7XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgdmVyc2lvbnMgb2YgdGhlIGludGVncmF0aW9uIHBhY2thZ2VcbiAgaWYgKCEoJ2dldElkZW50T3B0aW9uJyBpbiBhZGFwdGVyKSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gJ3Nob3J0JyA6ICdkZWJ1Zyc7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXIuZ2V0SWRlbnRPcHRpb24oLi4uYXJndW1lbnRzKTtcbn07XG5cbmV4cG9ydCB7IGFwcGVuZENzcywgZ2V0SWRlbnRPcHRpb24sIG1hcmtDb21wb3NpdGlvblVzZWQsIG1vY2tBZGFwdGVyLCBvbkJlZ2luRmlsZVNjb3BlLCBvbkVuZEZpbGVTY29wZSwgcmVnaXN0ZXJDbGFzc05hbWUsIHJlZ2lzdGVyQ29tcG9zaXRpb24sIHJlbW92ZUFkYXB0ZXIsIHNldEFkYXB0ZXIsIHNldEFkYXB0ZXJJZk5vdFNldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _taggedTemplateLiteral)\n/* harmony export */ });\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdGFnZ2VkVGVtcGxhdGVMaXRlcmFsLTEwOTk4MzE1LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96a2RhdGF2YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3MvZGlzdC90YWdnZWRUZW1wbGF0ZUxpdGVyYWwtMTA5OTgzMTUuZXNtLmpzPzc1ODAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHtcbiAgaWYgKCFyYXcpIHtcbiAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHtcbiAgICByYXc6IHtcbiAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICB9XG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbCBhcyBfIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _objectWithoutProperties),\n/* harmony export */   d: () => (/* binding */ dudupeAndJoinClassList),\n/* harmony export */   t: () => (/* binding */ transformCss)\n/* harmony export */ });\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cssesc */ \"(ssr)/../node_modules/cssesc/cssesc.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cssesc__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var modern_ahocorasick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modern-ahocorasick */ \"(ssr)/../node_modules/modern-ahocorasick/dist/index.js\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n/* harmony import */ var _taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var css_what__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-what */ \"(ssr)/../node_modules/css-what/lib/es/parse.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var media_query_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! media-query-parser */ \"(ssr)/../node_modules/media-query-parser/dist/media-query-parser.esm.js\");\n\n\n\n\n\n\n\n\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction forEach(obj, fn) {\n  for (var _key in obj) {\n    fn(obj[_key], _key);\n  }\n}\nfunction omit(obj, omitKeys) {\n  var result = {};\n  for (var _key2 in obj) {\n    if (omitKeys.indexOf(_key2) === -1) {\n      result[_key2] = obj[_key2];\n    }\n  }\n  return result;\n}\nfunction mapKeys(obj, fn) {\n  var result = {};\n  for (var _key3 in obj) {\n    result[fn(obj[_key3], _key3)] = obj[_key3];\n  }\n  return result;\n}\nfunction composeStylesIntoSet(set) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    classNames[_key5 - 1] = arguments[_key5];\n  }\n  for (var className of classNames) {\n    if (className.length === 0) {\n      continue;\n    }\n    if (typeof className === 'string') {\n      if (className.includes(' ')) {\n        composeStylesIntoSet(set, ...className.trim().split(' '));\n      } else {\n        set.add(className);\n      }\n    } else if (Array.isArray(className)) {\n      composeStylesIntoSet(set, ...className);\n    }\n  }\n}\nfunction dudupeAndJoinClassList(classNames) {\n  var set = new Set();\n  composeStylesIntoSet(set, ...classNames);\n  return Array.from(set).join(' ');\n}\n\nvar _templateObject$1;\n\n// https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nvar validateSelector = (selector, targetClassName) => {\n  var replaceTarget = () => {\n    var targetRegex = new RegExp(\".\".concat(escapeRegex(cssesc__WEBPACK_IMPORTED_MODULE_0___default()(targetClassName, {\n      isIdentifier: true\n    }))), 'g');\n    return selector.replace(targetRegex, '&');\n  };\n  var selectorParts;\n  try {\n    selectorParts = (0,css_what__WEBPACK_IMPORTED_MODULE_5__.parse)(selector);\n  } catch (err) {\n    throw new Error(\"Invalid selector: \".concat(replaceTarget()));\n  }\n  selectorParts.forEach(tokens => {\n    try {\n      for (var i = tokens.length - 1; i >= -1; i--) {\n        if (!tokens[i]) {\n          throw new Error();\n        }\n        var token = tokens[i];\n        if (token.type === 'child' || token.type === 'parent' || token.type === 'sibling' || token.type === 'adjacent' || token.type === 'descendant') {\n          throw new Error();\n        }\n        if (token.type === 'attribute' && token.name === 'class' && token.value === targetClassName) {\n          return; // Found it\n        }\n      }\n    } catch (err) {\n      throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject$1 || (_templateObject$1 = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__._)([\"\\n        Invalid selector: \", \"\\n    \\n        Style selectors must target the '&' character (along with any modifiers), e.g. \", \" or \", \".\\n        \\n        This is to ensure that each style block only affects the styling of a single class.\\n        \\n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of \", \") to 'parent', you should add \", \" to 'child').\\n        \\n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write \", \", you should instead write 'globalStyle(\", \", { ... })'\\n      \"])), replaceTarget(), '`${parent} &`', '`${parent} &:hover`', '`& ${child}`', '`${parent} &`', '`& h1`', '`${parent} h1`'));\n    }\n  });\n};\n\n/** e.g. @media screen and (min-width: 500px) */\n\nclass ConditionalRuleset {\n  /**\n   * Stores information about where conditions must be in relation to other conditions\n   *\n   * e.g. mobile -> tablet, desktop\n   */\n\n  constructor() {\n    this.ruleset = new Map();\n    this.precedenceLookup = new Map();\n  }\n  findOrCreateCondition(conditionQuery) {\n    var targetCondition = this.ruleset.get(conditionQuery);\n    if (!targetCondition) {\n      // No target condition so create one\n      targetCondition = {\n        query: conditionQuery,\n        rules: [],\n        children: new ConditionalRuleset()\n      };\n      this.ruleset.set(conditionQuery, targetCondition);\n    }\n    return targetCondition;\n  }\n  getConditionalRulesetByPath(conditionPath) {\n    var currRuleset = this;\n    for (var query of conditionPath) {\n      var condition = currRuleset.findOrCreateCondition(query);\n      currRuleset = condition.children;\n    }\n    return currRuleset;\n  }\n  addRule(rule, conditionQuery, conditionPath) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);\n    if (!targetCondition) {\n      throw new Error('Failed to add conditional rule');\n    }\n    targetCondition.rules.push(rule);\n  }\n  addConditionPrecedence(conditionPath, conditionOrder) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    for (var i = 0; i < conditionOrder.length; i++) {\n      var _ruleset$precedenceLo;\n      var query = conditionOrder[i];\n      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : new Set();\n      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {\n        conditionPrecedence.add(lowerPrecedenceCondition);\n      }\n      ruleset.precedenceLookup.set(query, conditionPrecedence);\n    }\n  }\n  isCompatible(incomingRuleset) {\n    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {\n      for (var lowerPrecedenceCondition of orderPrecedence) {\n        var _incomingRuleset$prec;\n        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that children are compatible\n    for (var {\n      query,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  merge(incomingRuleset) {\n    // Merge rulesets into one array\n    for (var {\n      query,\n      rules,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition) {\n        matchingCondition.rules.push(...rules);\n        matchingCondition.children.merge(children);\n      } else {\n        this.ruleset.set(query, {\n          query,\n          rules,\n          children\n        });\n      }\n    }\n\n    // Merge order precedences\n    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {\n      var _this$precedenceLooku;\n      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : new Set();\n      this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));\n    }\n  }\n\n  /**\n   * Merge another ConditionalRuleset into this one if they are compatible\n   *\n   * @returns true if successful, false if the ruleset is incompatible\n   */\n  mergeIfCompatible(incomingRuleset) {\n    if (!this.isCompatible(incomingRuleset)) {\n      return false;\n    }\n    this.merge(incomingRuleset);\n    return true;\n  }\n  getSortedRuleset() {\n    var _this = this;\n    var sortedRuleset = [];\n\n    // Loop through all queries and add them to the sorted ruleset\n    var _loop = function _loop(dependents) {\n      var conditionForQuery = _this.ruleset.get(query);\n      if (!conditionForQuery) {\n        throw new Error(\"Can't find condition for \".concat(query));\n      }\n\n      // Find the location of the first dependent condition in the sortedRuleset\n      // A dependent condition is a condition that must be placed *after* the current one\n      var firstMatchingDependent = sortedRuleset.findIndex(condition => dependents.has(condition.query));\n      if (firstMatchingDependent > -1) {\n        // Insert the condition before the dependent one\n        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);\n      } else {\n        // No match, just insert at the end\n        sortedRuleset.push(conditionForQuery);\n      }\n    };\n    for (var [query, dependents] of this.precedenceLookup.entries()) {\n      _loop(dependents);\n    }\n    return sortedRuleset;\n  }\n  renderToArray() {\n    var arr = [];\n    for (var {\n      query,\n      rules,\n      children\n    } of this.getSortedRuleset()) {\n      var selectors = {};\n      for (var rule of rules) {\n        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);\n      }\n      Object.assign(selectors, ...children.renderToArray());\n      arr.push({\n        [query]: selectors\n      });\n    }\n    return arr;\n  }\n}\n\nvar simplePseudoMap = {\n  ':-moz-any-link': true,\n  ':-moz-full-screen': true,\n  ':-moz-placeholder': true,\n  ':-moz-read-only': true,\n  ':-moz-read-write': true,\n  ':-ms-fullscreen': true,\n  ':-ms-input-placeholder': true,\n  ':-webkit-any-link': true,\n  ':-webkit-full-screen': true,\n  '::-moz-color-swatch': true,\n  '::-moz-list-bullet': true,\n  '::-moz-list-number': true,\n  '::-moz-page-sequence': true,\n  '::-moz-page': true,\n  '::-moz-placeholder': true,\n  '::-moz-progress-bar': true,\n  '::-moz-range-progress': true,\n  '::-moz-range-thumb': true,\n  '::-moz-range-track': true,\n  '::-moz-scrolled-page-sequence': true,\n  '::-moz-selection': true,\n  '::-ms-backdrop': true,\n  '::-ms-browse': true,\n  '::-ms-check': true,\n  '::-ms-clear': true,\n  '::-ms-fill-lower': true,\n  '::-ms-fill-upper': true,\n  '::-ms-fill': true,\n  '::-ms-reveal': true,\n  '::-ms-thumb': true,\n  '::-ms-ticks-after': true,\n  '::-ms-ticks-before': true,\n  '::-ms-tooltip': true,\n  '::-ms-track': true,\n  '::-ms-value': true,\n  '::-webkit-backdrop': true,\n  '::-webkit-calendar-picker-indicator': true,\n  '::-webkit-inner-spin-button': true,\n  '::-webkit-input-placeholder': true,\n  '::-webkit-meter-bar': true,\n  '::-webkit-meter-even-less-good-value': true,\n  '::-webkit-meter-inner-element': true,\n  '::-webkit-meter-optimum-value': true,\n  '::-webkit-meter-suboptimum-value': true,\n  '::-webkit-outer-spin-button': true,\n  '::-webkit-progress-bar': true,\n  '::-webkit-progress-inner-element': true,\n  '::-webkit-progress-inner-value': true,\n  '::-webkit-progress-value': true,\n  '::-webkit-resizer': true,\n  '::-webkit-scrollbar-button': true,\n  '::-webkit-scrollbar-corner': true,\n  '::-webkit-scrollbar-thumb': true,\n  '::-webkit-scrollbar-track-piece': true,\n  '::-webkit-scrollbar-track': true,\n  '::-webkit-scrollbar': true,\n  '::-webkit-search-cancel-button': true,\n  '::-webkit-search-results-button': true,\n  '::-webkit-slider-runnable-track': true,\n  '::-webkit-slider-thumb': true,\n  '::after': true,\n  '::backdrop': true,\n  '::before': true,\n  '::cue': true,\n  '::file-selector-button': true,\n  '::first-letter': true,\n  '::first-line': true,\n  '::grammar-error': true,\n  '::marker': true,\n  '::placeholder': true,\n  '::selection': true,\n  '::spelling-error': true,\n  '::target-text': true,\n  '::view-transition-group': true,\n  '::view-transition-image-pair': true,\n  '::view-transition-new': true,\n  '::view-transition-old': true,\n  '::view-transition': true,\n  ':active': true,\n  ':after': true,\n  ':any-link': true,\n  ':before': true,\n  ':blank': true,\n  ':checked': true,\n  ':default': true,\n  ':defined': true,\n  ':disabled': true,\n  ':empty': true,\n  ':enabled': true,\n  ':first-child': true,\n  ':first-letter': true,\n  ':first-line': true,\n  ':first-of-type': true,\n  ':first': true,\n  ':focus-visible': true,\n  ':focus-within': true,\n  ':focus': true,\n  ':fullscreen': true,\n  ':hover': true,\n  ':in-range': true,\n  ':indeterminate': true,\n  ':invalid': true,\n  ':last-child': true,\n  ':last-of-type': true,\n  ':left': true,\n  ':link': true,\n  ':only-child': true,\n  ':only-of-type': true,\n  ':optional': true,\n  ':out-of-range': true,\n  ':placeholder-shown': true,\n  ':read-only': true,\n  ':read-write': true,\n  ':required': true,\n  ':right': true,\n  ':root': true,\n  ':scope': true,\n  ':target': true,\n  ':valid': true,\n  ':visited': true\n};\nvar simplePseudos = Object.keys(simplePseudoMap);\nvar simplePseudoLookup = simplePseudoMap;\n\nvar _templateObject;\nvar createMediaQueryError = (mediaQuery, msg) => new Error((0,dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject || (_templateObject = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_2__._)([\"\\n    Invalid media query: \\\"\", \"\\\"\\n\\n    \", \"\\n\\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\\n  \"])), mediaQuery, msg));\nvar validateMediaQuery = mediaQuery => {\n  // Empty queries will start with '@media '\n  if (mediaQuery === '@media ') {\n    throw createMediaQueryError(mediaQuery, 'Query is empty');\n  }\n  try {\n    (0,media_query_parser__WEBPACK_IMPORTED_MODULE_4__.toAST)(mediaQuery);\n  } catch (e) {\n    throw createMediaQueryError(mediaQuery, e.message);\n  }\n};\n\nvar _excluded = [\"vars\"],\n  _excluded2 = [\"content\"];\nvar DECLARATION = '__DECLARATION';\nvar UNITLESS = {\n  animationIterationCount: true,\n  borderImage: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  initialLetter: true,\n  lineClamp: true,\n  lineHeight: true,\n  maxLines: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  scale: true,\n  tabSize: true,\n  WebkitLineClamp: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // svg properties\n  fillOpacity: true,\n  floodOpacity: true,\n  maskBorder: true,\n  maskBorderOutset: true,\n  maskBorderSlice: true,\n  maskBorderWidth: true,\n  shapeImageThreshold: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nfunction dashify(str) {\n  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();\n}\nfunction replaceBetweenIndexes(target, startIndex, endIndex, replacement) {\n  var start = target.slice(0, startIndex);\n  var end = target.slice(endIndex);\n  return \"\".concat(start).concat(replacement).concat(end);\n}\nvar DOUBLE_SPACE = '  ';\nvar specialKeys = [...simplePseudos, '@layer', '@media', '@supports', '@container', 'selectors'];\nclass Stylesheet {\n  constructor(localClassNames, composedClassLists) {\n    this.rules = [];\n    this.conditionalRulesets = [new ConditionalRuleset()];\n    this.fontFaceRules = [];\n    this.keyframesRules = [];\n    this.propertyRules = [];\n    this.localClassNamesMap = new Map(localClassNames.map(localClassName => [localClassName, localClassName]));\n    this.localClassNamesSearch = new modern_ahocorasick__WEBPACK_IMPORTED_MODULE_1__[\"default\"](localClassNames);\n    this.layers = new Map();\n\n    // Class list compositions should be priortized by Newer > Older\n    // Therefore we reverse the array as they are added in sequence\n    this.composedClassLists = composedClassLists.map(_ref => {\n      var {\n        identifier,\n        classList\n      } = _ref;\n      return {\n        identifier,\n        regex: RegExp(\"(\".concat(classList, \")\"), 'g')\n      };\n    }).reverse();\n  }\n  processCssObj(root) {\n    if (root.type === 'fontFace') {\n      this.fontFaceRules.push(root.rule);\n      return;\n    }\n    if (root.type === 'property') {\n      this.propertyRules.push(root);\n      return;\n    }\n    if (root.type === 'keyframes') {\n      root.rule = Object.fromEntries(Object.entries(root.rule).map(_ref2 => {\n        var [keyframe, rule] = _ref2;\n        return [keyframe, this.transformVars(this.transformProperties(rule))];\n      }));\n      this.keyframesRules.push(root);\n      return;\n    }\n    this.currConditionalRuleset = new ConditionalRuleset();\n    if (root.type === 'layer') {\n      var layerDefinition = \"@layer \".concat(root.name);\n      this.addLayer([layerDefinition]);\n    } else {\n      // Add main styles\n      var mainRule = omit(root.rule, specialKeys);\n      this.addRule({\n        selector: root.selector,\n        rule: mainRule\n      });\n      this.transformLayer(root, root.rule['@layer']);\n      this.transformMedia(root, root.rule['@media']);\n      this.transformSupports(root, root.rule['@supports']);\n      this.transformContainer(root, root.rule['@container']);\n      this.transformSimplePseudos(root, root.rule);\n      this.transformSelectors(root, root.rule);\n    }\n    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];\n    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {\n      // Ruleset merge failed due to incompatibility. We now deopt by starting a fresh ConditionalRuleset\n      this.conditionalRulesets.push(this.currConditionalRuleset);\n    }\n  }\n  addConditionalRule(cssRule, conditions) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    if (!this.currConditionalRuleset) {\n      throw new Error(\"Couldn't add conditional rule\");\n    }\n    var conditionQuery = conditions[conditions.length - 1];\n    var parentConditions = conditions.slice(0, conditions.length - 1);\n    this.currConditionalRuleset.addRule({\n      selector,\n      rule\n    }, conditionQuery, parentConditions);\n  }\n  addRule(cssRule) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    this.rules.push({\n      selector,\n      rule\n    });\n  }\n  addLayer(layer) {\n    var uniqueLayerKey = layer.join(' - ');\n    this.layers.set(uniqueLayerKey, layer);\n  }\n  transformProperties(cssRule) {\n    return this.transformContent(this.pixelifyProperties(cssRule));\n  }\n  pixelifyProperties(cssRule) {\n    forEach(cssRule, (value, key) => {\n      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {\n        // @ts-expect-error Any ideas?\n        cssRule[key] = \"\".concat(value, \"px\");\n      }\n    });\n    return cssRule;\n  }\n  transformVars(_ref3) {\n    var {\n        vars\n      } = _ref3,\n      rest = _objectWithoutProperties(_ref3, _excluded);\n    if (!vars) {\n      return rest;\n    }\n    return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_6__.getVarName)(key))), rest);\n  }\n  transformContent(_ref4) {\n    var {\n        content\n      } = _ref4,\n      rest = _objectWithoutProperties(_ref4, _excluded2);\n    if (typeof content === 'undefined') {\n      return rest;\n    }\n\n    // Handle fallback arrays:\n    var contentArray = Array.isArray(content) ? content : [content];\n    return _objectSpread2({\n      content: contentArray.map(value =>\n      // This logic was adapted from Stitches :)\n      value && (value.includes('\"') || value.includes(\"'\") || /^([A-Za-z\\-]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\\s|$)/.test(value)) ? value : \"\\\"\".concat(value, \"\\\"\"))\n    }, rest);\n  }\n  transformClassname(identifier) {\n    return \".\".concat(cssesc__WEBPACK_IMPORTED_MODULE_0___default()(identifier, {\n      isIdentifier: true\n    }));\n  }\n  transformSelector(selector) {\n    // Map class list compositions to single identifiers\n    var transformedSelector = selector;\n    var _loop = function _loop(identifier) {\n      transformedSelector = transformedSelector.replace(regex, () => {\n        (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_7__.markCompositionUsed)(identifier);\n        return identifier;\n      });\n    };\n    for (var {\n      identifier,\n      regex\n    } of this.composedClassLists) {\n      _loop(identifier);\n    }\n    if (this.localClassNamesMap.has(transformedSelector)) {\n      return this.transformClassname(transformedSelector);\n    }\n    var results = this.localClassNamesSearch.search(transformedSelector);\n    var lastReplaceIndex = transformedSelector.length;\n\n    // Perform replacements backwards to simplify index handling\n    for (var i = results.length - 1; i >= 0; i--) {\n      var [endIndex, [firstMatch]] = results[i];\n      var startIndex = endIndex - firstMatch.length + 1;\n\n      // Class names can be substrings of other class names\n      // e.g. '_1g1ptzo1' and '_1g1ptzo10'\n      //\n      // Additionally, concatenated classnames can contain substrings equal to other classnames\n      // e.g. '&&' where '&' is 'debugName_hash1' and 'debugName_hash1d' is also a local classname\n      // Before transforming the selector, this would look like `debugName_hash1debugName_hash1`\n      // which contains the substring `debugName_hash1d`â€™.\n      //\n      // In either of these cases, the last replace index will occur either before or within the\n      // current replacement range (from `startIndex` to `endIndex`).\n      // If this occurs, we skip the replacement to avoid transforming the selector incorrectly.\n      var skipReplacement = lastReplaceIndex <= endIndex;\n      if (skipReplacement) {\n        continue;\n      }\n      lastReplaceIndex = startIndex;\n\n      // If class names already starts with a '.' then skip\n      if (transformedSelector[startIndex - 1] !== '.') {\n        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));\n      }\n    }\n    return transformedSelector;\n  }\n  transformSelectors(root, rule, conditions) {\n    forEach(rule.selectors, (selectorRule, selector) => {\n      if (root.type !== 'local') {\n        throw new Error(\"Selectors are not allowed within \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n      }\n      var transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));\n      validateSelector(transformedSelector, root.selector);\n      var rule = {\n        selector: transformedSelector,\n        rule: omit(selectorRule, specialKeys)\n      };\n      if (conditions) {\n        this.addConditionalRule(rule, conditions);\n      } else {\n        this.addRule(rule);\n      }\n      var selectorRoot = {\n        type: 'selector',\n        selector: transformedSelector,\n        rule: selectorRule\n      };\n      this.transformLayer(selectorRoot, selectorRule['@layer'], conditions);\n      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);\n      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);\n      this.transformContainer(selectorRoot, selectorRule['@container'], conditions);\n    });\n  }\n  transformMedia(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional;\n      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@media \".concat(query)));\n      for (var [query, mediaRule] of Object.entries(rules)) {\n        var mediaQuery = \"@media \".concat(query);\n        validateMediaQuery(mediaQuery);\n        var conditions = [...parentConditions, mediaQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(mediaRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, mediaRule, conditions);\n          this.transformSelectors(root, mediaRule, conditions);\n        }\n        this.transformLayer(root, mediaRule['@layer'], conditions);\n        this.transformSupports(root, mediaRule['@supports'], conditions);\n        this.transformContainer(root, mediaRule['@container'], conditions);\n      }\n    }\n  }\n  transformContainer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional2;\n      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@container \".concat(query)));\n      forEach(rules, (containerRule, query) => {\n        var containerQuery = \"@container \".concat(query);\n        var conditions = [...parentConditions, containerQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(containerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, containerRule, conditions);\n          this.transformSelectors(root, containerRule, conditions);\n        }\n        this.transformLayer(root, containerRule['@layer'], conditions);\n        this.transformSupports(root, containerRule['@supports'], conditions);\n        this.transformMedia(root, containerRule['@media'], conditions);\n      });\n    }\n  }\n  transformLayer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional3;\n      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map(name => \"@layer \".concat(name)));\n      forEach(rules, (layerRule, name) => {\n        var conditions = [...parentConditions, \"@layer \".concat(name)];\n        this.addLayer(conditions);\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(layerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, layerRule, conditions);\n          this.transformSelectors(root, layerRule, conditions);\n        }\n        this.transformMedia(root, layerRule['@media'], conditions);\n        this.transformSupports(root, layerRule['@supports'], conditions);\n        this.transformContainer(root, layerRule['@container'], conditions);\n      });\n    }\n  }\n  transformSupports(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional4;\n      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@supports \".concat(query)));\n      forEach(rules, (supportsRule, query) => {\n        var conditions = [...parentConditions, \"@supports \".concat(query)];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(supportsRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, supportsRule, conditions);\n          this.transformSelectors(root, supportsRule, conditions);\n        }\n        this.transformLayer(root, supportsRule['@layer'], conditions);\n        this.transformMedia(root, supportsRule['@media'], conditions);\n        this.transformContainer(root, supportsRule['@container'], conditions);\n      });\n    }\n  }\n  transformSimplePseudos(root, rule, conditions) {\n    for (var key of Object.keys(rule)) {\n      // Process simple pseudos\n      if (simplePseudoLookup[key]) {\n        if (root.type !== 'local') {\n          throw new Error(\"Simple pseudos are not valid in \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n        }\n        if (conditions) {\n          this.addConditionalRule({\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          }, conditions);\n        } else {\n          this.addRule({\n            conditions,\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          });\n        }\n      }\n    }\n  }\n  toCss() {\n    var css = [];\n\n    // Render font-face rules\n    for (var fontFaceRule of this.fontFaceRules) {\n      css.push(renderCss({\n        '@font-face': fontFaceRule\n      }));\n    }\n\n    // Render property rules\n    for (var property of this.propertyRules) {\n      css.push(renderCss({\n        [\"@property \".concat(property.name)]: property.rule\n      }));\n    }\n\n    // Render keyframes\n    for (var keyframe of this.keyframesRules) {\n      css.push(renderCss({\n        [\"@keyframes \".concat(keyframe.name)]: keyframe.rule\n      }));\n    }\n\n    // Render layer definitions\n    for (var layer of this.layers.values()) {\n      var [definition, ...nesting] = layer.reverse();\n      var cssObj = {\n        [definition]: DECLARATION\n      };\n      for (var part of nesting) {\n        cssObj = {\n          [part]: cssObj\n        };\n      }\n      css.push(renderCss(cssObj));\n    }\n\n    // Render unconditional rules\n    for (var rule of this.rules) {\n      css.push(renderCss({\n        [rule.selector]: rule.rule\n      }));\n    }\n\n    // Render conditional rules\n    for (var conditionalRuleset of this.conditionalRulesets) {\n      for (var conditionalRule of conditionalRuleset.renderToArray()) {\n        css.push(renderCss(conditionalRule));\n      }\n    }\n    return css.filter(Boolean);\n  }\n}\nfunction renderCss(v) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var rules = [];\n  var _loop2 = function _loop2(key) {\n    var value = v[key];\n    if (value && Array.isArray(value)) {\n      rules.push(...value.map(v => renderCss({\n        [key]: v\n      }, indent)));\n    } else if (value && typeof value === 'object') {\n      var isEmpty = Object.keys(value).length === 0;\n      if (!isEmpty) {\n        rules.push(\"\".concat(indent).concat(key, \" {\\n\").concat(renderCss(value, indent + DOUBLE_SPACE), \"\\n\").concat(indent, \"}\"));\n      }\n    } else if (value === DECLARATION) {\n      rules.push(\"\".concat(indent).concat(key, \";\"));\n    } else {\n      rules.push(\"\".concat(indent).concat(key.startsWith('--') ? key : dashify(key), \": \").concat(value, \";\"));\n    }\n  };\n  for (var key of Object.keys(v)) {\n    _loop2(key);\n  }\n  return rules.join('\\n');\n}\nfunction transformCss(_ref5) {\n  var {\n    localClassNames,\n    cssObjs,\n    composedClassLists\n  } = _ref5;\n  var stylesheet = new Stylesheet(localClassNames, composedClassLists);\n  for (var root of cssObjs) {\n    stylesheet.processCssObj(root);\n  }\n  return stylesheet.toCss();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdHJhbnNmb3JtQ3NzLTBkYmEzNmJmLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQzFCO0FBQ2lCO0FBQzRDO0FBQ0g7QUFDckQ7QUFDTDtBQUNlOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csY0FBYztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkNBQU07QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQUs7QUFDekIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixrREFBTSwyQ0FBMkMseUVBQXNCLDhyQkFBOHJCLEtBQUsscUNBQXFDLFFBQVEsU0FBUyxRQUFRLGlCQUFpQixNQUFNLFFBQVEsUUFBUSxtQkFBbUIsUUFBUTtBQUNoNkI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGtEQUFNLHVDQUF1Qyx5RUFBc0I7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBSztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBEQUFXO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDLG9FQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUdBQW1CO0FBQzNCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvREFBb0QsNEVBQTRFO0FBQ2hJO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRDtBQUNqRCxNQUFNO0FBQ04sMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemtkYXRhdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdHJhbnNmb3JtQ3NzLTBkYmEzNmJmLmVzbS5qcz8wMzBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFZhck5hbWUgfSBmcm9tICdAdmFuaWxsYS1leHRyYWN0L3ByaXZhdGUnO1xuaW1wb3J0IGNzc2VzYyBmcm9tICdjc3Nlc2MnO1xuaW1wb3J0IEFob0NvcmFzaWNrIGZyb20gJ21vZGVybi1haG9jb3Jhc2ljayc7XG5pbXBvcnQgeyBtYXJrQ29tcG9zaXRpb25Vc2VkIH0gZnJvbSAnLi4vYWRhcHRlci9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtYWRhcHRlci5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsIH0gZnJvbSAnLi90YWdnZWRUZW1wbGF0ZUxpdGVyYWwtMTA5OTgzMTUuZXNtLmpzJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnY3NzLXdoYXQnO1xuaW1wb3J0IGRlZGVudCBmcm9tICdkZWRlbnQnO1xuaW1wb3J0IHsgdG9BU1QgfSBmcm9tICdtZWRpYS1xdWVyeS1wYXJzZXInO1xuXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICBmbihvYmpbX2tleV0sIF9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwgb21pdEtleXMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBfa2V5MiBpbiBvYmopIHtcbiAgICBpZiAob21pdEtleXMuaW5kZXhPZihfa2V5MikgPT09IC0xKSB7XG4gICAgICByZXN1bHRbX2tleTJdID0gb2JqW19rZXkyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcEtleXMob2JqLCBmbikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIF9rZXkzIGluIG9iaikge1xuICAgIHJlc3VsdFtmbihvYmpbX2tleTNdLCBfa2V5MyldID0gb2JqW19rZXkzXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcG9zZVN0eWxlc0ludG9TZXQoc2V0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc05hbWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW47IF9rZXk1KyspIHtcbiAgICBjbGFzc05hbWVzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG4gIGZvciAodmFyIGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChjbGFzc05hbWUuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICBjb21wb3NlU3R5bGVzSW50b1NldChzZXQsIC4uLmNsYXNzTmFtZS50cmltKCkuc3BsaXQoJyAnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXQuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkpIHtcbiAgICAgIGNvbXBvc2VTdHlsZXNJbnRvU2V0KHNldCwgLi4uY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGR1ZHVwZUFuZEpvaW5DbGFzc0xpc3QoY2xhc3NOYW1lcykge1xuICB2YXIgc2V0ID0gbmV3IFNldCgpO1xuICBjb21wb3NlU3R5bGVzSW50b1NldChzZXQsIC4uLmNsYXNzTmFtZXMpO1xuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpLmpvaW4oJyAnKTtcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCQxO1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cbnZhciB2YWxpZGF0ZVNlbGVjdG9yID0gKHNlbGVjdG9yLCB0YXJnZXRDbGFzc05hbWUpID0+IHtcbiAgdmFyIHJlcGxhY2VUYXJnZXQgPSAoKSA9PiB7XG4gICAgdmFyIHRhcmdldFJlZ2V4ID0gbmV3IFJlZ0V4cChcIi5cIi5jb25jYXQoZXNjYXBlUmVnZXgoY3NzZXNjKHRhcmdldENsYXNzTmFtZSwge1xuICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gICAgfSkpKSwgJ2cnKTtcbiAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZSh0YXJnZXRSZWdleCwgJyYnKTtcbiAgfTtcbiAgdmFyIHNlbGVjdG9yUGFydHM7XG4gIHRyeSB7XG4gICAgc2VsZWN0b3JQYXJ0cyA9IHBhcnNlKHNlbGVjdG9yKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvcjogXCIuY29uY2F0KHJlcGxhY2VUYXJnZXQoKSkpO1xuICB9XG4gIHNlbGVjdG9yUGFydHMuZm9yRWFjaCh0b2tlbnMgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xuICAgICAgICBpZiAoIXRva2Vuc1tpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjaGlsZCcgfHwgdG9rZW4udHlwZSA9PT0gJ3BhcmVudCcgfHwgdG9rZW4udHlwZSA9PT0gJ3NpYmxpbmcnIHx8IHRva2VuLnR5cGUgPT09ICdhZGphY2VudCcgfHwgdG9rZW4udHlwZSA9PT0gJ2Rlc2NlbmRhbnQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdhdHRyaWJ1dGUnICYmIHRva2VuLm5hbWUgPT09ICdjbGFzcycgJiYgdG9rZW4udmFsdWUgPT09IHRhcmdldENsYXNzTmFtZSkge1xuICAgICAgICAgIHJldHVybjsgLy8gRm91bmQgaXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGRlZGVudChfdGVtcGxhdGVPYmplY3QkMSB8fCAoX3RlbXBsYXRlT2JqZWN0JDEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgSW52YWxpZCBzZWxlY3RvcjogXCIsIFwiXFxuICAgIFxcbiAgICAgICAgU3R5bGUgc2VsZWN0b3JzIG11c3QgdGFyZ2V0IHRoZSAnJicgY2hhcmFjdGVyIChhbG9uZyB3aXRoIGFueSBtb2RpZmllcnMpLCBlLmcuIFwiLCBcIiBvciBcIiwgXCIuXFxuICAgICAgICBcXG4gICAgICAgIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgZWFjaCBzdHlsZSBibG9jayBvbmx5IGFmZmVjdHMgdGhlIHN0eWxpbmcgb2YgYSBzaW5nbGUgY2xhc3MuXFxuICAgICAgICBcXG4gICAgICAgIElmIHlvdXIgc2VsZWN0b3IgaXMgdGFyZ2V0aW5nIGFub3RoZXIgY2xhc3MsIHlvdSBzaG91bGQgbW92ZSBpdCB0byB0aGUgc3R5bGUgZGVmaW5pdGlvbiBmb3IgdGhhdCBjbGFzcywgZS5nLiBnaXZlbiB3ZSBoYXZlIHN0eWxlcyBmb3IgJ3BhcmVudCcgYW5kICdjaGlsZCcgZWxlbWVudHMsIGluc3RlYWQgb2YgYWRkaW5nIGEgc2VsZWN0b3Igb2YgXCIsIFwiKSB0byAncGFyZW50JywgeW91IHNob3VsZCBhZGQgXCIsIFwiIHRvICdjaGlsZCcpLlxcbiAgICAgICAgXFxuICAgICAgICBJZiB5b3VyIHNlbGVjdG9yIGlzIHRhcmdldGluZyBzb21ldGhpbmcgZ2xvYmFsLCB1c2UgdGhlICdnbG9iYWxTdHlsZScgZnVuY3Rpb24gaW5zdGVhZCwgZS5nLiBpZiB5b3Ugd2FudGVkIHRvIHdyaXRlIFwiLCBcIiwgeW91IHNob3VsZCBpbnN0ZWFkIHdyaXRlICdnbG9iYWxTdHlsZShcIiwgXCIsIHsgLi4uIH0pJ1xcbiAgICAgIFwiXSkpLCByZXBsYWNlVGFyZ2V0KCksICdgJHtwYXJlbnR9ICZgJywgJ2Ake3BhcmVudH0gJjpob3ZlcmAnLCAnYCYgJHtjaGlsZH1gJywgJ2Ake3BhcmVudH0gJmAnLCAnYCYgaDFgJywgJ2Ake3BhcmVudH0gaDFgJykpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKiogZS5nLiBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA1MDBweCkgKi9cblxuY2xhc3MgQ29uZGl0aW9uYWxSdWxlc2V0IHtcbiAgLyoqXG4gICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB3aGVyZSBjb25kaXRpb25zIG11c3QgYmUgaW4gcmVsYXRpb24gdG8gb3RoZXIgY29uZGl0aW9uc1xuICAgKlxuICAgKiBlLmcuIG1vYmlsZSAtPiB0YWJsZXQsIGRlc2t0b3BcbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ydWxlc2V0ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJlY2VkZW5jZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgfVxuICBmaW5kT3JDcmVhdGVDb25kaXRpb24oY29uZGl0aW9uUXVlcnkpIHtcbiAgICB2YXIgdGFyZ2V0Q29uZGl0aW9uID0gdGhpcy5ydWxlc2V0LmdldChjb25kaXRpb25RdWVyeSk7XG4gICAgaWYgKCF0YXJnZXRDb25kaXRpb24pIHtcbiAgICAgIC8vIE5vIHRhcmdldCBjb25kaXRpb24gc28gY3JlYXRlIG9uZVxuICAgICAgdGFyZ2V0Q29uZGl0aW9uID0ge1xuICAgICAgICBxdWVyeTogY29uZGl0aW9uUXVlcnksXG4gICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IG5ldyBDb25kaXRpb25hbFJ1bGVzZXQoKVxuICAgICAgfTtcbiAgICAgIHRoaXMucnVsZXNldC5zZXQoY29uZGl0aW9uUXVlcnksIHRhcmdldENvbmRpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRDb25kaXRpb247XG4gIH1cbiAgZ2V0Q29uZGl0aW9uYWxSdWxlc2V0QnlQYXRoKGNvbmRpdGlvblBhdGgpIHtcbiAgICB2YXIgY3VyclJ1bGVzZXQgPSB0aGlzO1xuICAgIGZvciAodmFyIHF1ZXJ5IG9mIGNvbmRpdGlvblBhdGgpIHtcbiAgICAgIHZhciBjb25kaXRpb24gPSBjdXJyUnVsZXNldC5maW5kT3JDcmVhdGVDb25kaXRpb24ocXVlcnkpO1xuICAgICAgY3VyclJ1bGVzZXQgPSBjb25kaXRpb24uY2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiBjdXJyUnVsZXNldDtcbiAgfVxuICBhZGRSdWxlKHJ1bGUsIGNvbmRpdGlvblF1ZXJ5LCBjb25kaXRpb25QYXRoKSB7XG4gICAgdmFyIHJ1bGVzZXQgPSB0aGlzLmdldENvbmRpdGlvbmFsUnVsZXNldEJ5UGF0aChjb25kaXRpb25QYXRoKTtcbiAgICB2YXIgdGFyZ2V0Q29uZGl0aW9uID0gcnVsZXNldC5maW5kT3JDcmVhdGVDb25kaXRpb24oY29uZGl0aW9uUXVlcnkpO1xuICAgIGlmICghdGFyZ2V0Q29uZGl0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhZGQgY29uZGl0aW9uYWwgcnVsZScpO1xuICAgIH1cbiAgICB0YXJnZXRDb25kaXRpb24ucnVsZXMucHVzaChydWxlKTtcbiAgfVxuICBhZGRDb25kaXRpb25QcmVjZWRlbmNlKGNvbmRpdGlvblBhdGgsIGNvbmRpdGlvbk9yZGVyKSB7XG4gICAgdmFyIHJ1bGVzZXQgPSB0aGlzLmdldENvbmRpdGlvbmFsUnVsZXNldEJ5UGF0aChjb25kaXRpb25QYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmRpdGlvbk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3J1bGVzZXQkcHJlY2VkZW5jZUxvO1xuICAgICAgdmFyIHF1ZXJ5ID0gY29uZGl0aW9uT3JkZXJbaV07XG4gICAgICB2YXIgY29uZGl0aW9uUHJlY2VkZW5jZSA9IChfcnVsZXNldCRwcmVjZWRlbmNlTG8gPSBydWxlc2V0LnByZWNlZGVuY2VMb29rdXAuZ2V0KHF1ZXJ5KSkgIT09IG51bGwgJiYgX3J1bGVzZXQkcHJlY2VkZW5jZUxvICE9PSB2b2lkIDAgPyBfcnVsZXNldCRwcmVjZWRlbmNlTG8gOiBuZXcgU2V0KCk7XG4gICAgICBmb3IgKHZhciBsb3dlclByZWNlZGVuY2VDb25kaXRpb24gb2YgY29uZGl0aW9uT3JkZXIuc2xpY2UoaSArIDEpKSB7XG4gICAgICAgIGNvbmRpdGlvblByZWNlZGVuY2UuYWRkKGxvd2VyUHJlY2VkZW5jZUNvbmRpdGlvbik7XG4gICAgICB9XG4gICAgICBydWxlc2V0LnByZWNlZGVuY2VMb29rdXAuc2V0KHF1ZXJ5LCBjb25kaXRpb25QcmVjZWRlbmNlKTtcbiAgICB9XG4gIH1cbiAgaXNDb21wYXRpYmxlKGluY29taW5nUnVsZXNldCkge1xuICAgIGZvciAodmFyIFtjb25kaXRpb24sIG9yZGVyUHJlY2VkZW5jZV0gb2YgdGhpcy5wcmVjZWRlbmNlTG9va3VwLmVudHJpZXMoKSkge1xuICAgICAgZm9yICh2YXIgbG93ZXJQcmVjZWRlbmNlQ29uZGl0aW9uIG9mIG9yZGVyUHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgX2luY29taW5nUnVsZXNldCRwcmVjO1xuICAgICAgICBpZiAoKF9pbmNvbWluZ1J1bGVzZXQkcHJlYyA9IGluY29taW5nUnVsZXNldC5wcmVjZWRlbmNlTG9va3VwLmdldChsb3dlclByZWNlZGVuY2VDb25kaXRpb24pKSAhPT0gbnVsbCAmJiBfaW5jb21pbmdSdWxlc2V0JHByZWMgIT09IHZvaWQgMCAmJiBfaW5jb21pbmdSdWxlc2V0JHByZWMuaGFzKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IGNoaWxkcmVuIGFyZSBjb21wYXRpYmxlXG4gICAgZm9yICh2YXIge1xuICAgICAgcXVlcnksXG4gICAgICBjaGlsZHJlblxuICAgIH0gb2YgaW5jb21pbmdSdWxlc2V0LnJ1bGVzZXQudmFsdWVzKCkpIHtcbiAgICAgIHZhciBtYXRjaGluZ0NvbmRpdGlvbiA9IHRoaXMucnVsZXNldC5nZXQocXVlcnkpO1xuICAgICAgaWYgKG1hdGNoaW5nQ29uZGl0aW9uICYmICFtYXRjaGluZ0NvbmRpdGlvbi5jaGlsZHJlbi5pc0NvbXBhdGlibGUoY2hpbGRyZW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbWVyZ2UoaW5jb21pbmdSdWxlc2V0KSB7XG4gICAgLy8gTWVyZ2UgcnVsZXNldHMgaW50byBvbmUgYXJyYXlcbiAgICBmb3IgKHZhciB7XG4gICAgICBxdWVyeSxcbiAgICAgIHJ1bGVzLFxuICAgICAgY2hpbGRyZW5cbiAgICB9IG9mIGluY29taW5nUnVsZXNldC5ydWxlc2V0LnZhbHVlcygpKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdDb25kaXRpb24gPSB0aGlzLnJ1bGVzZXQuZ2V0KHF1ZXJ5KTtcbiAgICAgIGlmIChtYXRjaGluZ0NvbmRpdGlvbikge1xuICAgICAgICBtYXRjaGluZ0NvbmRpdGlvbi5ydWxlcy5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgbWF0Y2hpbmdDb25kaXRpb24uY2hpbGRyZW4ubWVyZ2UoY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ydWxlc2V0LnNldChxdWVyeSwge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIG9yZGVyIHByZWNlZGVuY2VzXG4gICAgZm9yICh2YXIgW2NvbmRpdGlvbiwgaW5jb21pbmdPcmRlclByZWNlZGVuY2VdIG9mIGluY29taW5nUnVsZXNldC5wcmVjZWRlbmNlTG9va3VwLmVudHJpZXMoKSkge1xuICAgICAgdmFyIF90aGlzJHByZWNlZGVuY2VMb29rdTtcbiAgICAgIHZhciBvcmRlclByZWNlZGVuY2UgPSAoX3RoaXMkcHJlY2VkZW5jZUxvb2t1ID0gdGhpcy5wcmVjZWRlbmNlTG9va3VwLmdldChjb25kaXRpb24pKSAhPT0gbnVsbCAmJiBfdGhpcyRwcmVjZWRlbmNlTG9va3UgIT09IHZvaWQgMCA/IF90aGlzJHByZWNlZGVuY2VMb29rdSA6IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMucHJlY2VkZW5jZUxvb2t1cC5zZXQoY29uZGl0aW9uLCBuZXcgU2V0KFsuLi5vcmRlclByZWNlZGVuY2UsIC4uLmluY29taW5nT3JkZXJQcmVjZWRlbmNlXSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbm90aGVyIENvbmRpdGlvbmFsUnVsZXNldCBpbnRvIHRoaXMgb25lIGlmIHRoZXkgYXJlIGNvbXBhdGlibGVcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsLCBmYWxzZSBpZiB0aGUgcnVsZXNldCBpcyBpbmNvbXBhdGlibGVcbiAgICovXG4gIG1lcmdlSWZDb21wYXRpYmxlKGluY29taW5nUnVsZXNldCkge1xuICAgIGlmICghdGhpcy5pc0NvbXBhdGlibGUoaW5jb21pbmdSdWxlc2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm1lcmdlKGluY29taW5nUnVsZXNldCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0U29ydGVkUnVsZXNldCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBzb3J0ZWRSdWxlc2V0ID0gW107XG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIHF1ZXJpZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBzb3J0ZWQgcnVsZXNldFxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGRlcGVuZGVudHMpIHtcbiAgICAgIHZhciBjb25kaXRpb25Gb3JRdWVyeSA9IF90aGlzLnJ1bGVzZXQuZ2V0KHF1ZXJ5KTtcbiAgICAgIGlmICghY29uZGl0aW9uRm9yUXVlcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBjb25kaXRpb24gZm9yIFwiLmNvbmNhdChxdWVyeSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgZGVwZW5kZW50IGNvbmRpdGlvbiBpbiB0aGUgc29ydGVkUnVsZXNldFxuICAgICAgLy8gQSBkZXBlbmRlbnQgY29uZGl0aW9uIGlzIGEgY29uZGl0aW9uIHRoYXQgbXVzdCBiZSBwbGFjZWQgKmFmdGVyKiB0aGUgY3VycmVudCBvbmVcbiAgICAgIHZhciBmaXJzdE1hdGNoaW5nRGVwZW5kZW50ID0gc29ydGVkUnVsZXNldC5maW5kSW5kZXgoY29uZGl0aW9uID0+IGRlcGVuZGVudHMuaGFzKGNvbmRpdGlvbi5xdWVyeSkpO1xuICAgICAgaWYgKGZpcnN0TWF0Y2hpbmdEZXBlbmRlbnQgPiAtMSkge1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGNvbmRpdGlvbiBiZWZvcmUgdGhlIGRlcGVuZGVudCBvbmVcbiAgICAgICAgc29ydGVkUnVsZXNldC5zcGxpY2UoZmlyc3RNYXRjaGluZ0RlcGVuZGVudCwgMCwgY29uZGl0aW9uRm9yUXVlcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gbWF0Y2gsIGp1c3QgaW5zZXJ0IGF0IHRoZSBlbmRcbiAgICAgICAgc29ydGVkUnVsZXNldC5wdXNoKGNvbmRpdGlvbkZvclF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIFtxdWVyeSwgZGVwZW5kZW50c10gb2YgdGhpcy5wcmVjZWRlbmNlTG9va3VwLmVudHJpZXMoKSkge1xuICAgICAgX2xvb3AoZGVwZW5kZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWRSdWxlc2V0O1xuICB9XG4gIHJlbmRlclRvQXJyYXkoKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgcnVsZXMsXG4gICAgICBjaGlsZHJlblxuICAgIH0gb2YgdGhpcy5nZXRTb3J0ZWRSdWxlc2V0KCkpIHtcbiAgICAgIHZhciBzZWxlY3RvcnMgPSB7fTtcbiAgICAgIGZvciAodmFyIHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgc2VsZWN0b3JzW3J1bGUuc2VsZWN0b3JdID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNlbGVjdG9yc1tydWxlLnNlbGVjdG9yXSksIHJ1bGUucnVsZSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHNlbGVjdG9ycywgLi4uY2hpbGRyZW4ucmVuZGVyVG9BcnJheSgpKTtcbiAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgW3F1ZXJ5XTogc2VsZWN0b3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxufVxuXG52YXIgc2ltcGxlUHNldWRvTWFwID0ge1xuICAnOi1tb3otYW55LWxpbmsnOiB0cnVlLFxuICAnOi1tb3otZnVsbC1zY3JlZW4nOiB0cnVlLFxuICAnOi1tb3otcGxhY2Vob2xkZXInOiB0cnVlLFxuICAnOi1tb3otcmVhZC1vbmx5JzogdHJ1ZSxcbiAgJzotbW96LXJlYWQtd3JpdGUnOiB0cnVlLFxuICAnOi1tcy1mdWxsc2NyZWVuJzogdHJ1ZSxcbiAgJzotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiB0cnVlLFxuICAnOi13ZWJraXQtYW55LWxpbmsnOiB0cnVlLFxuICAnOi13ZWJraXQtZnVsbC1zY3JlZW4nOiB0cnVlLFxuICAnOjotbW96LWNvbG9yLXN3YXRjaCc6IHRydWUsXG4gICc6Oi1tb3otbGlzdC1idWxsZXQnOiB0cnVlLFxuICAnOjotbW96LWxpc3QtbnVtYmVyJzogdHJ1ZSxcbiAgJzo6LW1vei1wYWdlLXNlcXVlbmNlJzogdHJ1ZSxcbiAgJzo6LW1vei1wYWdlJzogdHJ1ZSxcbiAgJzo6LW1vei1wbGFjZWhvbGRlcic6IHRydWUsXG4gICc6Oi1tb3otcHJvZ3Jlc3MtYmFyJzogdHJ1ZSxcbiAgJzo6LW1vei1yYW5nZS1wcm9ncmVzcyc6IHRydWUsXG4gICc6Oi1tb3otcmFuZ2UtdGh1bWInOiB0cnVlLFxuICAnOjotbW96LXJhbmdlLXRyYWNrJzogdHJ1ZSxcbiAgJzo6LW1vei1zY3JvbGxlZC1wYWdlLXNlcXVlbmNlJzogdHJ1ZSxcbiAgJzo6LW1vei1zZWxlY3Rpb24nOiB0cnVlLFxuICAnOjotbXMtYmFja2Ryb3AnOiB0cnVlLFxuICAnOjotbXMtYnJvd3NlJzogdHJ1ZSxcbiAgJzo6LW1zLWNoZWNrJzogdHJ1ZSxcbiAgJzo6LW1zLWNsZWFyJzogdHJ1ZSxcbiAgJzo6LW1zLWZpbGwtbG93ZXInOiB0cnVlLFxuICAnOjotbXMtZmlsbC11cHBlcic6IHRydWUsXG4gICc6Oi1tcy1maWxsJzogdHJ1ZSxcbiAgJzo6LW1zLXJldmVhbCc6IHRydWUsXG4gICc6Oi1tcy10aHVtYic6IHRydWUsXG4gICc6Oi1tcy10aWNrcy1hZnRlcic6IHRydWUsXG4gICc6Oi1tcy10aWNrcy1iZWZvcmUnOiB0cnVlLFxuICAnOjotbXMtdG9vbHRpcCc6IHRydWUsXG4gICc6Oi1tcy10cmFjayc6IHRydWUsXG4gICc6Oi1tcy12YWx1ZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtYmFja2Ryb3AnOiB0cnVlLFxuICAnOjotd2Via2l0LWNhbGVuZGFyLXBpY2tlci1pbmRpY2F0b3InOiB0cnVlLFxuICAnOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHRydWUsXG4gICc6Oi13ZWJraXQtbWV0ZXItYmFyJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1tZXRlci1ldmVuLWxlc3MtZ29vZC12YWx1ZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtbWV0ZXItaW5uZXItZWxlbWVudCc6IHRydWUsXG4gICc6Oi13ZWJraXQtbWV0ZXItb3B0aW11bS12YWx1ZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtbWV0ZXItc3Vib3B0aW11bS12YWx1ZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24nOiB0cnVlLFxuICAnOjotd2Via2l0LXByb2dyZXNzLWJhcic6IHRydWUsXG4gICc6Oi13ZWJraXQtcHJvZ3Jlc3MtaW5uZXItZWxlbWVudCc6IHRydWUsXG4gICc6Oi13ZWJraXQtcHJvZ3Jlc3MtaW5uZXItdmFsdWUnOiB0cnVlLFxuICAnOjotd2Via2l0LXByb2dyZXNzLXZhbHVlJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1yZXNpemVyJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWInOiB0cnVlLFxuICAnOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZSc6IHRydWUsXG4gICc6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zY3JvbGxiYXInOiB0cnVlLFxuICAnOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uJzogdHJ1ZSxcbiAgJzo6LXdlYmtpdC1zZWFyY2gtcmVzdWx0cy1idXR0b24nOiB0cnVlLFxuICAnOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjayc6IHRydWUsXG4gICc6Oi13ZWJraXQtc2xpZGVyLXRodW1iJzogdHJ1ZSxcbiAgJzo6YWZ0ZXInOiB0cnVlLFxuICAnOjpiYWNrZHJvcCc6IHRydWUsXG4gICc6OmJlZm9yZSc6IHRydWUsXG4gICc6OmN1ZSc6IHRydWUsXG4gICc6OmZpbGUtc2VsZWN0b3ItYnV0dG9uJzogdHJ1ZSxcbiAgJzo6Zmlyc3QtbGV0dGVyJzogdHJ1ZSxcbiAgJzo6Zmlyc3QtbGluZSc6IHRydWUsXG4gICc6OmdyYW1tYXItZXJyb3InOiB0cnVlLFxuICAnOjptYXJrZXInOiB0cnVlLFxuICAnOjpwbGFjZWhvbGRlcic6IHRydWUsXG4gICc6OnNlbGVjdGlvbic6IHRydWUsXG4gICc6OnNwZWxsaW5nLWVycm9yJzogdHJ1ZSxcbiAgJzo6dGFyZ2V0LXRleHQnOiB0cnVlLFxuICAnOjp2aWV3LXRyYW5zaXRpb24tZ3JvdXAnOiB0cnVlLFxuICAnOjp2aWV3LXRyYW5zaXRpb24taW1hZ2UtcGFpcic6IHRydWUsXG4gICc6OnZpZXctdHJhbnNpdGlvbi1uZXcnOiB0cnVlLFxuICAnOjp2aWV3LXRyYW5zaXRpb24tb2xkJzogdHJ1ZSxcbiAgJzo6dmlldy10cmFuc2l0aW9uJzogdHJ1ZSxcbiAgJzphY3RpdmUnOiB0cnVlLFxuICAnOmFmdGVyJzogdHJ1ZSxcbiAgJzphbnktbGluayc6IHRydWUsXG4gICc6YmVmb3JlJzogdHJ1ZSxcbiAgJzpibGFuayc6IHRydWUsXG4gICc6Y2hlY2tlZCc6IHRydWUsXG4gICc6ZGVmYXVsdCc6IHRydWUsXG4gICc6ZGVmaW5lZCc6IHRydWUsXG4gICc6ZGlzYWJsZWQnOiB0cnVlLFxuICAnOmVtcHR5JzogdHJ1ZSxcbiAgJzplbmFibGVkJzogdHJ1ZSxcbiAgJzpmaXJzdC1jaGlsZCc6IHRydWUsXG4gICc6Zmlyc3QtbGV0dGVyJzogdHJ1ZSxcbiAgJzpmaXJzdC1saW5lJzogdHJ1ZSxcbiAgJzpmaXJzdC1vZi10eXBlJzogdHJ1ZSxcbiAgJzpmaXJzdCc6IHRydWUsXG4gICc6Zm9jdXMtdmlzaWJsZSc6IHRydWUsXG4gICc6Zm9jdXMtd2l0aGluJzogdHJ1ZSxcbiAgJzpmb2N1cyc6IHRydWUsXG4gICc6ZnVsbHNjcmVlbic6IHRydWUsXG4gICc6aG92ZXInOiB0cnVlLFxuICAnOmluLXJhbmdlJzogdHJ1ZSxcbiAgJzppbmRldGVybWluYXRlJzogdHJ1ZSxcbiAgJzppbnZhbGlkJzogdHJ1ZSxcbiAgJzpsYXN0LWNoaWxkJzogdHJ1ZSxcbiAgJzpsYXN0LW9mLXR5cGUnOiB0cnVlLFxuICAnOmxlZnQnOiB0cnVlLFxuICAnOmxpbmsnOiB0cnVlLFxuICAnOm9ubHktY2hpbGQnOiB0cnVlLFxuICAnOm9ubHktb2YtdHlwZSc6IHRydWUsXG4gICc6b3B0aW9uYWwnOiB0cnVlLFxuICAnOm91dC1vZi1yYW5nZSc6IHRydWUsXG4gICc6cGxhY2Vob2xkZXItc2hvd24nOiB0cnVlLFxuICAnOnJlYWQtb25seSc6IHRydWUsXG4gICc6cmVhZC13cml0ZSc6IHRydWUsXG4gICc6cmVxdWlyZWQnOiB0cnVlLFxuICAnOnJpZ2h0JzogdHJ1ZSxcbiAgJzpyb290JzogdHJ1ZSxcbiAgJzpzY29wZSc6IHRydWUsXG4gICc6dGFyZ2V0JzogdHJ1ZSxcbiAgJzp2YWxpZCc6IHRydWUsXG4gICc6dmlzaXRlZCc6IHRydWVcbn07XG52YXIgc2ltcGxlUHNldWRvcyA9IE9iamVjdC5rZXlzKHNpbXBsZVBzZXVkb01hcCk7XG52YXIgc2ltcGxlUHNldWRvTG9va3VwID0gc2ltcGxlUHNldWRvTWFwO1xuXG52YXIgX3RlbXBsYXRlT2JqZWN0O1xudmFyIGNyZWF0ZU1lZGlhUXVlcnlFcnJvciA9IChtZWRpYVF1ZXJ5LCBtc2cpID0+IG5ldyBFcnJvcihkZWRlbnQoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICBJbnZhbGlkIG1lZGlhIHF1ZXJ5OiBcXFwiXCIsIFwiXFxcIlxcblxcbiAgICBcIiwgXCJcXG5cXG4gICAgUmVhZCBtb3JlIG9uIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL01lZGlhX1F1ZXJpZXMvVXNpbmdfbWVkaWFfcXVlcmllc1xcbiAgXCJdKSksIG1lZGlhUXVlcnksIG1zZykpO1xudmFyIHZhbGlkYXRlTWVkaWFRdWVyeSA9IG1lZGlhUXVlcnkgPT4ge1xuICAvLyBFbXB0eSBxdWVyaWVzIHdpbGwgc3RhcnQgd2l0aCAnQG1lZGlhICdcbiAgaWYgKG1lZGlhUXVlcnkgPT09ICdAbWVkaWEgJykge1xuICAgIHRocm93IGNyZWF0ZU1lZGlhUXVlcnlFcnJvcihtZWRpYVF1ZXJ5LCAnUXVlcnkgaXMgZW1wdHknKTtcbiAgfVxuICB0cnkge1xuICAgIHRvQVNUKG1lZGlhUXVlcnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgY3JlYXRlTWVkaWFRdWVyeUVycm9yKG1lZGlhUXVlcnksIGUubWVzc2FnZSk7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ2YXJzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY29udGVudFwiXTtcbnZhciBERUNMQVJBVElPTiA9ICdfX0RFQ0xBUkFUSU9OJztcbnZhciBVTklUTEVTUyA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlOiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgaW5pdGlhbExldHRlcjogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBtYXhMaW5lczogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHNjYWxlOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICBXZWJraXRMaW5lQ2xhbXA6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBzdmcgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBtYXNrQm9yZGVyOiB0cnVlLFxuICBtYXNrQm9yZGVyT3V0c2V0OiB0cnVlLFxuICBtYXNrQm9yZGVyU2xpY2U6IHRydWUsXG4gIG1hc2tCb3JkZXJXaWR0aDogdHJ1ZSxcbiAgc2hhcGVJbWFnZVRocmVzaG9sZDogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuZnVuY3Rpb24gZGFzaGlmeShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS5yZXBsYWNlKC9ebXMtLywgJy1tcy0nKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUJldHdlZW5JbmRleGVzKHRhcmdldCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gIHZhciBzdGFydCA9IHRhcmdldC5zbGljZSgwLCBzdGFydEluZGV4KTtcbiAgdmFyIGVuZCA9IHRhcmdldC5zbGljZShlbmRJbmRleCk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzdGFydCkuY29uY2F0KHJlcGxhY2VtZW50KS5jb25jYXQoZW5kKTtcbn1cbnZhciBET1VCTEVfU1BBQ0UgPSAnICAnO1xudmFyIHNwZWNpYWxLZXlzID0gWy4uLnNpbXBsZVBzZXVkb3MsICdAbGF5ZXInLCAnQG1lZGlhJywgJ0BzdXBwb3J0cycsICdAY29udGFpbmVyJywgJ3NlbGVjdG9ycyddO1xuY2xhc3MgU3R5bGVzaGVldCB7XG4gIGNvbnN0cnVjdG9yKGxvY2FsQ2xhc3NOYW1lcywgY29tcG9zZWRDbGFzc0xpc3RzKSB7XG4gICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgIHRoaXMuY29uZGl0aW9uYWxSdWxlc2V0cyA9IFtuZXcgQ29uZGl0aW9uYWxSdWxlc2V0KCldO1xuICAgIHRoaXMuZm9udEZhY2VSdWxlcyA9IFtdO1xuICAgIHRoaXMua2V5ZnJhbWVzUnVsZXMgPSBbXTtcbiAgICB0aGlzLnByb3BlcnR5UnVsZXMgPSBbXTtcbiAgICB0aGlzLmxvY2FsQ2xhc3NOYW1lc01hcCA9IG5ldyBNYXAobG9jYWxDbGFzc05hbWVzLm1hcChsb2NhbENsYXNzTmFtZSA9PiBbbG9jYWxDbGFzc05hbWUsIGxvY2FsQ2xhc3NOYW1lXSkpO1xuICAgIHRoaXMubG9jYWxDbGFzc05hbWVzU2VhcmNoID0gbmV3IEFob0NvcmFzaWNrKGxvY2FsQ2xhc3NOYW1lcyk7XG4gICAgdGhpcy5sYXllcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBDbGFzcyBsaXN0IGNvbXBvc2l0aW9ucyBzaG91bGQgYmUgcHJpb3J0aXplZCBieSBOZXdlciA+IE9sZGVyXG4gICAgLy8gVGhlcmVmb3JlIHdlIHJldmVyc2UgdGhlIGFycmF5IGFzIHRoZXkgYXJlIGFkZGVkIGluIHNlcXVlbmNlXG4gICAgdGhpcy5jb21wb3NlZENsYXNzTGlzdHMgPSBjb21wb3NlZENsYXNzTGlzdHMubWFwKF9yZWYgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgY2xhc3NMaXN0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgIHJlZ2V4OiBSZWdFeHAoXCIoXCIuY29uY2F0KGNsYXNzTGlzdCwgXCIpXCIpLCAnZycpXG4gICAgICB9O1xuICAgIH0pLnJldmVyc2UoKTtcbiAgfVxuICBwcm9jZXNzQ3NzT2JqKHJvb3QpIHtcbiAgICBpZiAocm9vdC50eXBlID09PSAnZm9udEZhY2UnKSB7XG4gICAgICB0aGlzLmZvbnRGYWNlUnVsZXMucHVzaChyb290LnJ1bGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICB0aGlzLnByb3BlcnR5UnVsZXMucHVzaChyb290KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3QudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJvb3QucnVsZSA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyb290LnJ1bGUpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIHZhciBba2V5ZnJhbWUsIHJ1bGVdID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBba2V5ZnJhbWUsIHRoaXMudHJhbnNmb3JtVmFycyh0aGlzLnRyYW5zZm9ybVByb3BlcnRpZXMocnVsZSkpXTtcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMua2V5ZnJhbWVzUnVsZXMucHVzaChyb290KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyQ29uZGl0aW9uYWxSdWxlc2V0ID0gbmV3IENvbmRpdGlvbmFsUnVsZXNldCgpO1xuICAgIGlmIChyb290LnR5cGUgPT09ICdsYXllcicpIHtcbiAgICAgIHZhciBsYXllckRlZmluaXRpb24gPSBcIkBsYXllciBcIi5jb25jYXQocm9vdC5uYW1lKTtcbiAgICAgIHRoaXMuYWRkTGF5ZXIoW2xheWVyRGVmaW5pdGlvbl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgbWFpbiBzdHlsZXNcbiAgICAgIHZhciBtYWluUnVsZSA9IG9taXQocm9vdC5ydWxlLCBzcGVjaWFsS2V5cyk7XG4gICAgICB0aGlzLmFkZFJ1bGUoe1xuICAgICAgICBzZWxlY3Rvcjogcm9vdC5zZWxlY3RvcixcbiAgICAgICAgcnVsZTogbWFpblJ1bGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy50cmFuc2Zvcm1MYXllcihyb290LCByb290LnJ1bGVbJ0BsYXllciddKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWVkaWEocm9vdCwgcm9vdC5ydWxlWydAbWVkaWEnXSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybVN1cHBvcnRzKHJvb3QsIHJvb3QucnVsZVsnQHN1cHBvcnRzJ10pO1xuICAgICAgdGhpcy50cmFuc2Zvcm1Db250YWluZXIocm9vdCwgcm9vdC5ydWxlWydAY29udGFpbmVyJ10pO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIHJvb3QucnVsZSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCByb290LnJ1bGUpO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlQ29uZGl0aW9uYWxSdWxlc2V0ID0gdGhpcy5jb25kaXRpb25hbFJ1bGVzZXRzW3RoaXMuY29uZGl0aW9uYWxSdWxlc2V0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWFjdGl2ZUNvbmRpdGlvbmFsUnVsZXNldC5tZXJnZUlmQ29tcGF0aWJsZSh0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpKSB7XG4gICAgICAvLyBSdWxlc2V0IG1lcmdlIGZhaWxlZCBkdWUgdG8gaW5jb21wYXRpYmlsaXR5LiBXZSBub3cgZGVvcHQgYnkgc3RhcnRpbmcgYSBmcmVzaCBDb25kaXRpb25hbFJ1bGVzZXRcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxSdWxlc2V0cy5wdXNoKHRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCk7XG4gICAgfVxuICB9XG4gIGFkZENvbmRpdGlvbmFsUnVsZShjc3NSdWxlLCBjb25kaXRpb25zKSB7XG4gICAgLy8gUnVuIGB0cmFuc2Zvcm1Qcm9wZXJ0aWVzYCBiZWZvcmUgYHRyYW5zZm9ybVZhcnNgIGFzIHdlIGRvbid0IHdhbnQgdG8gcGl4ZWxpZnkgQ1NTIFZhcnNcbiAgICB2YXIgcnVsZSA9IHRoaXMudHJhbnNmb3JtVmFycyh0aGlzLnRyYW5zZm9ybVByb3BlcnRpZXMoY3NzUnVsZS5ydWxlKSk7XG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy50cmFuc2Zvcm1TZWxlY3Rvcihjc3NSdWxlLnNlbGVjdG9yKTtcbiAgICBpZiAoIXRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgYWRkIGNvbmRpdGlvbmFsIHJ1bGVcIik7XG4gICAgfVxuICAgIHZhciBjb25kaXRpb25RdWVyeSA9IGNvbmRpdGlvbnNbY29uZGl0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcGFyZW50Q29uZGl0aW9ucyA9IGNvbmRpdGlvbnMuc2xpY2UoMCwgY29uZGl0aW9ucy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQuYWRkUnVsZSh7XG4gICAgICBzZWxlY3RvcixcbiAgICAgIHJ1bGVcbiAgICB9LCBjb25kaXRpb25RdWVyeSwgcGFyZW50Q29uZGl0aW9ucyk7XG4gIH1cbiAgYWRkUnVsZShjc3NSdWxlKSB7XG4gICAgLy8gUnVuIGB0cmFuc2Zvcm1Qcm9wZXJ0aWVzYCBiZWZvcmUgYHRyYW5zZm9ybVZhcnNgIGFzIHdlIGRvbid0IHdhbnQgdG8gcGl4ZWxpZnkgQ1NTIFZhcnNcbiAgICB2YXIgcnVsZSA9IHRoaXMudHJhbnNmb3JtVmFycyh0aGlzLnRyYW5zZm9ybVByb3BlcnRpZXMoY3NzUnVsZS5ydWxlKSk7XG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy50cmFuc2Zvcm1TZWxlY3Rvcihjc3NSdWxlLnNlbGVjdG9yKTtcbiAgICB0aGlzLnJ1bGVzLnB1c2goe1xuICAgICAgc2VsZWN0b3IsXG4gICAgICBydWxlXG4gICAgfSk7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB2YXIgdW5pcXVlTGF5ZXJLZXkgPSBsYXllci5qb2luKCcgLSAnKTtcbiAgICB0aGlzLmxheWVycy5zZXQodW5pcXVlTGF5ZXJLZXksIGxheWVyKTtcbiAgfVxuICB0cmFuc2Zvcm1Qcm9wZXJ0aWVzKGNzc1J1bGUpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Db250ZW50KHRoaXMucGl4ZWxpZnlQcm9wZXJ0aWVzKGNzc1J1bGUpKTtcbiAgfVxuICBwaXhlbGlmeVByb3BlcnRpZXMoY3NzUnVsZSkge1xuICAgIGZvckVhY2goY3NzUnVsZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICFVTklUTEVTU1trZXldKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQW55IGlkZWFzP1xuICAgICAgICBjc3NSdWxlW2tleV0gPSBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3NzUnVsZTtcbiAgfVxuICB0cmFuc2Zvcm1WYXJzKF9yZWYzKSB7XG4gICAgdmFyIHtcbiAgICAgICAgdmFyc1xuICAgICAgfSA9IF9yZWYzLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgX2V4Y2x1ZGVkKTtcbiAgICBpZiAoIXZhcnMpIHtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG1hcEtleXModmFycywgKF92YWx1ZSwga2V5KSA9PiBnZXRWYXJOYW1lKGtleSkpKSwgcmVzdCk7XG4gIH1cbiAgdHJhbnNmb3JtQ29udGVudChfcmVmNCkge1xuICAgIHZhciB7XG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH0gPSBfcmVmNCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjQsIF9leGNsdWRlZDIpO1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBmYWxsYmFjayBhcnJheXM6XG4gICAgdmFyIGNvbnRlbnRBcnJheSA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICBjb250ZW50OiBjb250ZW50QXJyYXkubWFwKHZhbHVlID0+XG4gICAgICAvLyBUaGlzIGxvZ2ljIHdhcyBhZGFwdGVkIGZyb20gU3RpdGNoZXMgOilcbiAgICAgIHZhbHVlICYmICh2YWx1ZS5pbmNsdWRlcygnXCInKSB8fCB2YWx1ZS5pbmNsdWRlcyhcIidcIikgfHwgL14oW0EtWmEtelxcLV0rXFwoW15dKnxbXl0qLXF1b3RlfGluaGVyaXR8aW5pdGlhbHxub25lfG5vcm1hbHxyZXZlcnR8dW5zZXQpKFxcc3wkKS8udGVzdCh2YWx1ZSkpID8gdmFsdWUgOiBcIlxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSlcbiAgICB9LCByZXN0KTtcbiAgfVxuICB0cmFuc2Zvcm1DbGFzc25hbWUoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBcIi5cIi5jb25jYXQoY3NzZXNjKGlkZW50aWZpZXIsIHtcbiAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuICB0cmFuc2Zvcm1TZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIC8vIE1hcCBjbGFzcyBsaXN0IGNvbXBvc2l0aW9ucyB0byBzaW5nbGUgaWRlbnRpZmllcnNcbiAgICB2YXIgdHJhbnNmb3JtZWRTZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGlkZW50aWZpZXIpIHtcbiAgICAgIHRyYW5zZm9ybWVkU2VsZWN0b3IgPSB0cmFuc2Zvcm1lZFNlbGVjdG9yLnJlcGxhY2UocmVnZXgsICgpID0+IHtcbiAgICAgICAgbWFya0NvbXBvc2l0aW9uVXNlZChpZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIHtcbiAgICAgIGlkZW50aWZpZXIsXG4gICAgICByZWdleFxuICAgIH0gb2YgdGhpcy5jb21wb3NlZENsYXNzTGlzdHMpIHtcbiAgICAgIF9sb29wKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2NhbENsYXNzTmFtZXNNYXAuaGFzKHRyYW5zZm9ybWVkU2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1DbGFzc25hbWUodHJhbnNmb3JtZWRTZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gdGhpcy5sb2NhbENsYXNzTmFtZXNTZWFyY2guc2VhcmNoKHRyYW5zZm9ybWVkU2VsZWN0b3IpO1xuICAgIHZhciBsYXN0UmVwbGFjZUluZGV4ID0gdHJhbnNmb3JtZWRTZWxlY3Rvci5sZW5ndGg7XG5cbiAgICAvLyBQZXJmb3JtIHJlcGxhY2VtZW50cyBiYWNrd2FyZHMgdG8gc2ltcGxpZnkgaW5kZXggaGFuZGxpbmdcbiAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIFtlbmRJbmRleCwgW2ZpcnN0TWF0Y2hdXSA9IHJlc3VsdHNbaV07XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGVuZEluZGV4IC0gZmlyc3RNYXRjaC5sZW5ndGggKyAxO1xuXG4gICAgICAvLyBDbGFzcyBuYW1lcyBjYW4gYmUgc3Vic3RyaW5ncyBvZiBvdGhlciBjbGFzcyBuYW1lc1xuICAgICAgLy8gZS5nLiAnXzFnMXB0em8xJyBhbmQgJ18xZzFwdHpvMTAnXG4gICAgICAvL1xuICAgICAgLy8gQWRkaXRpb25hbGx5LCBjb25jYXRlbmF0ZWQgY2xhc3NuYW1lcyBjYW4gY29udGFpbiBzdWJzdHJpbmdzIGVxdWFsIHRvIG90aGVyIGNsYXNzbmFtZXNcbiAgICAgIC8vIGUuZy4gJyYmJyB3aGVyZSAnJicgaXMgJ2RlYnVnTmFtZV9oYXNoMScgYW5kICdkZWJ1Z05hbWVfaGFzaDFkJyBpcyBhbHNvIGEgbG9jYWwgY2xhc3NuYW1lXG4gICAgICAvLyBCZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzZWxlY3RvciwgdGhpcyB3b3VsZCBsb29rIGxpa2UgYGRlYnVnTmFtZV9oYXNoMWRlYnVnTmFtZV9oYXNoMWBcbiAgICAgIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBzdWJzdHJpbmcgYGRlYnVnTmFtZV9oYXNoMWRg4oCZLlxuICAgICAgLy9cbiAgICAgIC8vIEluIGVpdGhlciBvZiB0aGVzZSBjYXNlcywgdGhlIGxhc3QgcmVwbGFjZSBpbmRleCB3aWxsIG9jY3VyIGVpdGhlciBiZWZvcmUgb3Igd2l0aGluIHRoZVxuICAgICAgLy8gY3VycmVudCByZXBsYWNlbWVudCByYW5nZSAoZnJvbSBgc3RhcnRJbmRleGAgdG8gYGVuZEluZGV4YCkuXG4gICAgICAvLyBJZiB0aGlzIG9jY3Vycywgd2Ugc2tpcCB0aGUgcmVwbGFjZW1lbnQgdG8gYXZvaWQgdHJhbnNmb3JtaW5nIHRoZSBzZWxlY3RvciBpbmNvcnJlY3RseS5cbiAgICAgIHZhciBza2lwUmVwbGFjZW1lbnQgPSBsYXN0UmVwbGFjZUluZGV4IDw9IGVuZEluZGV4O1xuICAgICAgaWYgKHNraXBSZXBsYWNlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RSZXBsYWNlSW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgICAvLyBJZiBjbGFzcyBuYW1lcyBhbHJlYWR5IHN0YXJ0cyB3aXRoIGEgJy4nIHRoZW4gc2tpcFxuICAgICAgaWYgKHRyYW5zZm9ybWVkU2VsZWN0b3Jbc3RhcnRJbmRleCAtIDFdICE9PSAnLicpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRTZWxlY3RvciA9IHJlcGxhY2VCZXR3ZWVuSW5kZXhlcyh0cmFuc2Zvcm1lZFNlbGVjdG9yLCBzdGFydEluZGV4LCBlbmRJbmRleCArIDEsIHRoaXMudHJhbnNmb3JtQ2xhc3NuYW1lKGZpcnN0TWF0Y2gpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkU2VsZWN0b3I7XG4gIH1cbiAgdHJhbnNmb3JtU2VsZWN0b3JzKHJvb3QsIHJ1bGUsIGNvbmRpdGlvbnMpIHtcbiAgICBmb3JFYWNoKHJ1bGUuc2VsZWN0b3JzLCAoc2VsZWN0b3JSdWxlLCBzZWxlY3RvcikgPT4ge1xuICAgICAgaWYgKHJvb3QudHlwZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvcnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBcIi5jb25jYXQocm9vdC50eXBlID09PSAnZ2xvYmFsJyA/ICdcImdsb2JhbFN0eWxlXCInIDogJ1wic2VsZWN0b3JzXCInKSk7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNmb3JtZWRTZWxlY3RvciA9IHRoaXMudHJhbnNmb3JtU2VsZWN0b3Ioc2VsZWN0b3IucmVwbGFjZShSZWdFeHAoJyYnLCAnZycpLCByb290LnNlbGVjdG9yKSk7XG4gICAgICB2YWxpZGF0ZVNlbGVjdG9yKHRyYW5zZm9ybWVkU2VsZWN0b3IsIHJvb3Quc2VsZWN0b3IpO1xuICAgICAgdmFyIHJ1bGUgPSB7XG4gICAgICAgIHNlbGVjdG9yOiB0cmFuc2Zvcm1lZFNlbGVjdG9yLFxuICAgICAgICBydWxlOiBvbWl0KHNlbGVjdG9yUnVsZSwgc3BlY2lhbEtleXMpXG4gICAgICB9O1xuICAgICAgaWYgKGNvbmRpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUocnVsZSwgY29uZGl0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0b3JSb290ID0ge1xuICAgICAgICB0eXBlOiAnc2VsZWN0b3InLFxuICAgICAgICBzZWxlY3RvcjogdHJhbnNmb3JtZWRTZWxlY3RvcixcbiAgICAgICAgcnVsZTogc2VsZWN0b3JSdWxlXG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2Zvcm1MYXllcihzZWxlY3RvclJvb3QsIHNlbGVjdG9yUnVsZVsnQGxheWVyJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TdXBwb3J0cyhzZWxlY3RvclJvb3QsIHNlbGVjdG9yUnVsZVsnQHN1cHBvcnRzJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1NZWRpYShzZWxlY3RvclJvb3QsIHNlbGVjdG9yUnVsZVsnQG1lZGlhJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1Db250YWluZXIoc2VsZWN0b3JSb290LCBzZWxlY3RvclJ1bGVbJ0Bjb250YWluZXInXSwgY29uZGl0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNmb3JtTWVkaWEocm9vdCwgcnVsZXMpIHtcbiAgICB2YXIgcGFyZW50Q29uZGl0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICB2YXIgX3RoaXMkY3VyckNvbmRpdGlvbmFsO1xuICAgICAgKF90aGlzJGN1cnJDb25kaXRpb25hbCA9IHRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCkgPT09IG51bGwgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsID09PSB2b2lkIDAgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsLmFkZENvbmRpdGlvblByZWNlZGVuY2UocGFyZW50Q29uZGl0aW9ucywgT2JqZWN0LmtleXMocnVsZXMpLm1hcChxdWVyeSA9PiBcIkBtZWRpYSBcIi5jb25jYXQocXVlcnkpKSk7XG4gICAgICBmb3IgKHZhciBbcXVlcnksIG1lZGlhUnVsZV0gb2YgT2JqZWN0LmVudHJpZXMocnVsZXMpKSB7XG4gICAgICAgIHZhciBtZWRpYVF1ZXJ5ID0gXCJAbWVkaWEgXCIuY29uY2F0KHF1ZXJ5KTtcbiAgICAgICAgdmFsaWRhdGVNZWRpYVF1ZXJ5KG1lZGlhUXVlcnkpO1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFsuLi5wYXJlbnRDb25kaXRpb25zLCBtZWRpYVF1ZXJ5XTtcbiAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUoe1xuICAgICAgICAgIHNlbGVjdG9yOiByb290LnNlbGVjdG9yLFxuICAgICAgICAgIHJ1bGU6IG9taXQobWVkaWFSdWxlLCBzcGVjaWFsS2V5cylcbiAgICAgICAgfSwgY29uZGl0aW9ucyk7XG4gICAgICAgIGlmIChyb290LnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNpbXBsZVBzZXVkb3Mocm9vdCwgbWVkaWFSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCBtZWRpYVJ1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTGF5ZXIocm9vdCwgbWVkaWFSdWxlWydAbGF5ZXInXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3VwcG9ydHMocm9vdCwgbWVkaWFSdWxlWydAc3VwcG9ydHMnXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGFpbmVyKHJvb3QsIG1lZGlhUnVsZVsnQGNvbnRhaW5lciddLCBjb25kaXRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtQ29udGFpbmVyKHJvb3QsIHJ1bGVzKSB7XG4gICAgdmFyIHBhcmVudENvbmRpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIGlmIChydWxlcykge1xuICAgICAgdmFyIF90aGlzJGN1cnJDb25kaXRpb25hbDI7XG4gICAgICAoX3RoaXMkY3VyckNvbmRpdGlvbmFsMiA9IHRoaXMuY3VyckNvbmRpdGlvbmFsUnVsZXNldCkgPT09IG51bGwgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsMiA9PT0gdm9pZCAwIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbDIuYWRkQ29uZGl0aW9uUHJlY2VkZW5jZShwYXJlbnRDb25kaXRpb25zLCBPYmplY3Qua2V5cyhydWxlcykubWFwKHF1ZXJ5ID0+IFwiQGNvbnRhaW5lciBcIi5jb25jYXQocXVlcnkpKSk7XG4gICAgICBmb3JFYWNoKHJ1bGVzLCAoY29udGFpbmVyUnVsZSwgcXVlcnkpID0+IHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclF1ZXJ5ID0gXCJAY29udGFpbmVyIFwiLmNvbmNhdChxdWVyeSk7XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gWy4uLnBhcmVudENvbmRpdGlvbnMsIGNvbnRhaW5lclF1ZXJ5XTtcbiAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUoe1xuICAgICAgICAgIHNlbGVjdG9yOiByb290LnNlbGVjdG9yLFxuICAgICAgICAgIHJ1bGU6IG9taXQoY29udGFpbmVyUnVsZSwgc3BlY2lhbEtleXMpXG4gICAgICAgIH0sIGNvbmRpdGlvbnMpO1xuICAgICAgICBpZiAocm9vdC50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIGNvbnRhaW5lclJ1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtU2VsZWN0b3JzKHJvb3QsIGNvbnRhaW5lclJ1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTGF5ZXIocm9vdCwgY29udGFpbmVyUnVsZVsnQGxheWVyJ10sIGNvbmRpdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN1cHBvcnRzKHJvb3QsIGNvbnRhaW5lclJ1bGVbJ0BzdXBwb3J0cyddLCBjb25kaXRpb25zKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NZWRpYShyb290LCBjb250YWluZXJSdWxlWydAbWVkaWEnXSwgY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtTGF5ZXIocm9vdCwgcnVsZXMpIHtcbiAgICB2YXIgcGFyZW50Q29uZGl0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICB2YXIgX3RoaXMkY3VyckNvbmRpdGlvbmFsMztcbiAgICAgIChfdGhpcyRjdXJyQ29uZGl0aW9uYWwzID0gdGhpcy5jdXJyQ29uZGl0aW9uYWxSdWxlc2V0KSA9PT0gbnVsbCB8fCBfdGhpcyRjdXJyQ29uZGl0aW9uYWwzID09PSB2b2lkIDAgfHwgX3RoaXMkY3VyckNvbmRpdGlvbmFsMy5hZGRDb25kaXRpb25QcmVjZWRlbmNlKHBhcmVudENvbmRpdGlvbnMsIE9iamVjdC5rZXlzKHJ1bGVzKS5tYXAobmFtZSA9PiBcIkBsYXllciBcIi5jb25jYXQobmFtZSkpKTtcbiAgICAgIGZvckVhY2gocnVsZXMsIChsYXllclJ1bGUsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbLi4ucGFyZW50Q29uZGl0aW9ucywgXCJAbGF5ZXIgXCIuY29uY2F0KG5hbWUpXTtcbiAgICAgICAgdGhpcy5hZGRMYXllcihjb25kaXRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUoe1xuICAgICAgICAgIHNlbGVjdG9yOiByb290LnNlbGVjdG9yLFxuICAgICAgICAgIHJ1bGU6IG9taXQobGF5ZXJSdWxlLCBzcGVjaWFsS2V5cylcbiAgICAgICAgfSwgY29uZGl0aW9ucyk7XG4gICAgICAgIGlmIChyb290LnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNpbXBsZVBzZXVkb3Mocm9vdCwgbGF5ZXJSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCBsYXllclJ1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWVkaWEocm9vdCwgbGF5ZXJSdWxlWydAbWVkaWEnXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3VwcG9ydHMocm9vdCwgbGF5ZXJSdWxlWydAc3VwcG9ydHMnXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGFpbmVyKHJvb3QsIGxheWVyUnVsZVsnQGNvbnRhaW5lciddLCBjb25kaXRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1TdXBwb3J0cyhyb290LCBydWxlcykge1xuICAgIHZhciBwYXJlbnRDb25kaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgIHZhciBfdGhpcyRjdXJyQ29uZGl0aW9uYWw0O1xuICAgICAgKF90aGlzJGN1cnJDb25kaXRpb25hbDQgPSB0aGlzLmN1cnJDb25kaXRpb25hbFJ1bGVzZXQpID09PSBudWxsIHx8IF90aGlzJGN1cnJDb25kaXRpb25hbDQgPT09IHZvaWQgMCB8fCBfdGhpcyRjdXJyQ29uZGl0aW9uYWw0LmFkZENvbmRpdGlvblByZWNlZGVuY2UocGFyZW50Q29uZGl0aW9ucywgT2JqZWN0LmtleXMocnVsZXMpLm1hcChxdWVyeSA9PiBcIkBzdXBwb3J0cyBcIi5jb25jYXQocXVlcnkpKSk7XG4gICAgICBmb3JFYWNoKHJ1bGVzLCAoc3VwcG9ydHNSdWxlLCBxdWVyeSkgPT4ge1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFsuLi5wYXJlbnRDb25kaXRpb25zLCBcIkBzdXBwb3J0cyBcIi5jb25jYXQocXVlcnkpXTtcbiAgICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJ1bGUoe1xuICAgICAgICAgIHNlbGVjdG9yOiByb290LnNlbGVjdG9yLFxuICAgICAgICAgIHJ1bGU6IG9taXQoc3VwcG9ydHNSdWxlLCBzcGVjaWFsS2V5cylcbiAgICAgICAgfSwgY29uZGl0aW9ucyk7XG4gICAgICAgIGlmIChyb290LnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNpbXBsZVBzZXVkb3Mocm9vdCwgc3VwcG9ydHNSdWxlLCBjb25kaXRpb25zKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybVNlbGVjdG9ycyhyb290LCBzdXBwb3J0c1J1bGUsIGNvbmRpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTGF5ZXIocm9vdCwgc3VwcG9ydHNSdWxlWydAbGF5ZXInXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWVkaWEocm9vdCwgc3VwcG9ydHNSdWxlWydAbWVkaWEnXSwgY29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGFpbmVyKHJvb3QsIHN1cHBvcnRzUnVsZVsnQGNvbnRhaW5lciddLCBjb25kaXRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1TaW1wbGVQc2V1ZG9zKHJvb3QsIHJ1bGUsIGNvbmRpdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMocnVsZSkpIHtcbiAgICAgIC8vIFByb2Nlc3Mgc2ltcGxlIHBzZXVkb3NcbiAgICAgIGlmIChzaW1wbGVQc2V1ZG9Mb29rdXBba2V5XSkge1xuICAgICAgICBpZiAocm9vdC50eXBlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2ltcGxlIHBzZXVkb3MgYXJlIG5vdCB2YWxpZCBpbiBcIi5jb25jYXQocm9vdC50eXBlID09PSAnZ2xvYmFsJyA/ICdcImdsb2JhbFN0eWxlXCInIDogJ1wic2VsZWN0b3JzXCInKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbmRpdGlvbmFsUnVsZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogXCJcIi5jb25jYXQocm9vdC5zZWxlY3RvcikuY29uY2F0KGtleSksXG4gICAgICAgICAgICBydWxlOiBydWxlW2tleV1cbiAgICAgICAgICB9LCBjb25kaXRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZFJ1bGUoe1xuICAgICAgICAgICAgY29uZGl0aW9ucyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcIlwiLmNvbmNhdChyb290LnNlbGVjdG9yKS5jb25jYXQoa2V5KSxcbiAgICAgICAgICAgIHJ1bGU6IHJ1bGVba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvQ3NzKCkge1xuICAgIHZhciBjc3MgPSBbXTtcblxuICAgIC8vIFJlbmRlciBmb250LWZhY2UgcnVsZXNcbiAgICBmb3IgKHZhciBmb250RmFjZVJ1bGUgb2YgdGhpcy5mb250RmFjZVJ1bGVzKSB7XG4gICAgICBjc3MucHVzaChyZW5kZXJDc3Moe1xuICAgICAgICAnQGZvbnQtZmFjZSc6IGZvbnRGYWNlUnVsZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBwcm9wZXJ0eSBydWxlc1xuICAgIGZvciAodmFyIHByb3BlcnR5IG9mIHRoaXMucHJvcGVydHlSdWxlcykge1xuICAgICAgY3NzLnB1c2gocmVuZGVyQ3NzKHtcbiAgICAgICAgW1wiQHByb3BlcnR5IFwiLmNvbmNhdChwcm9wZXJ0eS5uYW1lKV06IHByb3BlcnR5LnJ1bGVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIga2V5ZnJhbWVzXG4gICAgZm9yICh2YXIga2V5ZnJhbWUgb2YgdGhpcy5rZXlmcmFtZXNSdWxlcykge1xuICAgICAgY3NzLnB1c2gocmVuZGVyQ3NzKHtcbiAgICAgICAgW1wiQGtleWZyYW1lcyBcIi5jb25jYXQoa2V5ZnJhbWUubmFtZSldOiBrZXlmcmFtZS5ydWxlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGxheWVyIGRlZmluaXRpb25zXG4gICAgZm9yICh2YXIgbGF5ZXIgb2YgdGhpcy5sYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBbZGVmaW5pdGlvbiwgLi4ubmVzdGluZ10gPSBsYXllci5yZXZlcnNlKCk7XG4gICAgICB2YXIgY3NzT2JqID0ge1xuICAgICAgICBbZGVmaW5pdGlvbl06IERFQ0xBUkFUSU9OXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgcGFydCBvZiBuZXN0aW5nKSB7XG4gICAgICAgIGNzc09iaiA9IHtcbiAgICAgICAgICBbcGFydF06IGNzc09ialxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3NzLnB1c2gocmVuZGVyQ3NzKGNzc09iaikpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB1bmNvbmRpdGlvbmFsIHJ1bGVzXG4gICAgZm9yICh2YXIgcnVsZSBvZiB0aGlzLnJ1bGVzKSB7XG4gICAgICBjc3MucHVzaChyZW5kZXJDc3Moe1xuICAgICAgICBbcnVsZS5zZWxlY3Rvcl06IHJ1bGUucnVsZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBjb25kaXRpb25hbCBydWxlc1xuICAgIGZvciAodmFyIGNvbmRpdGlvbmFsUnVsZXNldCBvZiB0aGlzLmNvbmRpdGlvbmFsUnVsZXNldHMpIHtcbiAgICAgIGZvciAodmFyIGNvbmRpdGlvbmFsUnVsZSBvZiBjb25kaXRpb25hbFJ1bGVzZXQucmVuZGVyVG9BcnJheSgpKSB7XG4gICAgICAgIGNzcy5wdXNoKHJlbmRlckNzcyhjb25kaXRpb25hbFJ1bGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzcy5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckNzcyh2KSB7XG4gIHZhciBpbmRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICB2YXIgcnVsZXMgPSBbXTtcbiAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB2W2tleV07XG4gICAgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBydWxlcy5wdXNoKC4uLnZhbHVlLm1hcCh2ID0+IHJlbmRlckNzcyh7XG4gICAgICAgIFtrZXldOiB2XG4gICAgICB9LCBpbmRlbnQpKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgaXNFbXB0eSA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDA7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgcnVsZXMucHVzaChcIlwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdChrZXksIFwiIHtcXG5cIikuY29uY2F0KHJlbmRlckNzcyh2YWx1ZSwgaW5kZW50ICsgRE9VQkxFX1NQQUNFKSwgXCJcXG5cIikuY29uY2F0KGluZGVudCwgXCJ9XCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBERUNMQVJBVElPTikge1xuICAgICAgcnVsZXMucHVzaChcIlwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdChrZXksIFwiO1wiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bGVzLnB1c2goXCJcIi5jb25jYXQoaW5kZW50KS5jb25jYXQoa2V5LnN0YXJ0c1dpdGgoJy0tJykgPyBrZXkgOiBkYXNoaWZ5KGtleSksIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcIjtcIikpO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKHYpKSB7XG4gICAgX2xvb3AyKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJ1bGVzLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ3NzKF9yZWY1KSB7XG4gIHZhciB7XG4gICAgbG9jYWxDbGFzc05hbWVzLFxuICAgIGNzc09ianMsXG4gICAgY29tcG9zZWRDbGFzc0xpc3RzXG4gIH0gPSBfcmVmNTtcbiAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgU3R5bGVzaGVldChsb2NhbENsYXNzTmFtZXMsIGNvbXBvc2VkQ2xhc3NMaXN0cyk7XG4gIGZvciAodmFyIHJvb3Qgb2YgY3NzT2Jqcykge1xuICAgIHN0eWxlc2hlZXQucHJvY2Vzc0Nzc09iaihyb290KTtcbiAgfVxuICByZXR1cm4gc3R5bGVzaGVldC50b0NzcygpO1xufVxuXG5leHBvcnQgeyBfb2JqZWN0U3ByZWFkMiBhcyBfLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgYXMgYSwgZHVkdXBlQW5kSm9pbkNsYXNzTGlzdCBhcyBkLCB0cmFuc2Zvcm1Dc3MgYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertVarName: () => (/* binding */ assertVarName),\n/* harmony export */   assignVars: () => (/* binding */ assignVars),\n/* harmony export */   composeStyles: () => (/* binding */ composeStyles),\n/* harmony export */   createContainer: () => (/* binding */ createContainer),\n/* harmony export */   createGlobalTheme: () => (/* binding */ createGlobalTheme),\n/* harmony export */   createGlobalThemeContract: () => (/* binding */ createGlobalThemeContract),\n/* harmony export */   createGlobalVar: () => (/* binding */ createGlobalVar),\n/* harmony export */   createTheme: () => (/* binding */ createTheme),\n/* harmony export */   createThemeContract: () => (/* binding */ createThemeContract),\n/* harmony export */   createVar: () => (/* binding */ createVar),\n/* harmony export */   createViewTransition: () => (/* binding */ createViewTransition),\n/* harmony export */   fallbackVar: () => (/* binding */ fallbackVar),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   generateIdentifier: () => (/* binding */ generateIdentifier),\n/* harmony export */   globalFontFace: () => (/* binding */ globalFontFace),\n/* harmony export */   globalKeyframes: () => (/* binding */ globalKeyframes),\n/* harmony export */   globalLayer: () => (/* binding */ globalLayer),\n/* harmony export */   globalStyle: () => (/* binding */ globalStyle),\n/* harmony export */   keyframes: () => (/* binding */ keyframes),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   style: () => (/* binding */ style),\n/* harmony export */   styleVariants: () => (/* binding */ styleVariants)\n/* harmony export */ });\n/* harmony import */ var _injectStyles_dist_vanilla_extract_css_injectStyles_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../injectStyles/dist/vanilla-extract-css-injectStyles.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js\");\n/* harmony import */ var _transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformCss-0dba36bf.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n/* harmony import */ var _emotion_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/hash */ \"(ssr)/../node_modules/@emotion/hash/dist/emotion-hash.esm.js\");\n/* harmony import */ var _fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../fileScope/dist/vanilla-extract-css-fileScope.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lru-cache */ \"(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js\");\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cssesc */ \"(ssr)/../node_modules/cssesc/cssesc.js\");\n/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(cssesc__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var deep_object_diff__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! deep-object-diff */ \"(ssr)/../node_modules/deep-object-diff/mjs/index.js\");\n/* harmony import */ var picocolors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! picocolors */ \"(ssr)/../node_modules/picocolors/picocolors.js\");\n/* harmony import */ var picocolors__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(picocolors__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var modern_ahocorasick__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! modern-ahocorasick */ \"(ssr)/../node_modules/modern-ahocorasick/dist/index.js\");\n/* harmony import */ var media_query_parser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! media-query-parser */ \"(ssr)/../node_modules/media-query-parser/dist/media-query-parser.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar localClassNames = new Set();\nvar composedClassLists = [];\nvar bufferedCSSObjs = [];\nvar browserRuntimeAdapter = {\n  appendCss: cssObj => {\n    bufferedCSSObjs.push(cssObj);\n  },\n  registerClassName: className => {\n    localClassNames.add(className);\n  },\n  registerComposition: composition => {\n    composedClassLists.push(composition);\n  },\n  markCompositionUsed: () => {},\n  onEndFileScope: fileScope => {\n    var css = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)({\n      localClassNames: Array.from(localClassNames),\n      composedClassLists,\n      cssObjs: bufferedCSSObjs\n    }).join('\\n');\n    (0,_injectStyles_dist_vanilla_extract_css_injectStyles_esm_js__WEBPACK_IMPORTED_MODULE_0__.injectStyles)({\n      fileScope,\n      css\n    });\n    bufferedCSSObjs = [];\n  },\n  getIdentOption: () =>  false ? 0 : 'debug'\n};\nif (typeof window !== 'undefined') {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.setAdapterIfNotSet)(browserRuntimeAdapter);\n}\n\nvar getLastSlashBeforeIndex = (path, index) => {\n  var pathIndex = index - 1;\n  while (pathIndex >= 0) {\n    if (path[pathIndex] === '/') {\n      return pathIndex;\n    }\n    pathIndex--;\n  }\n  return -1;\n};\n\n/**\n * Assumptions:\n * - The path is always normalized to use posix file separators (/) (see `addFileScope`)\n * - The path is always relative to the project root, i.e. there will never be a leading slash (see `addFileScope`)\n * - As long as `.css` is there, we have a valid `.css.*` file path, because otherwise there wouldn't\n *   be a file scope to begin with\n *\n * The LRU cache we use can't cache undefined/null values, so we opt to return an empty string,\n * rather than using a custom Symbol or something similar.\n */\nvar _getDebugFileName = path => {\n  var file;\n  var lastIndexOfDotCss = path.lastIndexOf('.css');\n  if (lastIndexOfDotCss === -1) {\n    return '';\n  }\n  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);\n  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);\n\n  // There are no slashes, therefore theres no directory to extract\n  if (lastSlashIndex === -1) {\n    return file;\n  }\n  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);\n  // If secondLastSlashIndex is -1, it means that the path looks like `directory/file.css.ts`,\n  // in which case dir will still be sliced starting at 0, which is what we want\n  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);\n  var debugFileName = file !== 'index' ? file : dir;\n  return debugFileName;\n};\nvar memoizedGetDebugFileName = () => {\n  var cache = new lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n    max: 500\n  });\n  return path => {\n    var cachedResult = cache.get(path);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = _getDebugFileName(path);\n    cache.set(path, result);\n    return result;\n  };\n};\nvar getDebugFileName = memoizedGetDebugFileName();\n\nfunction getDevPrefix(_ref) {\n  var {\n    debugId,\n    debugFileName\n  } = _ref;\n  var parts = debugId ? [debugId.replace(/\\s/g, '_')] : [];\n  if (debugFileName) {\n    var {\n      filePath\n    } = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)();\n    var _debugFileName = getDebugFileName(filePath);\n\n    // debugFileName could be an empty string\n    if (_debugFileName) {\n      parts.unshift(_debugFileName);\n    }\n  }\n  return parts.join('_');\n}\nfunction normalizeIdentifier(identifier) {\n  return identifier.match(/^[0-9]/) ? \"_\".concat(identifier) : identifier;\n}\nfunction generateIdentifier(arg) {\n  var identOption = (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.getIdentOption)();\n  var {\n    debugId,\n    debugFileName = true\n  } = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, typeof arg === 'string' ? {\n    debugId: arg\n  } : null), typeof arg === 'object' ? arg : null);\n\n  // Convert ref count to base 36 for optimal hash lengths\n  var refCount = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getAndIncrementRefCounter)().toString(36);\n  var {\n    filePath,\n    packageName\n  } = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)();\n  var fileScopeHash = (0,_emotion_hash__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(packageName ? \"\".concat(packageName).concat(filePath) : filePath);\n  var identifier = \"\".concat(fileScopeHash).concat(refCount);\n  if (identOption === 'debug') {\n    var devPrefix = getDevPrefix({\n      debugId,\n      debugFileName\n    });\n    if (devPrefix) {\n      identifier = \"\".concat(devPrefix, \"__\").concat(identifier);\n    }\n    return normalizeIdentifier(identifier);\n  }\n  if (typeof identOption === 'function') {\n    identifier = identOption({\n      hash: identifier,\n      debugId,\n      filePath,\n      packageName\n    });\n    if (!identifier.match(/^[A-Z_][0-9A-Z_-]+$/i)) {\n      throw new Error(\"Identifier function returned invalid indentifier: \\\"\".concat(identifier, \"\\\"\"));\n    }\n    return identifier;\n  }\n  return normalizeIdentifier(identifier);\n}\n\nvar normaliseObject = obj => (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(obj, () => '');\nfunction validateContract(contract, tokens) {\n  var theDiff = (0,deep_object_diff__WEBPACK_IMPORTED_MODULE_5__.diff)(normaliseObject(contract), normaliseObject(tokens));\n  var valid = Object.keys(theDiff).length === 0;\n  return {\n    valid,\n    diffString: valid ? '' : renderDiff(contract, theDiff)\n  };\n}\nfunction diffLine(value, nesting, type) {\n  var whitespace = [...Array(nesting).keys()].map(() => '  ').join('');\n  var line = \"\".concat(type ? type : ' ').concat(whitespace).concat(value);\n  if (true) {\n    if (type === '-') {\n      return picocolors__WEBPACK_IMPORTED_MODULE_14___default().red(line);\n    }\n    if (type === '+') {\n      return picocolors__WEBPACK_IMPORTED_MODULE_14___default().green(line);\n    }\n  }\n  return line;\n}\nfunction renderDiff(orig, diff) {\n  var nesting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var lines = [];\n  if (nesting === 0) {\n    lines.push(diffLine('{', 0));\n  }\n  var innerNesting = nesting + 1;\n  var keys = Object.keys(diff).sort();\n  for (var key of keys) {\n    var value = diff[key];\n    if (!(key in orig)) {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '+'));\n    } else if (typeof value === 'object') {\n      lines.push(diffLine(\"\".concat(key, \": {\"), innerNesting));\n      lines.push(renderDiff(orig[key], diff[key], innerNesting));\n      lines.push(diffLine('}', innerNesting));\n    } else {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '-'));\n    }\n  }\n  if (nesting === 0) {\n    lines.push(diffLine('}', 0));\n  }\n  return lines.join('\\n');\n}\n\nvar buildPropertyRule = _ref => {\n  var {\n    syntax,\n    inherits,\n    initialValue\n  } = _ref;\n  return (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({\n    syntax: \"\\\"\".concat(Array.isArray(syntax) ? syntax.join(' | ') : syntax, \"\\\"\"),\n    inherits: inherits ? 'true' : 'false'\n  }, initialValue != null ? {\n    initialValue\n  } : {});\n};\nfunction createVar(debugIdOrDeclaration, debugId) {\n  var cssVarName = cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier({\n    debugId: typeof debugIdOrDeclaration === 'string' ? debugIdOrDeclaration : debugId,\n    debugFileName: false\n  }), {\n    isIdentifier: true\n  });\n  if (debugIdOrDeclaration && typeof debugIdOrDeclaration === 'object') {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'property',\n      name: \"--\".concat(cssVarName),\n      rule: buildPropertyRule(debugIdOrDeclaration)\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return \"var(--\".concat(cssVarName, \")\");\n}\nfunction createGlobalVar(name, declaration) {\n  if (declaration && typeof declaration === 'object') {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'property',\n      name: \"--\".concat(name),\n      rule: buildPropertyRule(declaration)\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return \"var(--\".concat(name, \")\");\n}\nfunction assertVarName(value) {\n  if (typeof value !== 'string' || !/^var\\(--.*\\)$/.test(value)) {\n    throw new Error(\"Invalid variable name: \".concat(value));\n  }\n}\nfunction fallbackVar() {\n  var finalValue = '';\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  values.reverse().forEach(value => {\n    if (finalValue === '') {\n      finalValue = String(value);\n    } else {\n      assertVarName(value);\n      finalValue = value.replace(/\\)$/, \", \".concat(finalValue, \")\"));\n    }\n  });\n  return finalValue;\n}\nfunction assignVars(varContract, tokens) {\n  var varSetters = {};\n  var {\n    valid,\n    diffString\n  } = validateContract(varContract, tokens);\n  if (!valid) {\n    throw new Error(\"Tokens don't match contract.\\n\".concat(diffString));\n  }\n  (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (value, path) => {\n    varSetters[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.get)(varContract, path)] = String(value);\n  });\n  return varSetters;\n}\nfunction createThemeContract(tokens) {\n  return (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (_value, path) => {\n    return createVar(path.join('-'));\n  });\n}\nfunction createGlobalThemeContract(tokens, mapFn) {\n  return (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_13__.walkObject)(tokens, (value, path) => {\n    var rawVarName = typeof mapFn === 'function' ? mapFn(value, path) : value;\n    var varName = typeof rawVarName === 'string' ? rawVarName.replace(/^\\-\\-/, '') : null;\n    if (typeof varName !== 'string' || varName !== cssesc__WEBPACK_IMPORTED_MODULE_4___default()(varName, {\n      isIdentifier: true\n    })) {\n      throw new Error(\"Invalid variable name for \\\"\".concat(path.join('.'), \"\\\": \").concat(varName));\n    }\n    return \"var(--\".concat(varName, \")\");\n  });\n}\n\nvar _excluded = [\"@layer\"];\nfunction createGlobalTheme(selector, arg2, arg3) {\n  var themeContractProvided = Boolean(arg3);\n  var tokenArg = themeContractProvided ? arg3 : arg2;\n  var {\n    layerName,\n    tokens\n  } = extractLayerFromTokens(tokenArg);\n  var themeContract = themeContractProvided ? arg2 : createThemeContract(tokens);\n  var rule = {\n    vars: assignVars(themeContract, tokens)\n  };\n  if (layerName) {\n    rule = {\n      '@layer': {\n        [layerName]: rule\n      }\n    };\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'global',\n    selector: selector,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  if (!themeContractProvided) {\n    return themeContract;\n  }\n}\nfunction createTheme(arg1, arg2, arg3) {\n  var themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(themeClassName, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  var vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);\n  return vars ? [themeClassName, vars] : themeClassName;\n}\nfunction extractLayerFromTokens(tokens) {\n  if ('@layer' in tokens) {\n    var {\n        '@layer': layerName\n      } = tokens,\n      rest = (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(tokens, _excluded);\n    return {\n      layerName,\n      tokens: rest\n    };\n  }\n  return {\n    tokens\n  };\n}\n\nvar _templateObject;\nfunction composedStyle(rules, debugId) {\n  var className = generateIdentifier(debugId);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(className, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  var classList = [];\n  var styleRules = [];\n  for (var rule of rules) {\n    if (typeof rule === 'string') {\n      classList.push(rule);\n    } else {\n      styleRules.push(rule);\n    }\n  }\n  var result = className;\n  if (classList.length > 0) {\n    result = \"\".concat(className, \" \").concat((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(classList));\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerComposition)({\n      identifier: className,\n      classList: result\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n    if (styleRules.length > 0) {\n      // If there are styles attached to this composition then it is\n      // always used and should never be removed\n      (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.markCompositionUsed)(className);\n    }\n  }\n  if (styleRules.length > 0) {\n    var _rule = deepmerge__WEBPACK_IMPORTED_MODULE_8___default().all(styleRules, {\n      // Replace arrays rather than merging\n      arrayMerge: (_, sourceArray) => sourceArray\n    });\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'local',\n      selector: className,\n      rule: _rule\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return result;\n}\nfunction style(rule, debugId) {\n  if (Array.isArray(rule)) {\n    return composedStyle(rule, debugId);\n  }\n  var className = generateIdentifier(debugId);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.registerClassName)(className, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'local',\n    selector: className,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return className;\n}\n\n/**\n * @deprecated The same functionality is now provided by the 'style' function when you pass it an array\n */\nfunction composeStyles() {\n  var compose = (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.hasFileScope)() ? composedStyle : _transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d;\n  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classNames[_key] = arguments[_key];\n  }\n  return compose(classNames);\n}\nfunction globalStyle(selector, rule) {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'global',\n    selector,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n}\nfunction fontFace(rule, debugId) {\n  var fontFamily = \"\\\"\".concat(cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier(debugId), {\n    quotes: 'double'\n  }), \"\\\"\");\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    if ('fontFamily' in singleRule) {\n      throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_templateObject || (_templateObject = (0,_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_6__._)([\"\\n      This function creates and returns a hashed font-family name, so the \\\"fontFamily\\\" property should not be provided.\\n    \\n      If you'd like to define a globally scoped custom font, you can use the \\\"globalFontFace\\\" function instead.\\n    \"]))));\n    }\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'fontFace',\n      rule: (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, singleRule), {}, {\n        fontFamily\n      })\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n  return fontFamily;\n}\nfunction globalFontFace(fontFamily, rule) {\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n      type: 'fontFace',\n      rule: (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, singleRule), {}, {\n        fontFamily\n      })\n    }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  }\n}\nfunction keyframes(rule, debugId) {\n  var name = cssesc__WEBPACK_IMPORTED_MODULE_4___default()(generateIdentifier(debugId), {\n    isIdentifier: true\n  });\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'keyframes',\n    name,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\nfunction globalKeyframes(name, rule) {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'keyframes',\n    name,\n    rule\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n}\nfunction styleVariants() {\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n    var _data = arguments.length <= 0 ? undefined : arguments[0];\n    var _mapData = arguments.length <= 1 ? undefined : arguments[1];\n    var _debugId = arguments.length <= 2 ? undefined : arguments[2];\n    var _classMap = {};\n    for (var _key2 in _data) {\n      _classMap[_key2] = style(_mapData(_data[_key2], _key2), _debugId ? \"\".concat(_debugId, \"_\").concat(_key2) : _key2);\n    }\n    return _classMap;\n  }\n  var styleMap = arguments.length <= 0 ? undefined : arguments[0];\n  var debugId = arguments.length <= 1 ? undefined : arguments[1];\n  var classMap = {};\n  for (var _key3 in styleMap) {\n    classMap[_key3] = style(styleMap[_key3], debugId ? \"\".concat(debugId, \"_\").concat(_key3) : _key3);\n  }\n  return classMap;\n}\n\n// createContainer is used for local scoping of CSS containers\n// For now it is mostly just an alias of generateIdentifier\nvar createContainer = debugId => generateIdentifier(debugId);\n\n// createViewTransition is used for locally scoping CSS view transitions\n// For now it is mostly just an alias of generateIdentifier\nvar createViewTransition = debugId => generateIdentifier(debugId);\n\nvar defaultLayerOptions = {};\nvar merge = (obj1, obj2) => (0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)((0,_transformCss_0dba36bf_esm_js__WEBPACK_IMPORTED_MODULE_1__._)({}, obj1), obj2);\nvar getLayerArgs = function getLayerArgs() {\n  var options = defaultLayerOptions;\n  var debugId = arguments.length <= 0 ? undefined : arguments[0];\n  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    options = merge(defaultLayerOptions, arguments.length <= 0 ? undefined : arguments[0]);\n    debugId = arguments.length <= 1 ? undefined : arguments[1];\n  }\n  return [options, debugId];\n};\nfunction layer() {\n  var [options, debugId] = getLayerArgs(...arguments);\n  var name = generateIdentifier(debugId);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'layer',\n    name\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\nfunction globalLayer() {\n  var [options, name] = getLayerArgs(...arguments);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_11__.appendCss)({\n    type: 'layer',\n    name\n  }, (0,_fileScope_dist_vanilla_extract_css_fileScope_esm_js__WEBPACK_IMPORTED_MODULE_12__.getFileScope)());\n  return name;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RjtBQUN3RDtBQUM0QjtBQUMvSTtBQUM4RjtBQUMxRjtBQUNzQjtBQUMvQjtBQUNZO0FBQ1o7QUFDMEQ7QUFDMUQ7QUFDTTtBQUNOO0FBQ1Y7QUFDVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0I7QUFDQSxjQUFjLGdFQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHdHQUFZO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLE1BQXFDLEdBQUcsQ0FBTztBQUN2RTtBQUNBO0FBQ0EsRUFBRSxxR0FBa0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLG1HQUFZO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUdBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLGdFQUFjLENBQUMsZ0VBQWMsR0FBRztBQUN0QztBQUNBLElBQUk7O0FBRUo7QUFDQSxpQkFBaUIsZ0hBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSxtR0FBWTtBQUNsQixzQkFBc0IseURBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixxRUFBVTtBQUN2QztBQUNBLGdCQUFnQixzREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQStCO0FBQ3JDO0FBQ0EsYUFBYSxzREFBTTtBQUNuQjtBQUNBO0FBQ0EsYUFBYSx3REFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QztBQUM3QztBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUyxnRUFBYztBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBTTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUVBQVU7QUFDWixlQUFlLDhEQUFHO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFVO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLHFFQUFVO0FBQ25CO0FBQ0E7QUFDQSxtREFBbUQsNkNBQU07QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0dBQWlCLGlCQUFpQixtR0FBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixhQUFhLGdFQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvR0FBaUIsWUFBWSxtR0FBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQXNCO0FBQ3BFLElBQUksc0dBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLLEVBQUUsbUdBQVk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzR0FBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFhO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0RkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvR0FBaUIsWUFBWSxtR0FBWTtBQUMzQyxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUdBQVkscUJBQXFCLDREQUFzQjtBQUN2RSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCLDZDQUFNO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBTSx1Q0FBdUMseUVBQXNCO0FBQ3pGO0FBQ0EsSUFBSSw0RkFBUztBQUNiO0FBQ0EsWUFBWSxnRUFBYyxDQUFDLGdFQUFjLEdBQUcsaUJBQWlCO0FBQzdEO0FBQ0EsT0FBTztBQUNQLEtBQUssRUFBRSxtR0FBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRGQUFTO0FBQ2I7QUFDQSxZQUFZLGdFQUFjLENBQUMsZ0VBQWMsR0FBRyxpQkFBaUI7QUFDN0Q7QUFDQSxPQUFPO0FBQ1AsS0FBSyxFQUFFLG1HQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQU07QUFDbkI7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1HQUFZO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnRUFBYyxDQUFDLGdFQUFjLEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0RkFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHLEVBQUUsbUdBQVk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRGQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUcsRUFBRSxtR0FBWTtBQUNqQjtBQUNBOztBQUVxViIsInNvdXJjZXMiOlsid2VicGFjazovL3prZGF0YXZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L2Nzcy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MuZXNtLmpzPzE1ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0U3R5bGVzIH0gZnJvbSAnLi4vaW5qZWN0U3R5bGVzL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1pbmplY3RTdHlsZXMuZXNtLmpzJztcbmltcG9ydCB7IHQgYXMgdHJhbnNmb3JtQ3NzLCBfIGFzIF9vYmplY3RTcHJlYWQyLCBhIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcywgZCBhcyBkdWR1cGVBbmRKb2luQ2xhc3NMaXN0IH0gZnJvbSAnLi90cmFuc2Zvcm1Dc3MtMGRiYTM2YmYuZXNtLmpzJztcbmltcG9ydCB7IHNldEFkYXB0ZXJJZk5vdFNldCwgZ2V0SWRlbnRPcHRpb24sIGFwcGVuZENzcywgcmVnaXN0ZXJDbGFzc05hbWUsIHJlZ2lzdGVyQ29tcG9zaXRpb24sIG1hcmtDb21wb3NpdGlvblVzZWQgfSBmcm9tICcuLi9hZGFwdGVyL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1hZGFwdGVyLmVzbS5qcyc7XG5pbXBvcnQgaGFzaCBmcm9tICdAZW1vdGlvbi9oYXNoJztcbmltcG9ydCB7IGdldEFuZEluY3JlbWVudFJlZkNvdW50ZXIsIGdldEZpbGVTY29wZSwgaGFzRmlsZVNjb3BlIH0gZnJvbSAnLi4vZmlsZVNjb3BlL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1maWxlU2NvcGUuZXNtLmpzJztcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCB7IHdhbGtPYmplY3QsIGdldCB9IGZyb20gJ0B2YW5pbGxhLWV4dHJhY3QvcHJpdmF0ZSc7XG5pbXBvcnQgY3NzZXNjIGZyb20gJ2Nzc2VzYyc7XG5pbXBvcnQgeyBkaWZmIH0gZnJvbSAnZGVlcC1vYmplY3QtZGlmZic7XG5pbXBvcnQgcGMgZnJvbSAncGljb2NvbG9ycyc7XG5pbXBvcnQgeyBfIGFzIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwgfSBmcm9tICcuL3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbC0xMDk5ODMxNS5lc20uanMnO1xuaW1wb3J0IGRlZGVudCBmcm9tICdkZWRlbnQnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0ICdtb2Rlcm4tYWhvY29yYXNpY2snO1xuaW1wb3J0ICdjc3Mtd2hhdCc7XG5pbXBvcnQgJ21lZGlhLXF1ZXJ5LXBhcnNlcic7XG5cbnZhciBsb2NhbENsYXNzTmFtZXMgPSBuZXcgU2V0KCk7XG52YXIgY29tcG9zZWRDbGFzc0xpc3RzID0gW107XG52YXIgYnVmZmVyZWRDU1NPYmpzID0gW107XG52YXIgYnJvd3NlclJ1bnRpbWVBZGFwdGVyID0ge1xuICBhcHBlbmRDc3M6IGNzc09iaiA9PiB7XG4gICAgYnVmZmVyZWRDU1NPYmpzLnB1c2goY3NzT2JqKTtcbiAgfSxcbiAgcmVnaXN0ZXJDbGFzc05hbWU6IGNsYXNzTmFtZSA9PiB7XG4gICAgbG9jYWxDbGFzc05hbWVzLmFkZChjbGFzc05hbWUpO1xuICB9LFxuICByZWdpc3RlckNvbXBvc2l0aW9uOiBjb21wb3NpdGlvbiA9PiB7XG4gICAgY29tcG9zZWRDbGFzc0xpc3RzLnB1c2goY29tcG9zaXRpb24pO1xuICB9LFxuICBtYXJrQ29tcG9zaXRpb25Vc2VkOiAoKSA9PiB7fSxcbiAgb25FbmRGaWxlU2NvcGU6IGZpbGVTY29wZSA9PiB7XG4gICAgdmFyIGNzcyA9IHRyYW5zZm9ybUNzcyh7XG4gICAgICBsb2NhbENsYXNzTmFtZXM6IEFycmF5LmZyb20obG9jYWxDbGFzc05hbWVzKSxcbiAgICAgIGNvbXBvc2VkQ2xhc3NMaXN0cyxcbiAgICAgIGNzc09ianM6IGJ1ZmZlcmVkQ1NTT2Jqc1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIGluamVjdFN0eWxlcyh7XG4gICAgICBmaWxlU2NvcGUsXG4gICAgICBjc3NcbiAgICB9KTtcbiAgICBidWZmZXJlZENTU09ianMgPSBbXTtcbiAgfSxcbiAgZ2V0SWRlbnRPcHRpb246ICgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAnc2hvcnQnIDogJ2RlYnVnJ1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBzZXRBZGFwdGVySWZOb3RTZXQoYnJvd3NlclJ1bnRpbWVBZGFwdGVyKTtcbn1cblxudmFyIGdldExhc3RTbGFzaEJlZm9yZUluZGV4ID0gKHBhdGgsIGluZGV4KSA9PiB7XG4gIHZhciBwYXRoSW5kZXggPSBpbmRleCAtIDE7XG4gIHdoaWxlIChwYXRoSW5kZXggPj0gMCkge1xuICAgIGlmIChwYXRoW3BhdGhJbmRleF0gPT09ICcvJykge1xuICAgICAgcmV0dXJuIHBhdGhJbmRleDtcbiAgICB9XG4gICAgcGF0aEluZGV4LS07XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBBc3N1bXB0aW9uczpcbiAqIC0gVGhlIHBhdGggaXMgYWx3YXlzIG5vcm1hbGl6ZWQgdG8gdXNlIHBvc2l4IGZpbGUgc2VwYXJhdG9ycyAoLykgKHNlZSBgYWRkRmlsZVNjb3BlYClcbiAqIC0gVGhlIHBhdGggaXMgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSBwcm9qZWN0IHJvb3QsIGkuZS4gdGhlcmUgd2lsbCBuZXZlciBiZSBhIGxlYWRpbmcgc2xhc2ggKHNlZSBgYWRkRmlsZVNjb3BlYClcbiAqIC0gQXMgbG9uZyBhcyBgLmNzc2AgaXMgdGhlcmUsIHdlIGhhdmUgYSB2YWxpZCBgLmNzcy4qYCBmaWxlIHBhdGgsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZXJlIHdvdWxkbid0XG4gKiAgIGJlIGEgZmlsZSBzY29wZSB0byBiZWdpbiB3aXRoXG4gKlxuICogVGhlIExSVSBjYWNoZSB3ZSB1c2UgY2FuJ3QgY2FjaGUgdW5kZWZpbmVkL251bGwgdmFsdWVzLCBzbyB3ZSBvcHQgdG8gcmV0dXJuIGFuIGVtcHR5IHN0cmluZyxcbiAqIHJhdGhlciB0aGFuIHVzaW5nIGEgY3VzdG9tIFN5bWJvbCBvciBzb21ldGhpbmcgc2ltaWxhci5cbiAqL1xudmFyIF9nZXREZWJ1Z0ZpbGVOYW1lID0gcGF0aCA9PiB7XG4gIHZhciBmaWxlO1xuICB2YXIgbGFzdEluZGV4T2ZEb3RDc3MgPSBwYXRoLmxhc3RJbmRleE9mKCcuY3NzJyk7XG4gIGlmIChsYXN0SW5kZXhPZkRvdENzcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGxhc3RTbGFzaEluZGV4ID0gZ2V0TGFzdFNsYXNoQmVmb3JlSW5kZXgocGF0aCwgbGFzdEluZGV4T2ZEb3RDc3MpO1xuICBmaWxlID0gcGF0aC5zbGljZShsYXN0U2xhc2hJbmRleCArIDEsIGxhc3RJbmRleE9mRG90Q3NzKTtcblxuICAvLyBUaGVyZSBhcmUgbm8gc2xhc2hlcywgdGhlcmVmb3JlIHRoZXJlcyBubyBkaXJlY3RvcnkgdG8gZXh0cmFjdFxuICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbiAgdmFyIHNlY29uZExhc3RTbGFzaEluZGV4ID0gZ2V0TGFzdFNsYXNoQmVmb3JlSW5kZXgocGF0aCwgbGFzdFNsYXNoSW5kZXggLSAxKTtcbiAgLy8gSWYgc2Vjb25kTGFzdFNsYXNoSW5kZXggaXMgLTEsIGl0IG1lYW5zIHRoYXQgdGhlIHBhdGggbG9va3MgbGlrZSBgZGlyZWN0b3J5L2ZpbGUuY3NzLnRzYCxcbiAgLy8gaW4gd2hpY2ggY2FzZSBkaXIgd2lsbCBzdGlsbCBiZSBzbGljZWQgc3RhcnRpbmcgYXQgMCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG4gIHZhciBkaXIgPSBwYXRoLnNsaWNlKHNlY29uZExhc3RTbGFzaEluZGV4ICsgMSwgbGFzdFNsYXNoSW5kZXgpO1xuICB2YXIgZGVidWdGaWxlTmFtZSA9IGZpbGUgIT09ICdpbmRleCcgPyBmaWxlIDogZGlyO1xuICByZXR1cm4gZGVidWdGaWxlTmFtZTtcbn07XG52YXIgbWVtb2l6ZWRHZXREZWJ1Z0ZpbGVOYW1lID0gKCkgPT4ge1xuICB2YXIgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoe1xuICAgIG1heDogNTAwXG4gIH0pO1xuICByZXR1cm4gcGF0aCA9PiB7XG4gICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gX2dldERlYnVnRmlsZU5hbWUocGF0aCk7XG4gICAgY2FjaGUuc2V0KHBhdGgsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG52YXIgZ2V0RGVidWdGaWxlTmFtZSA9IG1lbW9pemVkR2V0RGVidWdGaWxlTmFtZSgpO1xuXG5mdW5jdGlvbiBnZXREZXZQcmVmaXgoX3JlZikge1xuICB2YXIge1xuICAgIGRlYnVnSWQsXG4gICAgZGVidWdGaWxlTmFtZVxuICB9ID0gX3JlZjtcbiAgdmFyIHBhcnRzID0gZGVidWdJZCA/IFtkZWJ1Z0lkLnJlcGxhY2UoL1xccy9nLCAnXycpXSA6IFtdO1xuICBpZiAoZGVidWdGaWxlTmFtZSkge1xuICAgIHZhciB7XG4gICAgICBmaWxlUGF0aFxuICAgIH0gPSBnZXRGaWxlU2NvcGUoKTtcbiAgICB2YXIgX2RlYnVnRmlsZU5hbWUgPSBnZXREZWJ1Z0ZpbGVOYW1lKGZpbGVQYXRoKTtcblxuICAgIC8vIGRlYnVnRmlsZU5hbWUgY291bGQgYmUgYW4gZW1wdHkgc3RyaW5nXG4gICAgaWYgKF9kZWJ1Z0ZpbGVOYW1lKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KF9kZWJ1Z0ZpbGVOYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJ18nKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICByZXR1cm4gaWRlbnRpZmllci5tYXRjaCgvXlswLTldLykgPyBcIl9cIi5jb25jYXQoaWRlbnRpZmllcikgOiBpZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJZGVudGlmaWVyKGFyZykge1xuICB2YXIgaWRlbnRPcHRpb24gPSBnZXRJZGVudE9wdGlvbigpO1xuICB2YXIge1xuICAgIGRlYnVnSWQsXG4gICAgZGVidWdGaWxlTmFtZSA9IHRydWVcbiAgfSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IHtcbiAgICBkZWJ1Z0lkOiBhcmdcbiAgfSA6IG51bGwpLCB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyA/IGFyZyA6IG51bGwpO1xuXG4gIC8vIENvbnZlcnQgcmVmIGNvdW50IHRvIGJhc2UgMzYgZm9yIG9wdGltYWwgaGFzaCBsZW5ndGhzXG4gIHZhciByZWZDb3VudCA9IGdldEFuZEluY3JlbWVudFJlZkNvdW50ZXIoKS50b1N0cmluZygzNik7XG4gIHZhciB7XG4gICAgZmlsZVBhdGgsXG4gICAgcGFja2FnZU5hbWVcbiAgfSA9IGdldEZpbGVTY29wZSgpO1xuICB2YXIgZmlsZVNjb3BlSGFzaCA9IGhhc2gocGFja2FnZU5hbWUgPyBcIlwiLmNvbmNhdChwYWNrYWdlTmFtZSkuY29uY2F0KGZpbGVQYXRoKSA6IGZpbGVQYXRoKTtcbiAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChmaWxlU2NvcGVIYXNoKS5jb25jYXQocmVmQ291bnQpO1xuICBpZiAoaWRlbnRPcHRpb24gPT09ICdkZWJ1ZycpIHtcbiAgICB2YXIgZGV2UHJlZml4ID0gZ2V0RGV2UHJlZml4KHtcbiAgICAgIGRlYnVnSWQsXG4gICAgICBkZWJ1Z0ZpbGVOYW1lXG4gICAgfSk7XG4gICAgaWYgKGRldlByZWZpeCkge1xuICAgICAgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGRldlByZWZpeCwgXCJfX1wiKS5jb25jYXQoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICB9XG4gIGlmICh0eXBlb2YgaWRlbnRPcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZGVudGlmaWVyID0gaWRlbnRPcHRpb24oe1xuICAgICAgaGFzaDogaWRlbnRpZmllcixcbiAgICAgIGRlYnVnSWQsXG4gICAgICBmaWxlUGF0aCxcbiAgICAgIHBhY2thZ2VOYW1lXG4gICAgfSk7XG4gICAgaWYgKCFpZGVudGlmaWVyLm1hdGNoKC9eW0EtWl9dWzAtOUEtWl8tXSskL2kpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZGVudGlmaWVyIGZ1bmN0aW9uIHJldHVybmVkIGludmFsaWQgaW5kZW50aWZpZXI6IFxcXCJcIi5jb25jYXQoaWRlbnRpZmllciwgXCJcXFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG59XG5cbnZhciBub3JtYWxpc2VPYmplY3QgPSBvYmogPT4gd2Fsa09iamVjdChvYmosICgpID0+ICcnKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29udHJhY3QoY29udHJhY3QsIHRva2Vucykge1xuICB2YXIgdGhlRGlmZiA9IGRpZmYobm9ybWFsaXNlT2JqZWN0KGNvbnRyYWN0KSwgbm9ybWFsaXNlT2JqZWN0KHRva2VucykpO1xuICB2YXIgdmFsaWQgPSBPYmplY3Qua2V5cyh0aGVEaWZmKS5sZW5ndGggPT09IDA7XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZGlmZlN0cmluZzogdmFsaWQgPyAnJyA6IHJlbmRlckRpZmYoY29udHJhY3QsIHRoZURpZmYpXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmTGluZSh2YWx1ZSwgbmVzdGluZywgdHlwZSkge1xuICB2YXIgd2hpdGVzcGFjZSA9IFsuLi5BcnJheShuZXN0aW5nKS5rZXlzKCldLm1hcCgoKSA9PiAnICAnKS5qb2luKCcnKTtcbiAgdmFyIGxpbmUgPSBcIlwiLmNvbmNhdCh0eXBlID8gdHlwZSA6ICcgJykuY29uY2F0KHdoaXRlc3BhY2UpLmNvbmNhdCh2YWx1ZSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnKSB7XG4gICAgaWYgKHR5cGUgPT09ICctJykge1xuICAgICAgcmV0dXJuIHBjLnJlZChsaW5lKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICcrJykge1xuICAgICAgcmV0dXJuIHBjLmdyZWVuKGxpbmUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZmYob3JpZywgZGlmZikge1xuICB2YXIgbmVzdGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIGxpbmVzID0gW107XG4gIGlmIChuZXN0aW5nID09PSAwKSB7XG4gICAgbGluZXMucHVzaChkaWZmTGluZSgneycsIDApKTtcbiAgfVxuICB2YXIgaW5uZXJOZXN0aW5nID0gbmVzdGluZyArIDE7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGlmZikuc29ydCgpO1xuICBmb3IgKHZhciBrZXkgb2Yga2V5cykge1xuICAgIHZhciB2YWx1ZSA9IGRpZmZba2V5XTtcbiAgICBpZiAoIShrZXkgaW4gb3JpZykpIHtcbiAgICAgIGxpbmVzLnB1c2goZGlmZkxpbmUoXCJcIi5jb25jYXQoa2V5LCBcIjogLi4uLFwiKSwgaW5uZXJOZXN0aW5nLCAnKycpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxpbmVzLnB1c2goZGlmZkxpbmUoXCJcIi5jb25jYXQoa2V5LCBcIjoge1wiKSwgaW5uZXJOZXN0aW5nKSk7XG4gICAgICBsaW5lcy5wdXNoKHJlbmRlckRpZmYob3JpZ1trZXldLCBkaWZmW2tleV0sIGlubmVyTmVzdGluZykpO1xuICAgICAgbGluZXMucHVzaChkaWZmTGluZSgnfScsIGlubmVyTmVzdGluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lcy5wdXNoKGRpZmZMaW5lKFwiXCIuY29uY2F0KGtleSwgXCI6IC4uLixcIiksIGlubmVyTmVzdGluZywgJy0nKSk7XG4gICAgfVxuICB9XG4gIGlmIChuZXN0aW5nID09PSAwKSB7XG4gICAgbGluZXMucHVzaChkaWZmTGluZSgnfScsIDApKTtcbiAgfVxuICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG59XG5cbnZhciBidWlsZFByb3BlcnR5UnVsZSA9IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIHN5bnRheCxcbiAgICBpbmhlcml0cyxcbiAgICBpbml0aWFsVmFsdWVcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgc3ludGF4OiBcIlxcXCJcIi5jb25jYXQoQXJyYXkuaXNBcnJheShzeW50YXgpID8gc3ludGF4LmpvaW4oJyB8ICcpIDogc3ludGF4LCBcIlxcXCJcIiksXG4gICAgaW5oZXJpdHM6IGluaGVyaXRzID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICB9LCBpbml0aWFsVmFsdWUgIT0gbnVsbCA/IHtcbiAgICBpbml0aWFsVmFsdWVcbiAgfSA6IHt9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVWYXIoZGVidWdJZE9yRGVjbGFyYXRpb24sIGRlYnVnSWQpIHtcbiAgdmFyIGNzc1Zhck5hbWUgPSBjc3Nlc2MoZ2VuZXJhdGVJZGVudGlmaWVyKHtcbiAgICBkZWJ1Z0lkOiB0eXBlb2YgZGVidWdJZE9yRGVjbGFyYXRpb24gPT09ICdzdHJpbmcnID8gZGVidWdJZE9yRGVjbGFyYXRpb24gOiBkZWJ1Z0lkLFxuICAgIGRlYnVnRmlsZU5hbWU6IGZhbHNlXG4gIH0pLCB7XG4gICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gIH0pO1xuICBpZiAoZGVidWdJZE9yRGVjbGFyYXRpb24gJiYgdHlwZW9mIGRlYnVnSWRPckRlY2xhcmF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIGFwcGVuZENzcyh7XG4gICAgICB0eXBlOiAncHJvcGVydHknLFxuICAgICAgbmFtZTogXCItLVwiLmNvbmNhdChjc3NWYXJOYW1lKSxcbiAgICAgIHJ1bGU6IGJ1aWxkUHJvcGVydHlSdWxlKGRlYnVnSWRPckRlY2xhcmF0aW9uKVxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgfVxuICByZXR1cm4gXCJ2YXIoLS1cIi5jb25jYXQoY3NzVmFyTmFtZSwgXCIpXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsVmFyKG5hbWUsIGRlY2xhcmF0aW9uKSB7XG4gIGlmIChkZWNsYXJhdGlvbiAmJiB0eXBlb2YgZGVjbGFyYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgYXBwZW5kQ3NzKHtcbiAgICAgIHR5cGU6ICdwcm9wZXJ0eScsXG4gICAgICBuYW1lOiBcIi0tXCIuY29uY2F0KG5hbWUpLFxuICAgICAgcnVsZTogYnVpbGRQcm9wZXJ0eVJ1bGUoZGVjbGFyYXRpb24pXG4gICAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xuICB9XG4gIHJldHVybiBcInZhcigtLVwiLmNvbmNhdChuYW1lLCBcIilcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRWYXJOYW1lKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICEvXnZhclxcKC0tLipcXCkkLy50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFyaWFibGUgbmFtZTogXCIuY29uY2F0KHZhbHVlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZhbGxiYWNrVmFyKCkge1xuICB2YXIgZmluYWxWYWx1ZSA9ICcnO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICB2YWx1ZXMucmV2ZXJzZSgpLmZvckVhY2godmFsdWUgPT4ge1xuICAgIGlmIChmaW5hbFZhbHVlID09PSAnJykge1xuICAgICAgZmluYWxWYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydFZhck5hbWUodmFsdWUpO1xuICAgICAgZmluYWxWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcKSQvLCBcIiwgXCIuY29uY2F0KGZpbmFsVmFsdWUsIFwiKVwiKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbmFsVmFsdWU7XG59XG5mdW5jdGlvbiBhc3NpZ25WYXJzKHZhckNvbnRyYWN0LCB0b2tlbnMpIHtcbiAgdmFyIHZhclNldHRlcnMgPSB7fTtcbiAgdmFyIHtcbiAgICB2YWxpZCxcbiAgICBkaWZmU3RyaW5nXG4gIH0gPSB2YWxpZGF0ZUNvbnRyYWN0KHZhckNvbnRyYWN0LCB0b2tlbnMpO1xuICBpZiAoIXZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW5zIGRvbid0IG1hdGNoIGNvbnRyYWN0LlxcblwiLmNvbmNhdChkaWZmU3RyaW5nKSk7XG4gIH1cbiAgd2Fsa09iamVjdCh0b2tlbnMsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgIHZhclNldHRlcnNbZ2V0KHZhckNvbnRyYWN0LCBwYXRoKV0gPSBTdHJpbmcodmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHZhclNldHRlcnM7XG59XG5mdW5jdGlvbiBjcmVhdGVUaGVtZUNvbnRyYWN0KHRva2Vucykge1xuICByZXR1cm4gd2Fsa09iamVjdCh0b2tlbnMsIChfdmFsdWUsIHBhdGgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlVmFyKHBhdGguam9pbignLScpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxUaGVtZUNvbnRyYWN0KHRva2VucywgbWFwRm4pIHtcbiAgcmV0dXJuIHdhbGtPYmplY3QodG9rZW5zLCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICB2YXIgcmF3VmFyTmFtZSA9IHR5cGVvZiBtYXBGbiA9PT0gJ2Z1bmN0aW9uJyA/IG1hcEZuKHZhbHVlLCBwYXRoKSA6IHZhbHVlO1xuICAgIHZhciB2YXJOYW1lID0gdHlwZW9mIHJhd1Zhck5hbWUgPT09ICdzdHJpbmcnID8gcmF3VmFyTmFtZS5yZXBsYWNlKC9eXFwtXFwtLywgJycpIDogbnVsbDtcbiAgICBpZiAodHlwZW9mIHZhck5hbWUgIT09ICdzdHJpbmcnIHx8IHZhck5hbWUgIT09IGNzc2VzYyh2YXJOYW1lLCB7XG4gICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICB9KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YXJpYWJsZSBuYW1lIGZvciBcXFwiXCIuY29uY2F0KHBhdGguam9pbignLicpLCBcIlxcXCI6IFwiKS5jb25jYXQodmFyTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gXCJ2YXIoLS1cIi5jb25jYXQodmFyTmFtZSwgXCIpXCIpO1xuICB9KTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcIkBsYXllclwiXTtcbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFRoZW1lKHNlbGVjdG9yLCBhcmcyLCBhcmczKSB7XG4gIHZhciB0aGVtZUNvbnRyYWN0UHJvdmlkZWQgPSBCb29sZWFuKGFyZzMpO1xuICB2YXIgdG9rZW5BcmcgPSB0aGVtZUNvbnRyYWN0UHJvdmlkZWQgPyBhcmczIDogYXJnMjtcbiAgdmFyIHtcbiAgICBsYXllck5hbWUsXG4gICAgdG9rZW5zXG4gIH0gPSBleHRyYWN0TGF5ZXJGcm9tVG9rZW5zKHRva2VuQXJnKTtcbiAgdmFyIHRoZW1lQ29udHJhY3QgPSB0aGVtZUNvbnRyYWN0UHJvdmlkZWQgPyBhcmcyIDogY3JlYXRlVGhlbWVDb250cmFjdCh0b2tlbnMpO1xuICB2YXIgcnVsZSA9IHtcbiAgICB2YXJzOiBhc3NpZ25WYXJzKHRoZW1lQ29udHJhY3QsIHRva2VucylcbiAgfTtcbiAgaWYgKGxheWVyTmFtZSkge1xuICAgIHJ1bGUgPSB7XG4gICAgICAnQGxheWVyJzoge1xuICAgICAgICBbbGF5ZXJOYW1lXTogcnVsZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXBwZW5kQ3NzKHtcbiAgICB0eXBlOiAnZ2xvYmFsJyxcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcnVsZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIGlmICghdGhlbWVDb250cmFjdFByb3ZpZGVkKSB7XG4gICAgcmV0dXJuIHRoZW1lQ29udHJhY3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRoZW1lKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgdmFyIHRoZW1lQ2xhc3NOYW1lID0gZ2VuZXJhdGVJZGVudGlmaWVyKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyA/IGFyZzMgOiBhcmcyKTtcbiAgcmVnaXN0ZXJDbGFzc05hbWUodGhlbWVDbGFzc05hbWUsIGdldEZpbGVTY29wZSgpKTtcbiAgdmFyIHZhcnMgPSB0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgPyBjcmVhdGVHbG9iYWxUaGVtZSh0aGVtZUNsYXNzTmFtZSwgYXJnMSwgYXJnMikgOiBjcmVhdGVHbG9iYWxUaGVtZSh0aGVtZUNsYXNzTmFtZSwgYXJnMSk7XG4gIHJldHVybiB2YXJzID8gW3RoZW1lQ2xhc3NOYW1lLCB2YXJzXSA6IHRoZW1lQ2xhc3NOYW1lO1xufVxuZnVuY3Rpb24gZXh0cmFjdExheWVyRnJvbVRva2Vucyh0b2tlbnMpIHtcbiAgaWYgKCdAbGF5ZXInIGluIHRva2Vucykge1xuICAgIHZhciB7XG4gICAgICAgICdAbGF5ZXInOiBsYXllck5hbWVcbiAgICAgIH0gPSB0b2tlbnMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHRva2VucywgX2V4Y2x1ZGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgdG9rZW5zOiByZXN0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2Vuc1xuICB9O1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0O1xuZnVuY3Rpb24gY29tcG9zZWRTdHlsZShydWxlcywgZGVidWdJZCkge1xuICB2YXIgY2xhc3NOYW1lID0gZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpO1xuICByZWdpc3RlckNsYXNzTmFtZShjbGFzc05hbWUsIGdldEZpbGVTY29wZSgpKTtcbiAgdmFyIGNsYXNzTGlzdCA9IFtdO1xuICB2YXIgc3R5bGVSdWxlcyA9IFtdO1xuICBmb3IgKHZhciBydWxlIG9mIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBydWxlID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NMaXN0LnB1c2gocnVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlUnVsZXMucHVzaChydWxlKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlc3VsdCA9IGNsYXNzTmFtZTtcbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0ID0gXCJcIi5jb25jYXQoY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KGR1ZHVwZUFuZEpvaW5DbGFzc0xpc3QoY2xhc3NMaXN0KSk7XG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbih7XG4gICAgICBpZGVudGlmaWVyOiBjbGFzc05hbWUsXG4gICAgICBjbGFzc0xpc3Q6IHJlc3VsdFxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgICBpZiAoc3R5bGVSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3R5bGVzIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9zaXRpb24gdGhlbiBpdCBpc1xuICAgICAgLy8gYWx3YXlzIHVzZWQgYW5kIHNob3VsZCBuZXZlciBiZSByZW1vdmVkXG4gICAgICBtYXJrQ29tcG9zaXRpb25Vc2VkKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVJ1bGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgX3J1bGUgPSBkZWVwbWVyZ2UuYWxsKHN0eWxlUnVsZXMsIHtcbiAgICAgIC8vIFJlcGxhY2UgYXJyYXlzIHJhdGhlciB0aGFuIG1lcmdpbmdcbiAgICAgIGFycmF5TWVyZ2U6IChfLCBzb3VyY2VBcnJheSkgPT4gc291cmNlQXJyYXlcbiAgICB9KTtcbiAgICBhcHBlbmRDc3Moe1xuICAgICAgdHlwZTogJ2xvY2FsJyxcbiAgICAgIHNlbGVjdG9yOiBjbGFzc05hbWUsXG4gICAgICBydWxlOiBfcnVsZVxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3R5bGUocnVsZSwgZGVidWdJZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShydWxlKSkge1xuICAgIHJldHVybiBjb21wb3NlZFN0eWxlKHJ1bGUsIGRlYnVnSWQpO1xuICB9XG4gIHZhciBjbGFzc05hbWUgPSBnZW5lcmF0ZUlkZW50aWZpZXIoZGVidWdJZCk7XG4gIHJlZ2lzdGVyQ2xhc3NOYW1lKGNsYXNzTmFtZSwgZ2V0RmlsZVNjb3BlKCkpO1xuICBhcHBlbmRDc3Moe1xuICAgIHR5cGU6ICdsb2NhbCcsXG4gICAgc2VsZWN0b3I6IGNsYXNzTmFtZSxcbiAgICBydWxlXG4gIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGUgc2FtZSBmdW5jdGlvbmFsaXR5IGlzIG5vdyBwcm92aWRlZCBieSB0aGUgJ3N0eWxlJyBmdW5jdGlvbiB3aGVuIHlvdSBwYXNzIGl0IGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VTdHlsZXMoKSB7XG4gIHZhciBjb21wb3NlID0gaGFzRmlsZVNjb3BlKCkgPyBjb21wb3NlZFN0eWxlIDogZHVkdXBlQW5kSm9pbkNsYXNzTGlzdDtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsYXNzTmFtZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY2xhc3NOYW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gY29tcG9zZShjbGFzc05hbWVzKTtcbn1cbmZ1bmN0aW9uIGdsb2JhbFN0eWxlKHNlbGVjdG9yLCBydWxlKSB7XG4gIGFwcGVuZENzcyh7XG4gICAgdHlwZTogJ2dsb2JhbCcsXG4gICAgc2VsZWN0b3IsXG4gICAgcnVsZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG59XG5mdW5jdGlvbiBmb250RmFjZShydWxlLCBkZWJ1Z0lkKSB7XG4gIHZhciBmb250RmFtaWx5ID0gXCJcXFwiXCIuY29uY2F0KGNzc2VzYyhnZW5lcmF0ZUlkZW50aWZpZXIoZGVidWdJZCksIHtcbiAgICBxdW90ZXM6ICdkb3VibGUnXG4gIH0pLCBcIlxcXCJcIik7XG4gIHZhciBydWxlcyA9IEFycmF5LmlzQXJyYXkocnVsZSkgPyBydWxlIDogW3J1bGVdO1xuICBmb3IgKHZhciBzaW5nbGVSdWxlIG9mIHJ1bGVzKSB7XG4gICAgaWYgKCdmb250RmFtaWx5JyBpbiBzaW5nbGVSdWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGVkZW50KF90ZW1wbGF0ZU9iamVjdCB8fCAoX3RlbXBsYXRlT2JqZWN0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgYSBoYXNoZWQgZm9udC1mYW1pbHkgbmFtZSwgc28gdGhlIFxcXCJmb250RmFtaWx5XFxcIiBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIHByb3ZpZGVkLlxcbiAgICBcXG4gICAgICBJZiB5b3UnZCBsaWtlIHRvIGRlZmluZSBhIGdsb2JhbGx5IHNjb3BlZCBjdXN0b20gZm9udCwgeW91IGNhbiB1c2UgdGhlIFxcXCJnbG9iYWxGb250RmFjZVxcXCIgZnVuY3Rpb24gaW5zdGVhZC5cXG4gICAgXCJdKSkpKTtcbiAgICB9XG4gICAgYXBwZW5kQ3NzKHtcbiAgICAgIHR5cGU6ICdmb250RmFjZScsXG4gICAgICBydWxlOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc2luZ2xlUnVsZSksIHt9LCB7XG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIH0pXG4gICAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xuICB9XG4gIHJldHVybiBmb250RmFtaWx5O1xufVxuZnVuY3Rpb24gZ2xvYmFsRm9udEZhY2UoZm9udEZhbWlseSwgcnVsZSkge1xuICB2YXIgcnVsZXMgPSBBcnJheS5pc0FycmF5KHJ1bGUpID8gcnVsZSA6IFtydWxlXTtcbiAgZm9yICh2YXIgc2luZ2xlUnVsZSBvZiBydWxlcykge1xuICAgIGFwcGVuZENzcyh7XG4gICAgICB0eXBlOiAnZm9udEZhY2UnLFxuICAgICAgcnVsZTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNpbmdsZVJ1bGUpLCB7fSwge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9KVxuICAgIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24ga2V5ZnJhbWVzKHJ1bGUsIGRlYnVnSWQpIHtcbiAgdmFyIG5hbWUgPSBjc3Nlc2MoZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpLCB7XG4gICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gIH0pO1xuICBhcHBlbmRDc3Moe1xuICAgIHR5cGU6ICdrZXlmcmFtZXMnLFxuICAgIG5hbWUsXG4gICAgcnVsZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZ2xvYmFsS2V5ZnJhbWVzKG5hbWUsIHJ1bGUpIHtcbiAgYXBwZW5kQ3NzKHtcbiAgICB0eXBlOiAna2V5ZnJhbWVzJyxcbiAgICBuYW1lLFxuICAgIHJ1bGVcbiAgfSwgZ2V0RmlsZVNjb3BlKCkpO1xufVxuZnVuY3Rpb24gc3R5bGVWYXJpYW50cygpIHtcbiAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBfZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgX21hcERhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIF9kZWJ1Z0lkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdO1xuICAgIHZhciBfY2xhc3NNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBfa2V5MiBpbiBfZGF0YSkge1xuICAgICAgX2NsYXNzTWFwW19rZXkyXSA9IHN0eWxlKF9tYXBEYXRhKF9kYXRhW19rZXkyXSwgX2tleTIpLCBfZGVidWdJZCA/IFwiXCIuY29uY2F0KF9kZWJ1Z0lkLCBcIl9cIikuY29uY2F0KF9rZXkyKSA6IF9rZXkyKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jbGFzc01hcDtcbiAgfVxuICB2YXIgc3R5bGVNYXAgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gIHZhciBkZWJ1Z0lkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICB2YXIgY2xhc3NNYXAgPSB7fTtcbiAgZm9yICh2YXIgX2tleTMgaW4gc3R5bGVNYXApIHtcbiAgICBjbGFzc01hcFtfa2V5M10gPSBzdHlsZShzdHlsZU1hcFtfa2V5M10sIGRlYnVnSWQgPyBcIlwiLmNvbmNhdChkZWJ1Z0lkLCBcIl9cIikuY29uY2F0KF9rZXkzKSA6IF9rZXkzKTtcbiAgfVxuICByZXR1cm4gY2xhc3NNYXA7XG59XG5cbi8vIGNyZWF0ZUNvbnRhaW5lciBpcyB1c2VkIGZvciBsb2NhbCBzY29waW5nIG9mIENTUyBjb250YWluZXJzXG4vLyBGb3Igbm93IGl0IGlzIG1vc3RseSBqdXN0IGFuIGFsaWFzIG9mIGdlbmVyYXRlSWRlbnRpZmllclxudmFyIGNyZWF0ZUNvbnRhaW5lciA9IGRlYnVnSWQgPT4gZ2VuZXJhdGVJZGVudGlmaWVyKGRlYnVnSWQpO1xuXG4vLyBjcmVhdGVWaWV3VHJhbnNpdGlvbiBpcyB1c2VkIGZvciBsb2NhbGx5IHNjb3BpbmcgQ1NTIHZpZXcgdHJhbnNpdGlvbnNcbi8vIEZvciBub3cgaXQgaXMgbW9zdGx5IGp1c3QgYW4gYWxpYXMgb2YgZ2VuZXJhdGVJZGVudGlmaWVyXG52YXIgY3JlYXRlVmlld1RyYW5zaXRpb24gPSBkZWJ1Z0lkID0+IGdlbmVyYXRlSWRlbnRpZmllcihkZWJ1Z0lkKTtcblxudmFyIGRlZmF1bHRMYXllck9wdGlvbnMgPSB7fTtcbnZhciBtZXJnZSA9IChvYmoxLCBvYmoyKSA9PiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb2JqMSksIG9iajIpO1xudmFyIGdldExheWVyQXJncyA9IGZ1bmN0aW9uIGdldExheWVyQXJncygpIHtcbiAgdmFyIG9wdGlvbnMgPSBkZWZhdWx0TGF5ZXJPcHRpb25zO1xuICB2YXIgZGVidWdJZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdExheWVyT3B0aW9ucywgYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgICBkZWJ1Z0lkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICB9XG4gIHJldHVybiBbb3B0aW9ucywgZGVidWdJZF07XG59O1xuZnVuY3Rpb24gbGF5ZXIoKSB7XG4gIHZhciBbb3B0aW9ucywgZGVidWdJZF0gPSBnZXRMYXllckFyZ3MoLi4uYXJndW1lbnRzKTtcbiAgdmFyIG5hbWUgPSBnZW5lcmF0ZUlkZW50aWZpZXIoZGVidWdJZCk7XG4gIGlmIChvcHRpb25zLnBhcmVudCkge1xuICAgIG5hbWUgPSBcIlwiLmNvbmNhdChvcHRpb25zLnBhcmVudCwgXCIuXCIpLmNvbmNhdChuYW1lKTtcbiAgfVxuICBhcHBlbmRDc3Moe1xuICAgIHR5cGU6ICdsYXllcicsXG4gICAgbmFtZVxuICB9LCBnZXRGaWxlU2NvcGUoKSk7XG4gIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZ2xvYmFsTGF5ZXIoKSB7XG4gIHZhciBbb3B0aW9ucywgbmFtZV0gPSBnZXRMYXllckFyZ3MoLi4uYXJndW1lbnRzKTtcbiAgaWYgKG9wdGlvbnMucGFyZW50KSB7XG4gICAgbmFtZSA9IFwiXCIuY29uY2F0KG9wdGlvbnMucGFyZW50LCBcIi5cIikuY29uY2F0KG5hbWUpO1xuICB9XG4gIGFwcGVuZENzcyh7XG4gICAgdHlwZTogJ2xheWVyJyxcbiAgICBuYW1lXG4gIH0sIGdldEZpbGVTY29wZSgpKTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCB7IGFzc2VydFZhck5hbWUsIGFzc2lnblZhcnMsIGNvbXBvc2VTdHlsZXMsIGNyZWF0ZUNvbnRhaW5lciwgY3JlYXRlR2xvYmFsVGhlbWUsIGNyZWF0ZUdsb2JhbFRoZW1lQ29udHJhY3QsIGNyZWF0ZUdsb2JhbFZhciwgY3JlYXRlVGhlbWUsIGNyZWF0ZVRoZW1lQ29udHJhY3QsIGNyZWF0ZVZhciwgY3JlYXRlVmlld1RyYW5zaXRpb24sIGZhbGxiYWNrVmFyLCBmb250RmFjZSwgZ2VuZXJhdGVJZGVudGlmaWVyLCBnbG9iYWxGb250RmFjZSwgZ2xvYmFsS2V5ZnJhbWVzLCBnbG9iYWxMYXllciwgZ2xvYmFsU3R5bGUsIGtleWZyYW1lcywgbGF5ZXIsIHN0eWxlLCBzdHlsZVZhcmlhbnRzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   endFileScope: () => (/* binding */ endFileScope),\n/* harmony export */   getAndIncrementRefCounter: () => (/* binding */ getAndIncrementRefCounter),\n/* harmony export */   getFileScope: () => (/* binding */ getFileScope),\n/* harmony export */   hasFileScope: () => (/* binding */ hasFileScope),\n/* harmony export */   setFileScope: () => (/* binding */ setFileScope)\n/* harmony export */ });\n/* harmony import */ var _dist_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/taggedTemplateLiteral-10998315.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js\");\n/* harmony import */ var dedent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dedent */ \"(ssr)/../node_modules/dedent/dist/dedent.mjs\");\n/* harmony import */ var _adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../adapter/dist/vanilla-extract-css-adapter.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js\");\n\n\n\n\nvar _templateObject;\nvar refCounter = 0;\nvar fileScopes = [];\nfunction setFileScope(filePath, packageName) {\n  refCounter = 0;\n  var fileScope = {\n    filePath,\n    packageName\n  };\n  fileScopes.unshift(fileScope);\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__.onBeginFileScope)(fileScope);\n}\nfunction endFileScope() {\n  (0,_adapter_dist_vanilla_extract_css_adapter_esm_js__WEBPACK_IMPORTED_MODULE_2__.onEndFileScope)(getFileScope());\n  refCounter = 0;\n  fileScopes.splice(0, 1);\n}\nfunction hasFileScope() {\n  return fileScopes.length > 0;\n}\nfunction getFileScope() {\n  if (fileScopes.length === 0) {\n    throw new Error((0,dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject || (_templateObject = (0,_dist_taggedTemplateLiteral_10998315_esm_js__WEBPACK_IMPORTED_MODULE_0__._)([\"\\n        Styles were unable to be assigned to a file. This is generally caused by one of the following:\\n\\n        - You may have created styles outside of a '.css.ts' context\\n        - You may have incorrect configuration. See https://vanilla-extract.style/documentation/getting-started\\n      \"]))));\n  }\n  return fileScopes[0];\n}\nfunction getAndIncrementRefCounter() {\n  return refCounter++;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2ZpbGVTY29wZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtZmlsZVNjb3BlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErRjtBQUNuRTtBQUM2RTs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtHQUFnQjtBQUNsQjtBQUNBO0FBQ0EsRUFBRSxnR0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFNLHVDQUF1Qyw4RUFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RiIsInNvdXJjZXMiOlsid2VicGFjazovL3prZGF0YXZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L2Nzcy9maWxlU2NvcGUvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLWZpbGVTY29wZS5lc20uanM/MzdkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwgfSBmcm9tICcuLi8uLi9kaXN0L3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbC0xMDk5ODMxNS5lc20uanMnO1xuaW1wb3J0IGRlZGVudCBmcm9tICdkZWRlbnQnO1xuaW1wb3J0IHsgb25CZWdpbkZpbGVTY29wZSwgb25FbmRGaWxlU2NvcGUgfSBmcm9tICcuLi8uLi9hZGFwdGVyL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWNzcy1hZGFwdGVyLmVzbS5qcyc7XG5cbnZhciBfdGVtcGxhdGVPYmplY3Q7XG52YXIgcmVmQ291bnRlciA9IDA7XG52YXIgZmlsZVNjb3BlcyA9IFtdO1xuZnVuY3Rpb24gc2V0RmlsZVNjb3BlKGZpbGVQYXRoLCBwYWNrYWdlTmFtZSkge1xuICByZWZDb3VudGVyID0gMDtcbiAgdmFyIGZpbGVTY29wZSA9IHtcbiAgICBmaWxlUGF0aCxcbiAgICBwYWNrYWdlTmFtZVxuICB9O1xuICBmaWxlU2NvcGVzLnVuc2hpZnQoZmlsZVNjb3BlKTtcbiAgb25CZWdpbkZpbGVTY29wZShmaWxlU2NvcGUpO1xufVxuZnVuY3Rpb24gZW5kRmlsZVNjb3BlKCkge1xuICBvbkVuZEZpbGVTY29wZShnZXRGaWxlU2NvcGUoKSk7XG4gIHJlZkNvdW50ZXIgPSAwO1xuICBmaWxlU2NvcGVzLnNwbGljZSgwLCAxKTtcbn1cbmZ1bmN0aW9uIGhhc0ZpbGVTY29wZSgpIHtcbiAgcmV0dXJuIGZpbGVTY29wZXMubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVTY29wZSgpIHtcbiAgaWYgKGZpbGVTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGRlZGVudChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgICBTdHlsZXMgd2VyZSB1bmFibGUgdG8gYmUgYXNzaWduZWQgdG8gYSBmaWxlLiBUaGlzIGlzIGdlbmVyYWxseSBjYXVzZWQgYnkgb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuXFxuICAgICAgICAtIFlvdSBtYXkgaGF2ZSBjcmVhdGVkIHN0eWxlcyBvdXRzaWRlIG9mIGEgJy5jc3MudHMnIGNvbnRleHRcXG4gICAgICAgIC0gWW91IG1heSBoYXZlIGluY29ycmVjdCBjb25maWd1cmF0aW9uLiBTZWUgaHR0cHM6Ly92YW5pbGxhLWV4dHJhY3Quc3R5bGUvZG9jdW1lbnRhdGlvbi9nZXR0aW5nLXN0YXJ0ZWRcXG4gICAgICBcIl0pKSkpO1xuICB9XG4gIHJldHVybiBmaWxlU2NvcGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0QW5kSW5jcmVtZW50UmVmQ291bnRlcigpIHtcbiAgcmV0dXJuIHJlZkNvdW50ZXIrKztcbn1cblxuZXhwb3J0IHsgZW5kRmlsZVNjb3BlLCBnZXRBbmRJbmNyZW1lbnRSZWZDb3VudGVyLCBnZXRGaWxlU2NvcGUsIGhhc0ZpbGVTY29wZSwgc2V0RmlsZVNjb3BlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   injectStyles: () => (/* binding */ injectStyles)\n/* harmony export */ });\nvar stylesheets = {};\nvar injectStyles = _ref => {\n  var {\n    fileScope,\n    css\n  } = _ref;\n  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join('/') : fileScope.filePath;\n  var stylesheet = stylesheets[fileScopeId];\n  if (!stylesheet) {\n    var styleEl = document.createElement('style');\n    if (fileScope.packageName) {\n      styleEl.setAttribute('data-package', fileScope.packageName);\n    }\n    styleEl.setAttribute('data-file', fileScope.filePath);\n    styleEl.setAttribute('type', 'text/css');\n    stylesheet = stylesheets[fileScopeId] = styleEl;\n    document.head.appendChild(styleEl);\n  }\n  stylesheet.innerHTML = css;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL2luamVjdFN0eWxlcy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1jc3MtaW5qZWN0U3R5bGVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3prZGF0YXZhdWx0LWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AdmFuaWxsYS1leHRyYWN0L2Nzcy9pbmplY3RTdHlsZXMvZGlzdC92YW5pbGxhLWV4dHJhY3QtY3NzLWluamVjdFN0eWxlcy5lc20uanM/ZjIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3R5bGVzaGVldHMgPSB7fTtcbnZhciBpbmplY3RTdHlsZXMgPSBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBmaWxlU2NvcGUsXG4gICAgY3NzXG4gIH0gPSBfcmVmO1xuICB2YXIgZmlsZVNjb3BlSWQgPSBmaWxlU2NvcGUucGFja2FnZU5hbWUgPyBbZmlsZVNjb3BlLnBhY2thZ2VOYW1lLCBmaWxlU2NvcGUuZmlsZVBhdGhdLmpvaW4oJy8nKSA6IGZpbGVTY29wZS5maWxlUGF0aDtcbiAgdmFyIHN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0c1tmaWxlU2NvcGVJZF07XG4gIGlmICghc3R5bGVzaGVldCkge1xuICAgIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAoZmlsZVNjb3BlLnBhY2thZ2VOYW1lKSB7XG4gICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wYWNrYWdlJywgZmlsZVNjb3BlLnBhY2thZ2VOYW1lKTtcbiAgICB9XG4gICAgc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsZScsIGZpbGVTY29wZS5maWxlUGF0aCk7XG4gICAgc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICBzdHlsZXNoZWV0ID0gc3R5bGVzaGVldHNbZmlsZVNjb3BlSWRdID0gc3R5bGVFbDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICB9XG4gIHN0eWxlc2hlZXQuaW5uZXJIVE1MID0gY3NzO1xufTtcblxuZXhwb3J0IHsgaW5qZWN0U3R5bGVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignInlineVars: () => (/* binding */ assignInlineVars),\n/* harmony export */   setElementVars: () => (/* binding */ setElementVars)\n/* harmony export */ });\n/* harmony import */ var _vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vanilla-extract/private */ \"(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\");\n\n\nfunction assignInlineVars(varsOrContract, tokens) {\n  var styles = {};\n  if (typeof tokens === 'object') {\n    var _contract = varsOrContract;\n    (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.walkObject)(tokens, (value, path) => {\n      if (value == null) {\n        return;\n      }\n      var varName = (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.get)(_contract, path);\n      styles[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(varName)] = String(value);\n    });\n  } else {\n    var _vars = varsOrContract;\n    for (var varName in _vars) {\n      var value = _vars[varName];\n      if (value == null) {\n        continue;\n      }\n      styles[(0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(varName)] = value;\n    }\n  }\n  Object.defineProperty(styles, 'toString', {\n    value: function value() {\n      return Object.keys(this).map(key => \"\".concat(key, \":\").concat(this[key])).join(';');\n    },\n    writable: false\n  });\n  return styles;\n}\n\nfunction setVar(element, variable, value) {\n  element.style.setProperty((0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.getVarName)(variable), value);\n}\nfunction setElementVars(element, varsOrContract, tokens) {\n  if (typeof tokens === 'object') {\n    var _contract = varsOrContract;\n    (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.walkObject)(tokens, (value, path) => {\n      if (value == null) {\n        return;\n      }\n      setVar(element, (0,_vanilla_extract_private__WEBPACK_IMPORTED_MODULE_0__.get)(_contract, path), String(value));\n    });\n  } else {\n    var _vars = varsOrContract;\n    for (var varName in _vars) {\n      var value = _vars[varName];\n      if (value == null) {\n        continue;\n      }\n      setVar(element, varName, _vars[varName]);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvZHluYW1pYy9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1keW5hbWljLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBRztBQUN2QixhQUFhLG9FQUFVO0FBQ3ZCLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvRUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQUc7QUFDekIsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96a2RhdGF2YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9keW5hbWljL2Rpc3QvdmFuaWxsYS1leHRyYWN0LWR5bmFtaWMuZXNtLmpzPzE3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2Fsa09iamVjdCwgZ2V0LCBnZXRWYXJOYW1lIH0gZnJvbSAnQHZhbmlsbGEtZXh0cmFjdC9wcml2YXRlJztcblxuZnVuY3Rpb24gYXNzaWduSW5saW5lVmFycyh2YXJzT3JDb250cmFjdCwgdG9rZW5zKSB7XG4gIHZhciBzdHlsZXMgPSB7fTtcbiAgaWYgKHR5cGVvZiB0b2tlbnMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9jb250cmFjdCA9IHZhcnNPckNvbnRyYWN0O1xuICAgIHdhbGtPYmplY3QodG9rZW5zLCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YXJOYW1lID0gZ2V0KF9jb250cmFjdCwgcGF0aCk7XG4gICAgICBzdHlsZXNbZ2V0VmFyTmFtZSh2YXJOYW1lKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdmFycyA9IHZhcnNPckNvbnRyYWN0O1xuICAgIGZvciAodmFyIHZhck5hbWUgaW4gX3ZhcnMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF92YXJzW3Zhck5hbWVdO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzdHlsZXNbZ2V0VmFyTmFtZSh2YXJOYW1lKV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ3RvU3RyaW5nJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5tYXAoa2V5ID0+IFwiXCIuY29uY2F0KGtleSwgXCI6XCIpLmNvbmNhdCh0aGlzW2tleV0pKS5qb2luKCc7Jyk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIHNldFZhcihlbGVtZW50LCB2YXJpYWJsZSwgdmFsdWUpIHtcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShnZXRWYXJOYW1lKHZhcmlhYmxlKSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudFZhcnMoZWxlbWVudCwgdmFyc09yQ29udHJhY3QsIHRva2Vucykge1xuICBpZiAodHlwZW9mIHRva2VucyA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgX2NvbnRyYWN0ID0gdmFyc09yQ29udHJhY3Q7XG4gICAgd2Fsa09iamVjdCh0b2tlbnMsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VmFyKGVsZW1lbnQsIGdldChfY29udHJhY3QsIHBhdGgpLCBTdHJpbmcodmFsdWUpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3ZhcnMgPSB2YXJzT3JDb250cmFjdDtcbiAgICBmb3IgKHZhciB2YXJOYW1lIGluIF92YXJzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfdmFyc1t2YXJOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2V0VmFyKGVsZW1lbnQsIHZhck5hbWUsIF92YXJzW3Zhck5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgYXNzaWduSW5saW5lVmFycywgc2V0RWxlbWVudFZhcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getVarName: () => (/* binding */ getVarName),\n/* harmony export */   walkObject: () => (/* binding */ walkObject)\n/* harmony export */ });\nfunction getVarName(variable) {\n  var matches = variable.match(/^var\\((.*)\\)$/);\n  if (matches) {\n    return matches[1];\n  }\n  return variable;\n}\n\nfunction get(obj, path) {\n  var result = obj;\n  for (var key of path) {\n    if (!(key in result)) {\n      throw new Error(\"Path \".concat(path.join(' -> '), \" does not exist in object\"));\n    }\n    result = result[key];\n  }\n  return result;\n}\n\nfunction walkObject(obj, fn) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var clone = {};\n  for (var key in obj) {\n    var _value = obj[key];\n    var currentPath = [...path, key];\n    if (typeof _value === 'string' || typeof _value === 'number' || _value == null) {\n      clone[key] = fn(_value, currentPath);\n    } else if (typeof _value === 'object' && !Array.isArray(_value)) {\n      clone[key] = walkObject(_value, fn, currentPath);\n    } else {\n      console.warn(\"Skipping invalid key \\\"\".concat(currentPath.join('.'), \"\\\". Should be a string, number, null or object. Received: \\\"\").concat(Array.isArray(_value) ? 'Array' : typeof _value, \"\\\"\"));\n    }\n  }\n  return clone;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcHJpdmF0ZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1wcml2YXRlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemtkYXRhdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcHJpdmF0ZS9kaXN0L3ZhbmlsbGEtZXh0cmFjdC1wcml2YXRlLmVzbS5qcz9lY2Q5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldFZhck5hbWUodmFyaWFibGUpIHtcbiAgdmFyIG1hdGNoZXMgPSB2YXJpYWJsZS5tYXRjaCgvXnZhclxcKCguKilcXCkkLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBvYmo7XG4gIGZvciAodmFyIGtleSBvZiBwYXRoKSB7XG4gICAgaWYgKCEoa2V5IGluIHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggXCIuY29uY2F0KHBhdGguam9pbignIC0+ICcpLCBcIiBkb2VzIG5vdCBleGlzdCBpbiBvYmplY3RcIikpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3YWxrT2JqZWN0KG9iaiwgZm4pIHtcbiAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciBfdmFsdWUgPSBvYmpba2V5XTtcbiAgICB2YXIgY3VycmVudFBhdGggPSBbLi4ucGF0aCwga2V5XTtcbiAgICBpZiAodHlwZW9mIF92YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIF92YWx1ZSA9PT0gJ251bWJlcicgfHwgX3ZhbHVlID09IG51bGwpIHtcbiAgICAgIGNsb25lW2tleV0gPSBmbihfdmFsdWUsIGN1cnJlbnRQYXRoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KF92YWx1ZSkpIHtcbiAgICAgIGNsb25lW2tleV0gPSB3YWxrT2JqZWN0KF92YWx1ZSwgZm4sIGN1cnJlbnRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgaW52YWxpZCBrZXkgXFxcIlwiLmNvbmNhdChjdXJyZW50UGF0aC5qb2luKCcuJyksIFwiXFxcIi4gU2hvdWxkIGJlIGEgc3RyaW5nLCBudW1iZXIsIG51bGwgb3Igb2JqZWN0LiBSZWNlaXZlZDogXFxcIlwiKS5jb25jYXQoQXJyYXkuaXNBcnJheShfdmFsdWUpID8gJ0FycmF5JyA6IHR5cGVvZiBfdmFsdWUsIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IHsgZ2V0LCBnZXRWYXJOYW1lLCB3YWxrT2JqZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRuntimeFn: () => (/* reexport safe */ _dist_createRuntimeFn_62c9670f_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)\n/* harmony export */ });\n/* harmony import */ var _dist_createRuntimeFn_62c9670f_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/createRuntimeFn-62c9670f.esm.js */ \"(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9jcmVhdGVSdW50aW1lRm4vZGlzdC92YW5pbGxhLWV4dHJhY3QtcmVjaXBlcy1jcmVhdGVSdW50aW1lRm4uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemtkYXRhdmF1bHQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9jcmVhdGVSdW50aW1lRm4vZGlzdC92YW5pbGxhLWV4dHJhY3QtcmVjaXBlcy1jcmVhdGVSdW50aW1lRm4uZXNtLmpzP2ZmYTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgYyBhcyBjcmVhdGVSdW50aW1lRm4gfSBmcm9tICcuLi8uLi9kaXN0L2NyZWF0ZVJ1bnRpbWVGbi02MmM5NjcwZi5lc20uanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/recipes/createRuntimeFn/dist/vanilla-extract-recipes-createRuntimeFn.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ createRuntimeFn),\n/* harmony export */   m: () => (/* binding */ mapValues)\n/* harmony export */ });\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction mapValues(input, fn) {\n  var result = {};\n  for (var _key in input) {\n    result[_key] = fn(input[_key], _key);\n  }\n  return result;\n}\n\nvar shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {\n  for (var key of Object.keys(compoundCheck)) {\n    var _selections$key;\n    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {\n      return false;\n    }\n  }\n  return true;\n};\nvar createRuntimeFn = config => {\n  var runtimeFn = options => {\n    var className = config.defaultClassName;\n    var selections = _objectSpread2(_objectSpread2({}, config.defaultVariants), options);\n    for (var variantName in selections) {\n      var _selections$variantNa;\n      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];\n      if (variantSelection != null) {\n        var selection = variantSelection;\n        if (typeof selection === 'boolean') {\n          // @ts-expect-error\n          selection = selection === true ? 'true' : 'false';\n        }\n        var selectionClassName =\n        // @ts-expect-error\n        config.variantClassNames[variantName][selection];\n        if (selectionClassName) {\n          className += ' ' + selectionClassName;\n        }\n      }\n    }\n    for (var [compoundCheck, compoundClassName] of config.compoundVariants) {\n      if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {\n        className += ' ' + compoundClassName;\n      }\n    }\n    return className;\n  };\n  runtimeFn.variants = () => Object.keys(config.variantClassNames);\n  runtimeFn.classNames = {\n    get base() {\n      return config.defaultClassName.split(' ')[0];\n    },\n    get variants() {\n      return mapValues(config.variantClassNames, classNames => mapValues(classNames, className => className.split(' ')[0]));\n    }\n  };\n  return runtimeFn;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvcmVjaXBlcy9kaXN0L2NyZWF0ZVJ1bnRpbWVGbi02MmM5NjcwZi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96a2RhdGF2YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9yZWNpcGVzL2Rpc3QvY3JlYXRlUnVudGltZUZuLTYyYzk2NzBmLmVzbS5qcz9mZDI5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIG1hcFZhbHVlcyhpbnB1dCwgZm4pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBfa2V5IGluIGlucHV0KSB7XG4gICAgcmVzdWx0W19rZXldID0gZm4oaW5wdXRbX2tleV0sIF9rZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBzaG91bGRBcHBseUNvbXBvdW5kID0gKGNvbXBvdW5kQ2hlY2ssIHNlbGVjdGlvbnMsIGRlZmF1bHRWYXJpYW50cykgPT4ge1xuICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMoY29tcG91bmRDaGVjaykpIHtcbiAgICB2YXIgX3NlbGVjdGlvbnMka2V5O1xuICAgIGlmIChjb21wb3VuZENoZWNrW2tleV0gIT09ICgoX3NlbGVjdGlvbnMka2V5ID0gc2VsZWN0aW9uc1trZXldKSAhPT0gbnVsbCAmJiBfc2VsZWN0aW9ucyRrZXkgIT09IHZvaWQgMCA/IF9zZWxlY3Rpb25zJGtleSA6IGRlZmF1bHRWYXJpYW50c1trZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgY3JlYXRlUnVudGltZUZuID0gY29uZmlnID0+IHtcbiAgdmFyIHJ1bnRpbWVGbiA9IG9wdGlvbnMgPT4ge1xuICAgIHZhciBjbGFzc05hbWUgPSBjb25maWcuZGVmYXVsdENsYXNzTmFtZTtcbiAgICB2YXIgc2VsZWN0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb25maWcuZGVmYXVsdFZhcmlhbnRzKSwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgdmFyaWFudE5hbWUgaW4gc2VsZWN0aW9ucykge1xuICAgICAgdmFyIF9zZWxlY3Rpb25zJHZhcmlhbnROYTtcbiAgICAgIHZhciB2YXJpYW50U2VsZWN0aW9uID0gKF9zZWxlY3Rpb25zJHZhcmlhbnROYSA9IHNlbGVjdGlvbnNbdmFyaWFudE5hbWVdKSAhPT0gbnVsbCAmJiBfc2VsZWN0aW9ucyR2YXJpYW50TmEgIT09IHZvaWQgMCA/IF9zZWxlY3Rpb25zJHZhcmlhbnROYSA6IGNvbmZpZy5kZWZhdWx0VmFyaWFudHNbdmFyaWFudE5hbWVdO1xuICAgICAgaWYgKHZhcmlhbnRTZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdmFyaWFudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb24gPT09ICdib29sZWFuJykge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb25DbGFzc05hbWUgPVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbmZpZy52YXJpYW50Q2xhc3NOYW1lc1t2YXJpYW50TmFtZV1bc2VsZWN0aW9uXTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkNsYXNzTmFtZSkge1xuICAgICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBzZWxlY3Rpb25DbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgW2NvbXBvdW5kQ2hlY2ssIGNvbXBvdW5kQ2xhc3NOYW1lXSBvZiBjb25maWcuY29tcG91bmRWYXJpYW50cykge1xuICAgICAgaWYgKHNob3VsZEFwcGx5Q29tcG91bmQoY29tcG91bmRDaGVjaywgc2VsZWN0aW9ucywgY29uZmlnLmRlZmF1bHRWYXJpYW50cykpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIGNvbXBvdW5kQ2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9O1xuICBydW50aW1lRm4udmFyaWFudHMgPSAoKSA9PiBPYmplY3Qua2V5cyhjb25maWcudmFyaWFudENsYXNzTmFtZXMpO1xuICBydW50aW1lRm4uY2xhc3NOYW1lcyA9IHtcbiAgICBnZXQgYmFzZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuZGVmYXVsdENsYXNzTmFtZS5zcGxpdCgnICcpWzBdO1xuICAgIH0sXG4gICAgZ2V0IHZhcmlhbnRzKCkge1xuICAgICAgcmV0dXJuIG1hcFZhbHVlcyhjb25maWcudmFyaWFudENsYXNzTmFtZXMsIGNsYXNzTmFtZXMgPT4gbWFwVmFsdWVzKGNsYXNzTmFtZXMsIGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuc3BsaXQoJyAnKVswXSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJ1bnRpbWVGbjtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVJ1bnRpbWVGbiBhcyBjLCBtYXBWYWx1ZXMgYXMgbSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache)\n/* harmony export */ });\n/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nclass LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2YW5pbGxhLWV4dHJhY3QvY3NzL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQXlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOFVBQThVO0FBQzlWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCLElBQUk7QUFDbkQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCLElBQUk7QUFDcEQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUF1QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtHQUErRztBQUMvSCxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0EsNEJBQTRCO0FBQzVCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVJBQWlSO0FBQ2pSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLDRIQUE0SDtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96a2RhdGF2YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQHZhbmlsbGEtZXh0cmFjdC9jc3Mvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2VzbS9pbmRleC5qcz83NjdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBMUlVDYWNoZVxuICovXG5jb25zdCBwZXJmID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJlxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGVyZm9ybWFuY2VcbiAgICA6IERhdGU7XG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KCk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IFBST0NFU1MgPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmICEhcHJvY2VzcyA/IHByb2Nlc3MgOiB7fSk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGVtaXRXYXJuaW5nID0gKG1zZywgdHlwZSwgY29kZSwgZm4pID0+IHtcbiAgICB0eXBlb2YgUFJPQ0VTUy5lbWl0V2FybmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IFBST0NFU1MuZW1pdFdhcm5pbmcobXNnLCB0eXBlLCBjb2RlLCBmbilcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKGBbJHtjb2RlfV0gJHt0eXBlfTogJHttc2d9YCk7XG59O1xubGV0IEFDID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXI7XG5sZXQgQVMgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodHlwZW9mIEFDID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFTID0gY2xhc3MgQWJvcnRTaWduYWwge1xuICAgICAgICBvbmFib3J0O1xuICAgICAgICBfb25hYm9ydCA9IFtdO1xuICAgICAgICByZWFzb247XG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfLCBmbikge1xuICAgICAgICAgICAgdGhpcy5fb25hYm9ydC5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9AdHMtaWdub3JlXG4gICAgQUMgPSBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHdhcm5BQ1BvbHlmaWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsID0gbmV3IEFTKCk7XG4gICAgICAgIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuc2lnbmFsLl9vbmFib3J0KSB7XG4gICAgICAgICAgICAgICAgZm4ocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLm9uYWJvcnQ/LihyZWFzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IFBST0NFU1MuZW52Py5MUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkcgIT09ICcxJztcbiAgICBjb25zdCB3YXJuQUNQb2x5ZmlsbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcmludEFDUG9seWZpbGxXYXJuaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwcmludEFDUG9seWZpbGxXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIGVtaXRXYXJuaW5nKCdBYm9ydENvbnRyb2xsZXIgaXMgbm90IGRlZmluZWQuIElmIHVzaW5nIGxydS1jYWNoZSBpbiAnICtcbiAgICAgICAgICAgICdub2RlIDE0LCBsb2FkIGFuIEFib3J0Q29udHJvbGxlciBwb2x5ZmlsbCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICdgbm9kZS1hYm9ydC1jb250cm9sbGVyYCBwYWNrYWdlLiBBIG1pbmltYWwgcG9seWZpbGwgaXMgJyArXG4gICAgICAgICAgICAncHJvdmlkZWQgZm9yIHVzZSBieSBMUlVDYWNoZS5mZXRjaCgpLCBidXQgaXQgc2hvdWxkIG5vdCBiZSAnICtcbiAgICAgICAgICAgICdyZWxpZWQgdXBvbiBpbiBvdGhlciBjb250ZXh0cyAoZWcsIHBhc3NpbmcgaXQgdG8gb3RoZXIgQVBJcyB0aGF0ICcgK1xuICAgICAgICAgICAgJ3VzZSBBYm9ydENvbnRyb2xsZXIvQWJvcnRTaWduYWwgbWlnaHQgaGF2ZSB1bmRlc2lyYWJsZSBlZmZlY3RzKS4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBkaXNhYmxlIHRoaXMgd2l0aCBMUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkc9MSBpbiB0aGUgZW52LicsICdOT19BQk9SVF9DT05UUk9MTEVSJywgJ0VOT1RTVVAnLCB3YXJuQUNQb2x5ZmlsbCk7XG4gICAgfTtcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jb25zdCBzaG91bGRXYXJuID0gKGNvZGUpID0+ICF3YXJuZWQuaGFzKGNvZGUpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuY29uc3QgaXNQb3NJbnQgPSAobikgPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyBUaGlzIGlzIGEgbGl0dGxlIGJpdCByaWRpY3Vsb3VzLCB0YmguXG4vLyBUaGUgbWF4aW11bSBhcnJheSBsZW5ndGggaXMgMl4zMi0xIG9yIHRoZXJlYWJvdXRzIG9uIG1vc3QgSlMgaW1wbHMuXG4vLyBBbmQgd2VsbCBiZWZvcmUgdGhhdCBwb2ludCwgeW91J3JlIGNhY2hpbmcgdGhlIGVudGlyZSB3b3JsZCwgSSBtZWFuLFxuLy8gdGhhdCdzIH4zMkdCIG9mIGp1c3QgaW50ZWdlcnMgZm9yIHRoZSBuZXh0L3ByZXYgbGlua3MsIHBsdXMgd2hhdGV2ZXJcbi8vIGVsc2UgdG8gaG9sZCB0aGF0IG1hbnkga2V5cyBhbmQgdmFsdWVzLiAgSnVzdCBmaWxsaW5nIHRoZSBtZW1vcnkgd2l0aFxuLy8gemVyb2VzIGF0IGluaXQgdGltZSBpcyBicnV0YWwgd2hlbiB5b3UgZ2V0IHRoYXQgYmlnLlxuLy8gQnV0IHdoeSBub3QgYmUgY29tcGxldGU/XG4vLyBNYXliZSBpbiB0aGUgZnV0dXJlLCB0aGVzZSBsaW1pdHMgd2lsbCBoYXZlIGV4cGFuZGVkLlxuY29uc3QgZ2V0VWludEFycmF5ID0gKG1heCkgPT4gIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgICAgICA/IFVpbnQ4QXJyYXlcbiAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgICAgICAgICA/IFVpbnQxNkFycmF5XG4gICAgICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICAgICAgICAgICAgICA/IFVpbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICAgPyBaZXJvQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKHNpemUpO1xuICAgICAgICB0aGlzLmZpbGwoMCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2sge1xuICAgIGhlYXA7XG4gICAgbGVuZ3RoO1xuICAgIC8vIHByaXZhdGUgY29uc3RydWN0b3JcbiAgICBzdGF0aWMgI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgIHN0YXRpYyBjcmVhdGUobWF4KSB7XG4gICAgICAgIGNvbnN0IEhlYXBDbHMgPSBnZXRVaW50QXJyYXkobWF4KTtcbiAgICAgICAgaWYgKCFIZWFwQ2xzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTdGFjayhtYXgsIEhlYXBDbHMpO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtYXgsIEhlYXBDbHMpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghU3RhY2suI2NvbnN0cnVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zdGFudGlhdGUgU3RhY2sgdXNpbmcgU3RhY2suY3JlYXRlKG4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXBDbHMobWF4KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwdXNoKG4pIHtcbiAgICAgICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gbjtcbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdO1xuICAgIH1cbn1cbi8qKlxuICogRGVmYXVsdCBleHBvcnQsIHRoZSB0aGluZyB5b3UncmUgdXNpbmcgdGhpcyBtb2R1bGUgdG8gZ2V0LlxuICpcbiAqIFRoZSBgS2AgYW5kIGBWYCB0eXBlcyBkZWZpbmUgdGhlIGtleSBhbmQgdmFsdWUgdHlwZXMsIHJlc3BlY3RpdmVseS4gVGhlXG4gKiBvcHRpb25hbCBgRkNgIHR5cGUgZGVmaW5lcyB0aGUgdHlwZSBvZiB0aGUgYGNvbnRleHRgIG9iamVjdCBwYXNzZWQgdG9cbiAqIGBjYWNoZS5mZXRjaCgpYCBhbmQgYGNhY2hlLm1lbW8oKWAuXG4gKlxuICogS2V5cyBhbmQgdmFsdWVzICoqbXVzdCBub3QqKiBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgbWF4YCxcbiAqIGBtYXhTaXplYCwgYGZldGNoTWV0aG9kYCwgYG1lbW9NZXRob2RgLCBgZGlzcG9zZWAgYW5kIGBkaXNwb3NlQWZ0ZXJgKSBhcmVcbiAqIGFkZGVkIGFzIG5vcm1hbCBwdWJsaWMgbWVtYmVycy4gKFRoZSBsaXN0ZWQgb3B0aW9ucyBhcmUgcmVhZC1vbmx5IGdldHRlcnMuKVxuICpcbiAqIENoYW5naW5nIGFueSBvZiB0aGVzZSB3aWxsIGFsdGVyIHRoZSBkZWZhdWx0cyBmb3Igc3Vic2VxdWVudCBtZXRob2QgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMUlVDYWNoZSB7XG4gICAgLy8gb3B0aW9ucyB0aGF0IGNhbm5vdCBiZSBjaGFuZ2VkIHdpdGhvdXQgZGlzYXN0ZXJcbiAgICAjbWF4O1xuICAgICNtYXhTaXplO1xuICAgICNkaXNwb3NlO1xuICAgICNkaXNwb3NlQWZ0ZXI7XG4gICAgI2ZldGNoTWV0aG9kO1xuICAgICNtZW1vTWV0aG9kO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGx9XG4gICAgICovXG4gICAgdHRsO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxSZXNvbHV0aW9ufVxuICAgICAqL1xuICAgIHR0bFJlc29sdXRpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bEF1dG9wdXJnZX1cbiAgICAgKi9cbiAgICB0dGxBdXRvcHVyZ2U7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uR2V0fVxuICAgICAqL1xuICAgIHVwZGF0ZUFnZU9uR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkhhc31cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkhhcztcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0Rpc3Bvc2VPblNldH1cbiAgICAgKi9cbiAgICBub0Rpc3Bvc2VPblNldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9VcGRhdGVUVEx9XG4gICAgICovXG4gICAgbm9VcGRhdGVUVEw7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heEVudHJ5U2l6ZX1cbiAgICAgKi9cbiAgICBtYXhFbnRyeVNpemU7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnNpemVDYWxjdWxhdGlvbn1cbiAgICAgKi9cbiAgICBzaXplQ2FsY3VsYXRpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbn1cbiAgICAgKi9cbiAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGVsZXRlT25TdGFsZUdldH1cbiAgICAgKi9cbiAgICBub0RlbGV0ZU9uU3RhbGVHZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoQWJvcnR9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmlnbm9yZUZldGNoQWJvcnR9XG4gICAgICovXG4gICAgaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgI3NpemU7XG4gICAgI2NhbGN1bGF0ZWRTaXplO1xuICAgICNrZXlNYXA7XG4gICAgI2tleUxpc3Q7XG4gICAgI3ZhbExpc3Q7XG4gICAgI25leHQ7XG4gICAgI3ByZXY7XG4gICAgI2hlYWQ7XG4gICAgI3RhaWw7XG4gICAgI2ZyZWU7XG4gICAgI2Rpc3Bvc2VkO1xuICAgICNzaXplcztcbiAgICAjc3RhcnRzO1xuICAgICN0dGxzO1xuICAgICNoYXNEaXNwb3NlO1xuICAgICNoYXNGZXRjaE1ldGhvZDtcbiAgICAjaGFzRGlzcG9zZUFmdGVyO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBjYWxsIHRoaXMgbWV0aG9kIHVubGVzcyB5b3UgbmVlZCB0byBpbnNwZWN0IHRoZVxuICAgICAqIGlubmVyIHdvcmtpbmdzIG9mIHRoZSBjYWNoZS4gIElmIGFueXRoaW5nIHJldHVybmVkIGJ5IHRoaXNcbiAgICAgKiBvYmplY3QgaXMgbW9kaWZpZWQgaW4gYW55IHdheSwgc3RyYW5nZSBicmVha2FnZSBtYXkgb2NjdXIuXG4gICAgICpcbiAgICAgKiBUaGVzZSBmaWVsZHMgYXJlIHByaXZhdGUgZm9yIGEgcmVhc29uIVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHVuc2FmZUV4cG9zZUludGVybmFscyhjKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBzdGFydHM6IGMuI3N0YXJ0cyxcbiAgICAgICAgICAgIHR0bHM6IGMuI3R0bHMsXG4gICAgICAgICAgICBzaXplczogYy4jc2l6ZXMsXG4gICAgICAgICAgICBrZXlNYXA6IGMuI2tleU1hcCxcbiAgICAgICAgICAgIGtleUxpc3Q6IGMuI2tleUxpc3QsXG4gICAgICAgICAgICB2YWxMaXN0OiBjLiN2YWxMaXN0LFxuICAgICAgICAgICAgbmV4dDogYy4jbmV4dCxcbiAgICAgICAgICAgIHByZXY6IGMuI3ByZXYsXG4gICAgICAgICAgICBnZXQgaGVhZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jaGVhZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgdGFpbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jdGFpbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmVlOiBjLiNmcmVlLFxuICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kRmV0Y2g6IChwKSA9PiBjLiNpc0JhY2tncm91bmRGZXRjaChwKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRGZXRjaDogKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSA9PiBjLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpLFxuICAgICAgICAgICAgbW92ZVRvVGFpbDogKGluZGV4KSA9PiBjLiNtb3ZlVG9UYWlsKGluZGV4KSxcbiAgICAgICAgICAgIGluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNpbmRleGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgcmluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNyaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIGlzU3RhbGU6IChpbmRleCkgPT4gYy4jaXNTdGFsZShpbmRleCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFByb3RlY3RlZCByZWFkLW9ubHkgbWVtYmVyc1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXh9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heFNpemV9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXhTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY29tcHV0ZWQgc2l6ZSBvZiBpdGVtcyBpbiB0aGUgY2FjaGUgKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgY2FsY3VsYXRlZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjYWxjdWxhdGVkU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBzdG9yZWQgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZmV0Y2hNZXRob2R9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGZldGNoTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmV0Y2hNZXRob2Q7XG4gICAgfVxuICAgIGdldCBtZW1vTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWVtb01ldGhvZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmRpc3Bvc2V9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZGlzcG9zZUFmdGVyfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBkaXNwb3NlQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NlQWZ0ZXI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBtYXggPSAwLCB0dGwsIHR0bFJlc29sdXRpb24gPSAxLCB0dGxBdXRvcHVyZ2UsIHVwZGF0ZUFnZU9uR2V0LCB1cGRhdGVBZ2VPbkhhcywgYWxsb3dTdGFsZSwgZGlzcG9zZSwgZGlzcG9zZUFmdGVyLCBub0Rpc3Bvc2VPblNldCwgbm9VcGRhdGVUVEwsIG1heFNpemUgPSAwLCBtYXhFbnRyeVNpemUgPSAwLCBzaXplQ2FsY3VsYXRpb24sIGZldGNoTWV0aG9kLCBtZW1vTWV0aG9kLCBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sIG5vRGVsZXRlT25TdGFsZUdldCwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGlnbm9yZUZldGNoQWJvcnQsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWF4ICE9PSAwICYmICFpc1Bvc0ludChtYXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggb3B0aW9uIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgVWludEFycmF5ID0gbWF4ID8gZ2V0VWludEFycmF5KG1heCkgOiBBcnJheTtcbiAgICAgICAgaWYgKCFVaW50QXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtYXggdmFsdWU6ICcgKyBtYXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heCA9IG1heDtcbiAgICAgICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIHRoaXMubWF4RW50cnlTaXplID0gbWF4RW50cnlTaXplIHx8IHRoaXMuI21heFNpemU7XG4gICAgICAgIHRoaXMuc2l6ZUNhbGN1bGF0aW9uID0gc2l6ZUNhbGN1bGF0aW9uO1xuICAgICAgICBpZiAodGhpcy5zaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jbWF4U2l6ZSAmJiAhdGhpcy5tYXhFbnRyeVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHNpemVDYWxjdWxhdGlvbiB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gc2V0IHRvIG5vbi1mdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vTWV0aG9kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBtZW1vTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZW1vTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWVtb01ldGhvZCA9IG1lbW9NZXRob2Q7XG4gICAgICAgIGlmIChmZXRjaE1ldGhvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgZmV0Y2hNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZldGNoTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmZXRjaE1ldGhvZCA9IGZldGNoTWV0aG9kO1xuICAgICAgICB0aGlzLiNoYXNGZXRjaE1ldGhvZCA9ICEhZmV0Y2hNZXRob2Q7XG4gICAgICAgIHRoaXMuI2tleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4ja2V5TGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy4jdmFsTGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy4jbmV4dCA9IG5ldyBVaW50QXJyYXkobWF4KTtcbiAgICAgICAgdGhpcy4jcHJldiA9IG5ldyBVaW50QXJyYXkobWF4KTtcbiAgICAgICAgdGhpcy4jaGVhZCA9IDA7XG4gICAgICAgIHRoaXMuI3RhaWwgPSAwO1xuICAgICAgICB0aGlzLiNmcmVlID0gU3RhY2suY3JlYXRlKG1heCk7XG4gICAgICAgIHRoaXMuI3NpemUgPSAwO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZSA9IGRpc3Bvc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlciA9IGRpc3Bvc2VBZnRlcjtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNoYXNEaXNwb3NlID0gISF0aGlzLiNkaXNwb3NlO1xuICAgICAgICB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgPSAhIXRoaXMuI2Rpc3Bvc2VBZnRlcjtcbiAgICAgICAgdGhpcy5ub0Rpc3Bvc2VPblNldCA9ICEhbm9EaXNwb3NlT25TZXQ7XG4gICAgICAgIHRoaXMubm9VcGRhdGVUVEwgPSAhIW5vVXBkYXRlVFRMO1xuICAgICAgICB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9ICEhbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uID0gISFhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gISFhbGxvd1N0YWxlT25GZXRjaEFib3J0O1xuICAgICAgICB0aGlzLmlnbm9yZUZldGNoQWJvcnQgPSAhIWlnbm9yZUZldGNoQWJvcnQ7XG4gICAgICAgIC8vIE5COiBtYXhFbnRyeVNpemUgaXMgc2V0IHRvIG1heFNpemUgaWYgaXQncyBzZXRcbiAgICAgICAgaWYgKHRoaXMubWF4RW50cnlTaXplICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jbWF4U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy4jbWF4U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMubWF4RW50cnlTaXplKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEVudHJ5U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVTaXplVHJhY2tpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG93U3RhbGUgPSAhIWFsbG93U3RhbGU7XG4gICAgICAgIHRoaXMubm9EZWxldGVPblN0YWxlR2V0ID0gISFub0RlbGV0ZU9uU3RhbGVHZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlQWdlT25HZXQgPSAhIXVwZGF0ZUFnZU9uR2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFnZU9uSGFzID0gISF1cGRhdGVBZ2VPbkhhcztcbiAgICAgICAgdGhpcy50dGxSZXNvbHV0aW9uID1cbiAgICAgICAgICAgIGlzUG9zSW50KHR0bFJlc29sdXRpb24pIHx8IHR0bFJlc29sdXRpb24gPT09IDBcbiAgICAgICAgICAgICAgICA/IHR0bFJlc29sdXRpb25cbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIHRoaXMudHRsQXV0b3B1cmdlID0gISF0dGxBdXRvcHVyZ2U7XG4gICAgICAgIHRoaXMudHRsID0gdHRsIHx8IDA7XG4gICAgICAgIGlmICh0aGlzLnR0bCkge1xuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLnR0bCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsaXplVFRMVHJhY2tpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyBub3QgYWxsb3cgY29tcGxldGVseSB1bmJvdW5kZWQgY2FjaGVzXG4gICAgICAgIGlmICh0aGlzLiNtYXggPT09IDAgJiYgdGhpcy50dGwgPT09IDAgJiYgdGhpcy4jbWF4U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXQgbGVhc3Qgb25lIG9mIG1heCwgbWF4U2l6ZSwgb3IgdHRsIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnR0bEF1dG9wdXJnZSAmJiAhdGhpcy4jbWF4ICYmICF0aGlzLiNtYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gJ0xSVV9DQUNIRV9VTkJPVU5ERUQnO1xuICAgICAgICAgICAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuZWQuYWRkKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Jlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLic7XG4gICAgICAgICAgICAgICAgZW1pdFdhcm5pbmcobXNnLCAnVW5ib3VuZGVkQ2FjaGVXYXJuaW5nJywgY29kZSwgTFJVQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG1zIGxlZnQgaW4gdGhlIGl0ZW0ncyBUVEwuIElmIGl0ZW0gaXMgbm90IGluIGNhY2hlLFxuICAgICAqIHJldHVybnMgYDBgLiBSZXR1cm5zIGBJbmZpbml0eWAgaWYgaXRlbSBpcyBpbiBjYWNoZSB3aXRob3V0IGEgZGVmaW5lZCBUVEwuXG4gICAgICovXG4gICAgZ2V0UmVtYWluaW5nVFRMKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4ja2V5TWFwLmhhcyhrZXkpID8gSW5maW5pdHkgOiAwO1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCB0dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICBjb25zdCBzdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIHRoaXMuI3R0bHMgPSB0dGxzO1xuICAgICAgICB0aGlzLiNzdGFydHMgPSBzdGFydHM7XG4gICAgICAgIHRoaXMuI3NldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCwgc3RhcnQgPSBwZXJmLm5vdygpKSA9PiB7XG4gICAgICAgICAgICBzdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gc3RhcnQgOiAwO1xuICAgICAgICAgICAgdHRsc1tpbmRleF0gPSB0dGw7XG4gICAgICAgICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZSh0aGlzLiNrZXlMaXN0W2luZGV4XSwgJ2V4cGlyZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdHRsICsgMSk7XG4gICAgICAgICAgICAgICAgLy8gdW5yZWYoKSBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICBzdGFydHNbaW5kZXhdID0gdHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jc3RhdHVzVFRMID0gKHN0YXR1cywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICh0dGxzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR0bCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGlmICghdHRsIHx8ICFzdGFydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXR1cy50dGwgPSB0dGw7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhdHVzLm5vdyA9IGNhY2hlZE5vdyB8fCBnZXROb3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBzdGF0dXMubm93IC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnJlbWFpbmluZ1RUTCA9IHR0bCAtIGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVib3VuY2UgY2FsbHMgdG8gcGVyZi5ub3coKSB0byAxcyBzbyB3ZSdyZSBub3QgaGl0dGluZ1xuICAgICAgICAvLyB0aGF0IGNvc3RseSBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICAgIGxldCBjYWNoZWROb3cgPSAwO1xuICAgICAgICBjb25zdCBnZXROb3cgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gcGVyZi5ub3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR0bFJlc29sdXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkTm93ID0gbjtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiAoY2FjaGVkTm93ID0gMCksIHRoaXMudHRsUmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVtYWluaW5nVFRMID0ga2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR0bCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCF0dGwgfHwgIXN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWdlID0gKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0dGwgLSBhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2lzU3RhbGUgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiAhIXQgJiYgISFzICYmIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gcyA+IHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNvbmRpdGlvbmFsbHkgc2V0IHByaXZhdGUgbWV0aG9kcyByZWxhdGVkIHRvIFRUTFxuICAgICN1cGRhdGVJdGVtQWdlID0gKCkgPT4geyB9O1xuICAgICNzdGF0dXNUVEwgPSAoKSA9PiB7IH07XG4gICAgI3NldEl0ZW1UVEwgPSAoKSA9PiB7IH07XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAjaXNTdGFsZSA9ICgpID0+IGZhbHNlO1xuICAgICNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCBzaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLiNzaXplcyA9IHNpemVzO1xuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplIC09IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3JlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWxseSBhY2NlcHQgYmFja2dyb3VuZCBmZXRjaGVzLlxuICAgICAgICAgICAgLy8gYWN0dWFsIHZhbHVlIHNpemUgd2lsbCBiZSBjaGVja2VkIHdoZW4gdGhleSByZXR1cm4uXG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNpemVDYWxjdWxhdGlvbih2LCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlciknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzaXplIHZhbHVlIChtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaGVuIG1heFNpemUgb3IgbWF4RW50cnlTaXplIGlzIHVzZWQsIHNpemVDYWxjdWxhdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvciBzaXplIG11c3QgYmUgc2V0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZSA9IChpbmRleCwgc2l6ZSwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzaXplc1tpbmRleF0gPSBzaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gdGhpcy4jbWF4U2l6ZSAtIHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy4jY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2aWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplICs9IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZW50cnlTaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMudG90YWxDYWxjdWxhdGVkU2l6ZSA9IHRoaXMuI2NhbGN1bGF0ZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjcmVtb3ZlSXRlbVNpemUgPSBfaSA9PiB7IH07XG4gICAgI2FkZEl0ZW1TaXplID0gKF9pLCBfcywgX3N0KSA9PiB7IH07XG4gICAgI3JlcXVpcmVTaXplID0gKF9rLCBfdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBvbiBjYWNoZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgKiNpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiN0YWlsOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNwcmV2W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqI3JpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNoZWFkOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNuZXh0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmdldCh0aGlzLiNrZXlMaXN0W2luZGV4XSkgPT09IGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGhpcy4ja2V5TGlzdFtpXSwgdGhpcy4jdmFsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5lbnRyaWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJlbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5rZXlzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBrZXlzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpya2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLnZhbHVlc31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpydmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRpbmcgb3ZlciB0aGUgY2FjaGUgaXRzZWxmIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRzIGFzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBTdHJpbmcgdmFsdWUgdGhhdCBpcyB1c2VkIGluIHRoZSBjcmVhdGlvbiBvZiB0aGUgZGVmYXVsdCBzdHJpbmdcbiAgICAgKiBkZXNjcmlwdGlvbiBvZiBhbiBvYmplY3QuIENhbGxlZCBieSB0aGUgYnVpbHQtaW4gbWV0aG9kXG4gICAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqL1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0xSVUNhY2hlJztcbiAgICAvKipcbiAgICAgKiBGaW5kIGEgdmFsdWUgZm9yIHdoaWNoIHRoZSBzdXBwbGllZCBmbiBtZXRob2QgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSxcbiAgICAgKiBzaW1pbGFyIHRvIGBBcnJheS5maW5kKClgLiBmbiBpcyBjYWxsZWQgYXMgYGZuKHZhbHVlLCBrZXksIGNhY2hlKWAuXG4gICAgICovXG4gICAgZmluZChmbiwgZ2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZuKHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLiNrZXlMaXN0W2ldLCBnZXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0gaW4gdGhlIGNhY2hlLCBpbiBvcmRlciBmcm9tIG1vc3RcbiAgICAgKiByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICpcbiAgICAgKiBgZm5gIGlzIGNhbGxlZCBhcyBgZm4odmFsdWUsIGtleSwgY2FjaGUpYC5cbiAgICAgKlxuICAgICAqIElmIGB0aGlzcGAgaXMgcHJvdmlkZWQsIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgdGhpc2AtY29udGV4dCBvZlxuICAgICAqIHRoZSBwcm92aWRlZCBvYmplY3QsIG9yIHRoZSBjYWNoZSBpZiBubyBgdGhpc3BgIG9iamVjdCBpcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHVwZGF0ZSBhZ2Ugb3IgcmVjZW50eSBvZiB1c2UsIG9yIGl0ZXJhdGUgb3ZlciBzdGFsZSB2YWx1ZXMuXG4gICAgICovXG4gICAgZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIHtAbGluayBMUlVDYWNoZS5mb3JFYWNofSBidXQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgaW5cbiAgICAgKiByZXZlcnNlIG9yZGVyLiAgKGllLCBsZXNzIHJlY2VudGx5IHVzZWQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgZmlyc3QuKVxuICAgICAqL1xuICAgIHJmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbnkgc3RhbGUgZW50cmllcy4gUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdhcyByZW1vdmVkLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdXJnZVN0YWxlKCkge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZSh0aGlzLiNrZXlMaXN0W2ldLCAnZXhwaXJlJyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXh0ZW5kZWQgaW5mbyBhYm91dCBhIGdpdmVuIGVudHJ5LCB0byBnZXQgaXRzIHZhbHVlLCBzaXplLCBhbmRcbiAgICAgKiBUVEwgaW5mbyBzaW11bHRhbmVvdXNseS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUga2V5IGlzIG5vdCBwcmVzZW50LlxuICAgICAqXG4gICAgICogVW5saWtlIHtAbGluayBMUlVDYWNoZSNkdW1wfSwgd2hpY2ggaXMgZGVzaWduZWQgdG8gYmUgcG9ydGFibGUgYW5kIHN1cnZpdmVcbiAgICAgKiBzZXJpYWxpemF0aW9uLCB0aGUgYHN0YXJ0YCB2YWx1ZSBpcyBhbHdheXMgdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBhbmQgdGhlXG4gICAgICogYHR0bGAgaXMgYSBjYWxjdWxhdGVkIHJlbWFpbmluZyB0aW1lIHRvIGxpdmUgKG5lZ2F0aXZlIGlmIGV4cGlyZWQpLlxuICAgICAqXG4gICAgICogQWx3YXlzIHJldHVybnMgc3RhbGUgdmFsdWVzLCBpZiB0aGVpciBpbmZvIGlzIGZvdW5kIGluIHRoZSBjYWNoZSwgc28gYmVcbiAgICAgKiBzdXJlIHRvIGNoZWNrIGZvciBleHBpcmF0aW9ucyAoaWUsIGEgbmVnYXRpdmUge0BsaW5rIExSVUNhY2hlLkVudHJ5I3R0bH0pXG4gICAgICogaWYgcmVsZXZhbnQuXG4gICAgICovXG4gICAgaW5mbyhrZXkpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuI2tleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgIDogdjtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICBpZiAodHRsICYmIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluID0gdHRsIC0gKHBlcmYubm93KCkgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgZW50cnkudHRsID0gcmVtYWluO1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLiNzaXplc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBba2V5LCB7QGxpbmsgTFJVQ2FjaGUuRW50cnl9XSB0dXBsZXMgd2hpY2ggY2FuIGJlXG4gICAgICogcGFzc2VkIHRvIHtAbGluayBMUkxVQ2FjaGUjbG9hZH0uXG4gICAgICpcbiAgICAgKiBUaGUgYHN0YXJ0YCBmaWVsZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gYSBwb3J0YWJsZSBgRGF0ZS5ub3coKWBcbiAgICAgKiB0aW1lc3RhbXAsIGV2ZW4gaWYgYHBlcmZvcm1hbmNlLm5vdygpYCBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBTdGFsZSBlbnRyaWVzIGFyZSBhbHdheXMgaW5jbHVkZWQgaW4gdGhlIGBkdW1wYCwgZXZlbiBpZlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlfSBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgcmV0dXJucyBhbiBhY3R1YWwgYXJyYXksIG5vdCBhIGdlbmVyYXRvciwgc28gaXQgY2FuIGJlIG1vcmVcbiAgICAgKiBlYXNpbHkgcGFzc2VkIGFyb3VuZC5cbiAgICAgKi9cbiAgICBkdW1wKCkge1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwga2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgICAgIGVudHJ5LnR0bCA9IHRoaXMuI3R0bHNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGR1bXAgdGhlIHN0YXJ0IHJlbGF0aXZlIHRvIGEgcG9ydGFibGUgdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gcGVyZi5ub3coKSAtIHRoaXMuI3N0YXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAtIGFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5zaXplID0gdGhpcy4jc2l6ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjYWNoZSBhbmQgbG9hZCBpbiB0aGUgaXRlbXMgaW4gZW50cmllcyBpbiB0aGUgb3JkZXIgbGlzdGVkLlxuICAgICAqXG4gICAgICogVGhlIHNoYXBlIG9mIHRoZSByZXN1bHRpbmcgY2FjaGUgbWF5IGJlIGRpZmZlcmVudCBpZiB0aGUgc2FtZSBvcHRpb25zIGFyZVxuICAgICAqIG5vdCB1c2VkIGluIGJvdGggY2FjaGVzLlxuICAgICAqXG4gICAgICogVGhlIGBzdGFydGAgZmllbGRzIGFyZSBhc3N1bWVkIHRvIGJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gYSBwb3J0YWJsZVxuICAgICAqIGBEYXRlLm5vdygpYCB0aW1lc3RhbXAsIGV2ZW4gaWYgYHBlcmZvcm1hbmNlLm5vdygpYCBpcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgbG9hZChhcnIpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5zdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIGVudHJ5LnN0YXJ0IGlzIGEgcG9ydGFibGUgdGltZXN0YW1wLCBidXQgd2UgbWF5IGJlIHVzaW5nXG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIHBlcmZvcm1hbmNlLm5vdygpLCBzbyBjYWxjdWxhdGUgdGhlIG9mZnNldCwgc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgaW50ZW5kZWQgcmVtYWluaW5nIFRUTCwgbm8gbWF0dGVyIGhvdyBsb25nIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBiZWVuIG9uIGljZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSBlbnRyeS5zdGFydDtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IHBlcmYubm93KCkgLSBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIGVudHJ5LnZhbHVlLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgYHVuZGVmaW5lZGAgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUsIHRoaXMgaXMgYW4gYWxpYXMgZm9yXG4gICAgICoge0BsaW5rIExSVUNhY2hlI2RlbGV0ZX1cbiAgICAgKlxuICAgICAqIEZpZWxkcyBvbiB0aGUge0BsaW5rIExSVUNhY2hlLlNldE9wdGlvbnN9IG9wdGlvbnMgcGFyYW0gd2lsbCBvdmVycmlkZVxuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgdmFsdWVzIGluIHRoZSBjb25zdHJ1Y3RvciBvcHRpb25zIGZvciB0aGUgc2NvcGVcbiAgICAgKiBvZiB0aGlzIHNpbmdsZSBgc2V0KClgIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGBzdGFydGAgaXMgcHJvdmlkZWQsIHRoZW4gdGhhdCB3aWxsIHNldCB0aGUgZWZmZWN0aXZlIHN0YXJ0XG4gICAgICogdGltZSBmb3IgdGhlIFRUTCBjYWxjdWxhdGlvbi4gTm90ZSB0aGF0IHRoaXMgbXVzdCBiZSBhIHByZXZpb3VzXG4gICAgICogdmFsdWUgb2YgYHBlcmZvcm1hbmNlLm5vdygpYCBpZiBzdXBwb3J0ZWQsIG9yIGEgcHJldmlvdXMgdmFsdWUgb2ZcbiAgICAgKiBgRGF0ZS5ub3coKWAgaWYgbm90LlxuICAgICAqXG4gICAgICogT3B0aW9ucyBvYmplY3QgbWF5IGFsc28gaW5jbHVkZSBgc2l6ZWAsIHdoaWNoIHdpbGwgcHJldmVudFxuICAgICAqIGNhbGxpbmcgdGhlIGBzaXplQ2FsY3VsYXRpb25gIGZ1bmN0aW9uIGFuZCBqdXN0IHVzZSB0aGUgc3BlY2lmaWVkXG4gICAgICogbnVtYmVyIGlmIGl0IGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYW5kIGBub0Rpc3Bvc2VPblNldGAgd2hpY2hcbiAgICAgKiB3aWxsIHByZXZlbnQgY2FsbGluZyBhIGBkaXNwb3NlYCBmdW5jdGlvbiBpbiB0aGUgY2FzZSBvZlxuICAgICAqIG92ZXJ3cml0ZXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHNpemVgIChvciByZXR1cm4gdmFsdWUgb2YgYHNpemVDYWxjdWxhdGlvbmApIGZvciBhIGdpdmVuXG4gICAgICogZW50cnkgaXMgZ3JlYXRlciB0aGFuIGBtYXhFbnRyeVNpemVgLCB0aGVuIHRoZSBpdGVtIHdpbGwgbm90IGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogV2lsbCB1cGRhdGUgdGhlIHJlY2VuY3kgb2YgdGhlIGVudHJ5LlxuICAgICAqXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIGB1bmRlZmluZWRgLCB0aGVuIHRoaXMgaXMgYW4gYWxpYXMgZm9yXG4gICAgICogYGNhY2hlLmRlbGV0ZShrZXkpYC4gYHVuZGVmaW5lZGAgaXMgbmV2ZXIgc3RvcmVkIGluIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBzZXQoaywgdiwgc2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0dGwgPSB0aGlzLnR0bCwgc3RhcnQsIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIHN0YXR1cywgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGxldCB7IG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCB9ID0gc2V0T3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuI3JlcXVpcmVTaXplKGssIHYsIHNldE9wdGlvbnMuc2l6ZSB8fCAwLCBzaXplQ2FsY3VsYXRpb24pO1xuICAgICAgICAvLyBpZiB0aGUgaXRlbSBkb2Vzbid0IGZpdCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBzZXQgdG8gbWF4U2l6ZSBieSBkZWZhdWx0XG4gICAgICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAmJiBzaXplID4gdGhpcy5tYXhFbnRyeVNpemUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ21pc3MnO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5tYXhFbnRyeVNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYXZlIHRvIGRlbGV0ZSwgaW4gY2FzZSBzb21ldGhpbmcgaXMgdGhlcmUgYWxyZWFkeS5cbiAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnc2V0Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiNzaXplID09PSAwID8gdW5kZWZpbmVkIDogdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uXG4gICAgICAgICAgICBpbmRleCA9ICh0aGlzLiNzaXplID09PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLiN0YWlsXG4gICAgICAgICAgICAgICAgOiB0aGlzLiNmcmVlLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2ZyZWUucG9wKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplID09PSB0aGlzLiNtYXhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy4jZXZpY3QoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI3NpemUpO1xuICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpbmRleF0gPSBrO1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB2O1xuICAgICAgICAgICAgdGhpcy4ja2V5TWFwLnNldChrLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiNuZXh0W3RoaXMuI3RhaWxdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiNwcmV2W2luZGV4XSA9IHRoaXMuI3RhaWw7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiNzaXplKys7XG4gICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdhZGQnO1xuICAgICAgICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy4jbW92ZVRvVGFpbChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWwgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRmV0Y2hNZXRob2QgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRWYWwuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdyZXBsYWNlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfX3N0YWxlV2hpbGVGZXRjaGluZzogcyB9ID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkICYmICFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4ocywgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtzLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKG9sZFZhbCwgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAncmVwbGFjZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb2xkVmFsICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb2xkVmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3VwZGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR0bCAhPT0gMCAmJiAhdGhpcy4jdHRscykge1xuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIGlmICghbm9VcGRhdGVUVEwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzZXRJdGVtVFRMKGluZGV4LCB0dGwsIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9EaXNwb3NlT25TZXQgJiYgdGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZpY3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbSwgcmV0dXJuaW5nIGl0cyB2YWx1ZSBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIGNhY2hlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy4jdmFsTGlzdFt0aGlzLiNoZWFkXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNldmljdCh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjZXZpY3QoZnJlZSkge1xuICAgICAgICBjb25zdCBoZWFkID0gdGhpcy4jaGVhZDtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaGVhZF07XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2hlYWRdO1xuICAgICAgICBpZiAodGhpcy4jaGFzRmV0Y2hNZXRob2QgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdldmljdGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UgfHwgdGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCAnZXZpY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgJ2V2aWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGhlYWQpO1xuICAgICAgICAvLyBpZiB3ZSBhcmVuJ3QgYWJvdXQgdG8gdXNlIHRoZSBpbmRleCwgdGhlbiBudWxsIHRoZXNlIG91dFxuICAgICAgICBpZiAoZnJlZSkge1xuICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtoZWFkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLnB1c2goaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgICAgIHRoaXMuI2ZyZWUubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2hlYWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2tleU1hcC5kZWxldGUoayk7XG4gICAgICAgIHRoaXMuI3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGluIHRoZSBjYWNoZSwgd2l0aG91dCB1cGRhdGluZyB0aGUgcmVjZW5jeSBvZiB1c2UuXG4gICAgICogV2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIGV2ZW4gdGhvdWdoIGl0IGlzIHRlY2huaWNhbGx5XG4gICAgICogaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaXMgaW4gdGhlIGNhY2hlLCB3aXRob3V0IHVwZGF0aW5nIHRoZSByZWNlbmN5IG9mXG4gICAgICogdXNlLiBBZ2UgaXMgdXBkYXRlZCBpZiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9IGlzIHNldFxuICAgICAqIHRvIGB0cnVlYCBpbiBlaXRoZXIgdGhlIG9wdGlvbnMgb3IgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogV2lsbCByZXR1cm4gYGZhbHNlYCBpZiB0aGUgaXRlbSBpcyBzdGFsZSwgZXZlbiB0aG91Z2ggaXQgaXMgdGVjaG5pY2FsbHkgaW5cbiAgICAgKiB0aGUgY2FjaGUuIFRoZSBkaWZmZXJlbmNlIGNhbiBiZSBkZXRlcm1pbmVkIChpZiBpdCBtYXR0ZXJzKSBieSB1c2luZyBhXG4gICAgICogYHN0YXR1c2AgYXJndW1lbnQsIGFuZCBpbnNwZWN0aW5nIHRoZSBgaGFzYCBmaWVsZC5cbiAgICAgKlxuICAgICAqIFdpbGwgbm90IHVwZGF0ZSBpdGVtIGFnZSB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9IGlzIHNldC5cbiAgICAgKi9cbiAgICBoYXMoaywgaGFzT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlQWdlT25IYXMgPSB0aGlzLnVwZGF0ZUFnZU9uSGFzLCBzdGF0dXMgfSA9IGhhc09wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSAmJlxuICAgICAgICAgICAgICAgIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdoaXQnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2Uge0BsaW5rIExSVUNhY2hlI2dldH0gYnV0IGRvZXNuJ3QgdXBkYXRlIHJlY2VuY3kgb3IgZGVsZXRlIHN0YWxlXG4gICAgICogaXRlbXMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX0gaXMgc2V0LlxuICAgICAqL1xuICAgIHBlZWsoaywgcGVla09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHBlZWtPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoIWFsbG93U3RhbGUgJiYgdGhpcy4jaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAvLyBlaXRoZXIgc3RhbGUgYW5kIGFsbG93ZWQsIG9yIGZvcmNpbmcgYSByZWZyZXNoIG9mIG5vbi1zdGFsZSB2YWx1ZVxuICAgICAgICByZXR1cm4gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdjtcbiAgICB9XG4gICAgI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFDKCk7XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICAvLyB3aGVuL2lmIG91ciBBQyBzaWduYWxzLCB0aGVuIHN0b3AgbGlzdGVuaW5nIHRvIHRoZWlycy5cbiAgICAgICAgc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGFjLmFib3J0KHNpZ25hbC5yZWFzb24pLCB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNiID0gKHYsIHVwZGF0ZUNhY2hlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWJvcnRlZCB9ID0gYWMuc2lnbmFsO1xuICAgICAgICAgICAgY29uc3QgaWdub3JlQWJvcnQgPSBvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgJiYgdiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoQWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBhYy5zaWduYWwucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlQWJvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0SWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCAmJiAhaWdub3JlQWJvcnQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRmFpbChhYy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVpdGhlciB3ZSBkaWRuJ3QgYWJvcnQsIGFuZCBhcmUgc3RpbGwgaGVyZSwgb3Igd2UgZGlkLCBhbmQgaWdub3JlZFxuICAgICAgICAgICAgY29uc3QgYmYgPSBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ2ZldGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGssIHYsIGZldGNoT3B0cy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWIgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoZXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmZXRjaEZhaWwgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWJvcnRlZCB9ID0gYWMuc2lnbmFsO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTdGFsZUFib3J0ZWQgPSBhYm9ydGVkICYmIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGUgPSBhbGxvd1N0YWxlQWJvcnRlZCB8fCBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9EZWxldGUgPSBhbGxvd1N0YWxlIHx8IG9wdGlvbnMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgYmYgPSBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxsb3cgc3RhbGUgb24gZmV0Y2ggcmVqZWN0aW9ucywgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0YWxlIHZhbHVlIGlzIG5vdCByZW1vdmVkIGZyb20gdGhlIGNhY2hlIHdoZW4gdGhlIGZldGNoIGZhaWxzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbCA9ICFub0RlbGV0ZSB8fCBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChkZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdmZXRjaCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWxsb3dTdGFsZUFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSB0aGUgKnByb21pc2UqIHdpdGggdGhlIHN0YWxlIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBwcm9taXNlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxlYXZlIGl0IHVudG91Y2hlZCBpZiB3ZSdyZSBzdGlsbCB3YWl0aW5nIGZvciBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydGVkIGJhY2tncm91bmQgZmV0Y2ggdGhhdCBoYXNuJ3QgeWV0IHJldHVybmVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzICYmIGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJmLl9fcmV0dXJuZWQgPT09IGJmKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjYWxsID0gKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbXAgPSB0aGlzLiNmZXRjaE1ldGhvZD8uKGssIHYsIGZldGNoT3B0cyk7XG4gICAgICAgICAgICBpZiAoZm1wICYmIGZtcCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBmbXAudGhlbih2ID0+IHJlcyh2ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB2KSwgcmVqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlnbm9yZWQsIHdlIGdvIHVudGlsIHdlIGZpbmlzaCwgcmVnYXJkbGVzcy5cbiAgICAgICAgICAgIC8vIGRlZmVyIGNoZWNrIHVudGlsIHdlIGFyZSBhY3R1YWxseSBhYm9ydGluZyxcbiAgICAgICAgICAgIC8vIHNvIGZldGNoTWV0aG9kIGNhbiBvdmVycmlkZS5cbiAgICAgICAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gaXQgZXZlbnR1YWxseSByZXNvbHZlcywgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdiA9PiBjYih2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaERpc3BhdGNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UocGNhbGwpLnRoZW4oY2IsIGViKTtcbiAgICAgICAgY29uc3QgYmYgPSBPYmplY3QuYXNzaWduKHAsIHtcbiAgICAgICAgICAgIF9fYWJvcnRDb250cm9sbGVyOiBhYyxcbiAgICAgICAgICAgIF9fc3RhbGVXaGlsZUZldGNoaW5nOiB2LFxuICAgICAgICAgICAgX19yZXR1cm5lZDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmFsLCBkb24ndCBleHBvc2Ugc3RhdHVzLlxuICAgICAgICAgICAgdGhpcy5zZXQoaywgYmYsIHsgLi4uZmV0Y2hPcHRzLm9wdGlvbnMsIHN0YXR1czogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgICNpc0JhY2tncm91bmRGZXRjaChwKSB7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGIgPSBwO1xuICAgICAgICByZXR1cm4gKCEhYiAmJlxuICAgICAgICAgICAgYiBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgIGIuaGFzT3duUHJvcGVydHkoJ19fc3RhbGVXaGlsZUZldGNoaW5nJykgJiZcbiAgICAgICAgICAgIGIuX19hYm9ydENvbnRyb2xsZXIgaW5zdGFuY2VvZiBBQyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIFxuICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICB0dGwgPSB0aGlzLnR0bCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCwgXG4gICAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGlnbm9yZUZldGNoQWJvcnQgPSB0aGlzLmlnbm9yZUZldGNoQWJvcnQsIGFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGNvbnRleHQsIGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBzdGF0dXMsIHNpZ25hbCwgfSA9IGZldGNoT3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnZ2V0JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICAgICAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0LFxuICAgICAgICAgICAgaWdub3JlRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ21pc3MnO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKHAuX19yZXR1cm5lZCA9IHApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWxlID0gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaW5mbGlnaHQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFsZSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAodi5fX3JldHVybmVkID0gdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3JjZSBhIHJlZnJlc2gsIHRoYXQgbWVhbnMgZG8gTk9UIHNlcnZlIHRoZSBjYWNoZWQgdmFsdWUsXG4gICAgICAgICAgICAvLyB1bmxlc3Mgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmcmVzaGluZyB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBpc1N0YWxlID0gdGhpcy4jaXNTdGFsZShpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiAhaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlIG9yIGEgZm9yY2VkIHJlZnJlc2gsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZy5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGFsZSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YWxlVmFsID0gaGFzU3RhbGUgJiYgYWxsb3dTdGFsZTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSBpc1N0YWxlID8gJ3N0YWxlJyA6ICdyZWZyZXNoJztcbiAgICAgICAgICAgICAgICBpZiAoc3RhbGVWYWwgJiYgaXNTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWxlVmFsID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmb3JjZUZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCB0aGlzLmZldGNoKGssIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoKCkgcmV0dXJuZWQgdW5kZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBtZW1vKGssIG1lbW9PcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbWVtb01ldGhvZCA9IHRoaXMuI21lbW9NZXRob2Q7XG4gICAgICAgIGlmICghbWVtb01ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtZW1vTWV0aG9kIHByb3ZpZGVkIHRvIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCBmb3JjZVJlZnJlc2gsIC4uLm9wdGlvbnMgfSA9IG1lbW9PcHRpb25zO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5nZXQoaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjb25zdCB2diA9IG1lbW9NZXRob2Qoaywgdiwge1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldChrLCB2diwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB2djtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmFsdWUgZnJvbSB0aGUgY2FjaGUuIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBjYWNoZVxuICAgICAqIGVudHJ5IGZvdW5kLlxuICAgICAqXG4gICAgICogSWYgdGhlIGtleSBpcyBub3QgZm91bmQsIGdldCgpIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGdldChrLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBzdGF0dXMsIH0gPSBnZXRPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvbmx5IGlmIG5vdCBhbiBpbi1mbGlnaHQgYmFja2dyb3VuZCBmZXRjaFxuICAgICAgICAgICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0RlbGV0ZU9uU3RhbGVHZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnZXhwaXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBhbGxvd1N0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdGFsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHN0YWxlLCBhbmQgZmV0Y2hpbmcsIEFORCBoYXMgYSBfX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlLCB0aGVuIHRoYXQgbWVhbnMgdGhlIHVzZXIgZmV0Y2hlZCB3aXRoIHtmb3JjZVJlZnJlc2g6dHJ1ZX0sXG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBzYWZlIHRvIHJldHVybiB0aGF0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAjY29ubmVjdChwLCBuKSB7XG4gICAgICAgIHRoaXMuI3ByZXZbbl0gPSBwO1xuICAgICAgICB0aGlzLiNuZXh0W3BdID0gbjtcbiAgICB9XG4gICAgI21vdmVUb1RhaWwoaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAgICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgICAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAgICAgLy8gdGFpbCA9IGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiNwcmV2W2luZGV4XSwgdGhpcy4jbmV4dFtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiN0YWlsLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGtleSBvdXQgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgd2FzIGRlbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBkZWxldGUoaykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVsZXRlKGssICdkZWxldGUnKTtcbiAgICB9XG4gICAgI2RlbGV0ZShrLCByZWFzb24pIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2xlYXIocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UgfHwgdGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCByZWFzb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdGFpbCA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV4dFtwaV0gPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5pID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNwcmV2W25pXSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NpemUtLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlIGVudGlyZWx5LCB0aHJvd2luZyBhd2F5IGFsbCB2YWx1ZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjbGVhcignZGVsZXRlJyk7XG4gICAgfVxuICAgICNjbGVhcihyZWFzb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCByZWFzb25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4ja2V5TWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICB0aGlzLiN0dGxzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLiNzdGFydHMuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuI3NpemVzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGVhZCA9IDA7XG4gICAgICAgIHRoaXMuI3RhaWwgPSAwO1xuICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js\n");

/***/ })

};
;