"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dedent";
exports.ids = ["vendor-chunks/dedent"];
exports.modules = {

/***/ "(ssr)/../node_modules/dedent/dist/dedent.mjs":
/*!**********************************************!*\
  !*** ../node_modules/dedent/dist/dedent.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst dedent = createDedent({});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dedent);\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      alignValues = false,\n      escapeSpecialCharacters = Array.isArray(strings),\n      trimWhitespace = true\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        const value = alignValues ? alignValue(values[i], result) : values[i];\n\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += value;\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n\n    // dedent eats leading and trailing whitespace too\n    if (trimWhitespace) {\n      result = result.trim();\n    }\n\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    if (escapeSpecialCharacters) {\n      result = result.replace(/\\\\n/g, \"\\n\");\n    }\n    return result;\n  }\n}\n\n/**\n * Adjusts the indentation of a multi-line interpolated value to match the current line.\n */\nfunction alignValue(value, precedingText) {\n  if (typeof value !== \"string\" || !value.includes(\"\\n\")) {\n    return value;\n  }\n  const currentLine = precedingText.slice(precedingText.lastIndexOf(\"\\n\") + 1);\n  const indentMatch = currentLine.match(/^(\\s+)/);\n  if (indentMatch) {\n    const indent = indentMatch[1];\n    return value.replace(/\\n/g, `\\n${indent}`);\n  }\n  return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2RlZGVudC9kaXN0L2RlZGVudC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7QUFDblUsOEJBQThCO0FBQzlCLGlFQUFlLE1BQU0sRUFBQztBQUN0QjtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLE1BQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96a2RhdGF2YXVsdC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZGVkZW50L2Rpc3QvZGVkZW50Lm1qcz85YTJjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuY29uc3QgZGVkZW50ID0gY3JlYXRlRGVkZW50KHt9KTtcbmV4cG9ydCBkZWZhdWx0IGRlZGVudDtcbmZ1bmN0aW9uIGNyZWF0ZURlZGVudChvcHRpb25zKSB7XG4gIGRlZGVudC53aXRoT3B0aW9ucyA9IG5ld09wdGlvbnMgPT4gY3JlYXRlRGVkZW50KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIG5ld09wdGlvbnMpKTtcbiAgcmV0dXJuIGRlZGVudDtcbiAgZnVuY3Rpb24gZGVkZW50KHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgIGNvbnN0IHJhdyA9IHR5cGVvZiBzdHJpbmdzID09PSBcInN0cmluZ1wiID8gW3N0cmluZ3NdIDogc3RyaW5ncy5yYXc7XG4gICAgY29uc3Qge1xuICAgICAgYWxpZ25WYWx1ZXMgPSBmYWxzZSxcbiAgICAgIGVzY2FwZVNwZWNpYWxDaGFyYWN0ZXJzID0gQXJyYXkuaXNBcnJheShzdHJpbmdzKSxcbiAgICAgIHRyaW1XaGl0ZXNwYWNlID0gdHJ1ZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gZmlyc3QsIHBlcmZvcm0gaW50ZXJwb2xhdGlvblxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbmV4dCA9IHJhd1tpXTtcbiAgICAgIGlmIChlc2NhcGVTcGVjaWFsQ2hhcmFjdGVycykge1xuICAgICAgICAvLyBoYW5kbGUgZXNjYXBlZCBuZXdsaW5lcywgYmFja3RpY2tzLCBhbmQgaW50ZXJwb2xhdGlvbiBjaGFyYWN0ZXJzXG4gICAgICAgIG5leHQgPSBuZXh0LnJlcGxhY2UoL1xcXFxcXG5bIFxcdF0qL2csIFwiXCIpLnJlcGxhY2UoL1xcXFxgL2csIFwiYFwiKS5yZXBsYWNlKC9cXFxcXFwkL2csIFwiJFwiKS5yZXBsYWNlKC9cXFxcXFx7L2csIFwie1wiKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgICAgaWYgKGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWxpZ25WYWx1ZXMgPyBhbGlnblZhbHVlKHZhbHVlc1tpXSwgcmVzdWx0KSA6IHZhbHVlc1tpXTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHNcbiAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyBzdHJpcCBpbmRlbnRhdGlvblxuICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0LnNwbGl0KFwiXFxuXCIpO1xuICAgIGxldCBtaW5kZW50ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGwgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IG0gPSBsLm1hdGNoKC9eKFxccyspXFxTKy8pO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gbVsxXS5sZW5ndGg7XG4gICAgICAgIGlmICghbWluZGVudCkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZpcnN0IGluZGVudGVkIGxpbmVcbiAgICAgICAgICBtaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pbmRlbnQgPSBNYXRoLm1pbihtaW5kZW50LCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtID0gbWluZGVudDsgLy8gYXBwZWFzZSBUeXBlU2NyaXB0XG4gICAgICByZXN1bHQgPSBsaW5lc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R5cGVzY3JpcHQtZXNsaW50L3R5cGVzY3JpcHQtZXNsaW50L2lzc3Vlcy83MTQwXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1zdHJpbmctc3RhcnRzLWVuZHMtd2l0aFxuICAgICAgLm1hcChsID0+IGxbMF0gPT09IFwiIFwiIHx8IGxbMF0gPT09IFwiXFx0XCIgPyBsLnNsaWNlKG0pIDogbCkuam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICAvLyBkZWRlbnQgZWF0cyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvb1xuICAgIGlmICh0cmltV2hpdGVzcGFjZSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZXNjYXBlZCBuZXdsaW5lcyBhdCB0aGUgZW5kIHRvIGVuc3VyZSB0aGV5IGRvbid0IGdldCBzdHJpcHBlZCB0b29cbiAgICBpZiAoZXNjYXBlU3BlY2lhbENoYXJhY3RlcnMpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXFxcbi9nLCBcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIEFkanVzdHMgdGhlIGluZGVudGF0aW9uIG9mIGEgbXVsdGktbGluZSBpbnRlcnBvbGF0ZWQgdmFsdWUgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgbGluZS5cbiAqL1xuZnVuY3Rpb24gYWxpZ25WYWx1ZSh2YWx1ZSwgcHJlY2VkaW5nVGV4dCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBjdXJyZW50TGluZSA9IHByZWNlZGluZ1RleHQuc2xpY2UocHJlY2VkaW5nVGV4dC5sYXN0SW5kZXhPZihcIlxcblwiKSArIDEpO1xuICBjb25zdCBpbmRlbnRNYXRjaCA9IGN1cnJlbnRMaW5lLm1hdGNoKC9eKFxccyspLyk7XG4gIGlmIChpbmRlbnRNYXRjaCkge1xuICAgIGNvbnN0IGluZGVudCA9IGluZGVudE1hdGNoWzFdO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgYFxcbiR7aW5kZW50fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/dedent/dist/dedent.mjs\n");

/***/ })

};
;