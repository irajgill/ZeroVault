"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/walrus-client.ts":
/*!**********************************!*\
  !*** ./src/lib/walrus-client.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBlobExists: function() { return /* binding */ checkBlobExists; },\n/* harmony export */   downloadFromWalrus: function() { return /* binding */ downloadFromWalrus; },\n/* harmony export */   getBlobUrl: function() { return /* binding */ getBlobUrl; },\n/* harmony export */   uploadToWalrus: function() { return /* binding */ uploadToWalrus; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/../node_modules/axios/lib/axios.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/constants */ \"(app-pages-browser)/./src/constants/index.ts\");\n\n\n/**\n * Upload a file to the backend which encrypts (Seal placeholder) and stores in Walrus.\n * Backend endpoint: POST /api/upload/dataset\n */ async function uploadToWalrus(file) {\n    try {\n        // Read file as base64 (without data URL prefix)\n        const arrayBuffer = await file.arrayBuffer();\n        const base64 = bufferToBase64(new Uint8Array(arrayBuffer));\n        const body = {\n            file: base64,\n            originalFilename: file.name,\n            contentType: file.type || \"application/octet-stream\",\n            metadata: {\n                name: file.name || \"dataset\",\n                description: \"Uploaded via ZeroVault (\".concat(new Date().toISOString(), \")\"),\n                price: \"0\"\n            }\n        };\n        const url = \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_0__.BACKEND_URL, \"/api/upload/dataset\");\n        const resp = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(url, body, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            timeout: 60000\n        });\n        // Backend returns: { dataset_id?, blob_id, seal_policy_id, upload_size, metadata, quality_* }\n        const data = resp.data || {};\n        if (!data.blob_id) throw new Error(\"Upload did not return blob_id\");\n        const result = {\n            dataset_id: data.dataset_id,\n            blob_id: data.blob_id,\n            seal_policy_id: data.seal_policy_id,\n            upload_size: Number(data.upload_size || 0),\n            metadata: data.metadata,\n            quality_score: typeof data.quality_score === \"number\" ? data.quality_score : undefined,\n            is_valid: typeof data.is_valid === \"boolean\" ? data.is_valid : undefined,\n            attestation: typeof data.attestation === \"string\" ? data.attestation : undefined,\n            timestamp_ms: typeof data.timestamp_ms === \"number\" ? data.timestamp_ms : undefined\n        };\n        return result;\n    } catch (err) {\n        throw wrapAxiosError(err, \"Failed to upload dataset to Walrus via backend\");\n    }\n}\n/**\n * Download a Walrus blob from the aggregator.\n * Returns a Blob with best-effort content type.\n */ async function downloadFromWalrus(blobId) {\n    try {\n        const url = getBlobUrl(blobId);\n        const resp = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(url, {\n            responseType: \"arraybuffer\",\n            timeout: 60000\n        });\n        const contentType = resp.headers[\"content-type\"] || \"application/octet-stream\";\n        return new Blob([\n            resp.data\n        ], {\n            type: contentType\n        });\n    } catch (err) {\n        throw wrapAxiosError(err, \"Failed to download Walrus blob \".concat(blobId));\n    }\n}\n/**\n * Return the public URL to a Walrus blob on the aggregator.\n */ function getBlobUrl(blobId) {\n    // Walrus testnet aggregator exposes blobs under /v1/blobs/{blob_id}\n    return \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_0__.WALRUS_URLS.aggregator, \"/v1/blobs/\").concat(encodeURIComponent(blobId));\n}\n/**\n * Check if a Walrus blob exists using HEAD; falls back to GET if HEAD not supported.\n */ async function checkBlobExists(blobId) {\n    const url = getBlobUrl(blobId);\n    try {\n        await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].head(url, {\n            timeout: 10000\n        });\n        return true;\n    } catch (e) {\n        const err = e;\n        // Some servers may not support HEAD; fall back to GET\n        if (err.response && err.response.status === 405) {\n            try {\n                await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(url, {\n                    timeout: 10000\n                });\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        if (err.response && err.response.status === 404) return false;\n        // On network errors, report false\n        return false;\n    }\n}\n// Helpers\nfunction bufferToBase64(bytes) {\n    let binary = \"\";\n    const chunkSize = 0x8000;\n    for(let i = 0; i < bytes.length; i += chunkSize){\n        const chunk = bytes.subarray(i, i + chunkSize);\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\n    }\n    return btoa(binary);\n}\nfunction wrapAxiosError(err, prefix) {\n    if (axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isAxiosError(err)) {\n        var _err_response;\n        const code = err.code ? \" (\".concat(err.code, \")\") : \"\";\n        const status = ((_err_response = err.response) === null || _err_response === void 0 ? void 0 : _err_response.status) ? \" [HTTP \".concat(err.response.status, \"]\") : \"\";\n        const msg = err.message || \"unknown axios error\";\n        return new Error(\"\".concat(prefix, \": \").concat(msg).concat(code).concat(status));\n    }\n    return new Error(\"\".concat(prefix, \": \").concat((err === null || err === void 0 ? void 0 : err.message) || String(err)));\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    uploadToWalrus,\n    downloadFromWalrus,\n    getBlobUrl,\n    checkBlobExists\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2FscnVzLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEM7QUFDYTtBQWV2RDs7O0NBR0MsR0FDTSxlQUFlRyxlQUFlQyxJQUFVO0lBQzdDLElBQUk7UUFDRixnREFBZ0Q7UUFDaEQsTUFBTUMsY0FBYyxNQUFNRCxLQUFLQyxXQUFXO1FBQzFDLE1BQU1DLFNBQVNDLGVBQWUsSUFBSUMsV0FBV0g7UUFFN0MsTUFBTUksT0FBTztZQUNYTCxNQUFNRTtZQUNOSSxrQkFBa0JOLEtBQUtPLElBQUk7WUFDM0JDLGFBQWFSLEtBQUtTLElBQUksSUFBSTtZQUMxQkMsVUFBVTtnQkFDUkgsTUFBTVAsS0FBS08sSUFBSSxJQUFJO2dCQUNuQkksYUFBYSwyQkFBb0QsT0FBekIsSUFBSUMsT0FBT0MsV0FBVyxJQUFHO2dCQUNqRUMsT0FBTztZQUNUO1FBQ0Y7UUFFQSxNQUFNQyxNQUFNLEdBQWUsT0FBWmxCLG1EQUFXQSxFQUFDO1FBQzNCLE1BQU1tQixPQUFPLE1BQU1wQiw2Q0FBS0EsQ0FBQ3FCLElBQUksQ0FBQ0YsS0FBS1YsTUFBTTtZQUN2Q2EsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLFNBQVM7UUFDWDtRQUVBLDhGQUE4RjtRQUM5RixNQUFNQyxPQUFPSixLQUFLSSxJQUFJLElBQUksQ0FBQztRQUMzQixJQUFJLENBQUNBLEtBQUtDLE9BQU8sRUFBRSxNQUFNLElBQUlDLE1BQU07UUFFbkMsTUFBTUMsU0FBdUI7WUFDM0JDLFlBQVlKLEtBQUtJLFVBQVU7WUFDM0JILFNBQVNELEtBQUtDLE9BQU87WUFDckJJLGdCQUFnQkwsS0FBS0ssY0FBYztZQUNuQ0MsYUFBYUMsT0FBT1AsS0FBS00sV0FBVyxJQUFJO1lBQ3hDaEIsVUFBVVUsS0FBS1YsUUFBUTtZQUN2QmtCLGVBQWUsT0FBT1IsS0FBS1EsYUFBYSxLQUFLLFdBQVdSLEtBQUtRLGFBQWEsR0FBR0M7WUFDN0VDLFVBQVUsT0FBT1YsS0FBS1UsUUFBUSxLQUFLLFlBQVlWLEtBQUtVLFFBQVEsR0FBR0Q7WUFDL0RFLGFBQWEsT0FBT1gsS0FBS1csV0FBVyxLQUFLLFdBQVdYLEtBQUtXLFdBQVcsR0FBR0Y7WUFDdkVHLGNBQWMsT0FBT1osS0FBS1ksWUFBWSxLQUFLLFdBQVdaLEtBQUtZLFlBQVksR0FBR0g7UUFDNUU7UUFFQSxPQUFPTjtJQUNULEVBQUUsT0FBT1UsS0FBSztRQUNaLE1BQU1DLGVBQWVELEtBQUs7SUFDNUI7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWVFLG1CQUFtQkMsTUFBYztJQUNyRCxJQUFJO1FBQ0YsTUFBTXJCLE1BQU1zQixXQUFXRDtRQUN2QixNQUFNcEIsT0FBTyxNQUFNcEIsNkNBQUtBLENBQUMwQyxHQUFHLENBQWN2QixLQUFLO1lBQzdDd0IsY0FBYztZQUNkcEIsU0FBUztRQUNYO1FBQ0EsTUFBTVgsY0FBY1EsS0FBS0UsT0FBTyxDQUFDLGVBQWUsSUFBSTtRQUNwRCxPQUFPLElBQUlzQixLQUFLO1lBQUN4QixLQUFLSSxJQUFJO1NBQUMsRUFBRTtZQUFFWCxNQUFNRDtRQUFZO0lBQ25ELEVBQUUsT0FBT3lCLEtBQUs7UUFDWixNQUFNQyxlQUFlRCxLQUFLLGtDQUF5QyxPQUFQRztJQUM5RDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxXQUFXRCxNQUFjO0lBQ3ZDLG9FQUFvRTtJQUNwRSxPQUFPLEdBQXNDSyxPQUFuQzNDLG1EQUFXQSxDQUFDNEMsVUFBVSxFQUFDLGNBQXVDLE9BQTNCRCxtQkFBbUJMO0FBQ2xFO0FBRUE7O0NBRUMsR0FDTSxlQUFlTyxnQkFBZ0JQLE1BQWM7SUFDbEQsTUFBTXJCLE1BQU1zQixXQUFXRDtJQUN2QixJQUFJO1FBQ0YsTUFBTXhDLDZDQUFLQSxDQUFDZ0QsSUFBSSxDQUFDN0IsS0FBSztZQUFFSSxTQUFTO1FBQU87UUFDeEMsT0FBTztJQUNULEVBQUUsT0FBTzBCLEdBQUc7UUFDVixNQUFNWixNQUFNWTtRQUNaLHNEQUFzRDtRQUN0RCxJQUFJWixJQUFJYSxRQUFRLElBQUliLElBQUlhLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUs7WUFDL0MsSUFBSTtnQkFDRixNQUFNbkQsNkNBQUtBLENBQUMwQyxHQUFHLENBQUN2QixLQUFLO29CQUFFSSxTQUFTO2dCQUFPO2dCQUN2QyxPQUFPO1lBQ1QsRUFBRSxVQUFNO2dCQUNOLE9BQU87WUFDVDtRQUNGO1FBQ0EsSUFBSWMsSUFBSWEsUUFBUSxJQUFJYixJQUFJYSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE9BQU87UUFDeEQsa0NBQWtDO1FBQ2xDLE9BQU87SUFDVDtBQUNGO0FBRUEsVUFBVTtBQUNWLFNBQVM1QyxlQUFlNkMsS0FBaUI7SUFDdkMsSUFBSUMsU0FBUztJQUNiLE1BQU1DLFlBQVk7SUFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1JLE1BQU0sRUFBRUQsS0FBS0QsVUFBVztRQUNoRCxNQUFNRyxRQUFRTCxNQUFNTSxRQUFRLENBQUNILEdBQUdBLElBQUlEO1FBQ3BDRCxVQUFVTSxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNQyxNQUFNQyxJQUFJLENBQUNOO0lBQ3ZEO0lBQ0EsT0FBT08sS0FBS1g7QUFDZDtBQUVBLFNBQVNmLGVBQWVELEdBQVksRUFBRTRCLE1BQWM7SUFDbEQsSUFBSWpFLDZDQUFLQSxDQUFDa0UsWUFBWSxDQUFDN0IsTUFBTTtZQUVaQTtRQURmLE1BQU04QixPQUFPOUIsSUFBSThCLElBQUksR0FBRyxLQUFjLE9BQVQ5QixJQUFJOEIsSUFBSSxFQUFDLE9BQUs7UUFDM0MsTUFBTWhCLFNBQVNkLEVBQUFBLGdCQUFBQSxJQUFJYSxRQUFRLGNBQVpiLG9DQUFBQSxjQUFjYyxNQUFNLElBQUcsVUFBOEIsT0FBcEJkLElBQUlhLFFBQVEsQ0FBQ0MsTUFBTSxFQUFDLE9BQUs7UUFDekUsTUFBTWlCLE1BQU0vQixJQUFJZ0MsT0FBTyxJQUFJO1FBQzNCLE9BQU8sSUFBSTNDLE1BQU0sR0FBYzBDLE9BQVhILFFBQU8sTUFBVUUsT0FBTkMsS0FBYWpCLE9BQVBnQixNQUFjLE9BQVBoQjtJQUM5QztJQUNBLE9BQU8sSUFBSXpCLE1BQU0sR0FBYyxPQUFYdUMsUUFBTyxNQUEyQyxPQUF2QyxDQUFDNUIsZ0JBQUFBLDBCQUFELElBQWdCZ0MsT0FBTyxLQUFJVixPQUFPdEI7QUFDbkU7QUFFQSwrREFBZTtJQUNibEM7SUFDQW9DO0lBQ0FFO0lBQ0FNO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvd2FscnVzLWNsaWVudC50cz80YzVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcywgeyBBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBCQUNLRU5EX1VSTCwgV0FMUlVTX1VSTFMgfSBmcm9tIFwiQC9jb25zdGFudHNcIjtcbmltcG9ydCB0eXBlIHsgRGF0YXNldCB9IGZyb20gXCJAL3R5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkUmVzdWx0IHtcbiAgZGF0YXNldF9pZD86IHN0cmluZztcbiAgYmxvYl9pZDogc3RyaW5nO1xuICBzZWFsX3BvbGljeV9pZDogc3RyaW5nO1xuICB1cGxvYWRfc2l6ZTogbnVtYmVyO1xuICBtZXRhZGF0YT86IHVua25vd247XG4gIHF1YWxpdHlfc2NvcmU/OiBudW1iZXI7XG4gIGlzX3ZhbGlkPzogYm9vbGVhbjtcbiAgYXR0ZXN0YXRpb24/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcF9tcz86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBVcGxvYWQgYSBmaWxlIHRvIHRoZSBiYWNrZW5kIHdoaWNoIGVuY3J5cHRzIChTZWFsIHBsYWNlaG9sZGVyKSBhbmQgc3RvcmVzIGluIFdhbHJ1cy5cbiAqIEJhY2tlbmQgZW5kcG9pbnQ6IFBPU1QgL2FwaS91cGxvYWQvZGF0YXNldFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkVG9XYWxydXMoZmlsZTogRmlsZSk6IFByb21pc2U8VXBsb2FkUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgLy8gUmVhZCBmaWxlIGFzIGJhc2U2NCAod2l0aG91dCBkYXRhIFVSTCBwcmVmaXgpXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgYmFzZTY0ID0gYnVmZmVyVG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcblxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBmaWxlOiBiYXNlNjQsXG4gICAgICBvcmlnaW5hbEZpbGVuYW1lOiBmaWxlLm5hbWUsXG4gICAgICBjb250ZW50VHlwZTogZmlsZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgXCJkYXRhc2V0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVXBsb2FkZWQgdmlhIFplcm9WYXVsdCAoJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9KWAsXG4gICAgICAgIHByaWNlOiBcIjBcIiwgLy8gZGVmYXVsdCAwIGZvciBjbGllbnQtc2lkZSBoZWxwZXI7IHJlYWwgcHJpY2Ugc2V0IGluIGxpc3RpbmcgZmxvd1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsID0gYCR7QkFDS0VORF9VUkx9L2FwaS91cGxvYWQvZGF0YXNldGA7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCBib2R5LCB7XG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICB0aW1lb3V0OiA2MF8wMDAsXG4gICAgfSk7XG5cbiAgICAvLyBCYWNrZW5kIHJldHVybnM6IHsgZGF0YXNldF9pZD8sIGJsb2JfaWQsIHNlYWxfcG9saWN5X2lkLCB1cGxvYWRfc2l6ZSwgbWV0YWRhdGEsIHF1YWxpdHlfKiB9XG4gICAgY29uc3QgZGF0YSA9IHJlc3AuZGF0YSB8fCB7fTtcbiAgICBpZiAoIWRhdGEuYmxvYl9pZCkgdGhyb3cgbmV3IEVycm9yKFwiVXBsb2FkIGRpZCBub3QgcmV0dXJuIGJsb2JfaWRcIik7XG5cbiAgICBjb25zdCByZXN1bHQ6IFVwbG9hZFJlc3VsdCA9IHtcbiAgICAgIGRhdGFzZXRfaWQ6IGRhdGEuZGF0YXNldF9pZCxcbiAgICAgIGJsb2JfaWQ6IGRhdGEuYmxvYl9pZCxcbiAgICAgIHNlYWxfcG9saWN5X2lkOiBkYXRhLnNlYWxfcG9saWN5X2lkLFxuICAgICAgdXBsb2FkX3NpemU6IE51bWJlcihkYXRhLnVwbG9hZF9zaXplIHx8IDApLFxuICAgICAgbWV0YWRhdGE6IGRhdGEubWV0YWRhdGEsXG4gICAgICBxdWFsaXR5X3Njb3JlOiB0eXBlb2YgZGF0YS5xdWFsaXR5X3Njb3JlID09PSBcIm51bWJlclwiID8gZGF0YS5xdWFsaXR5X3Njb3JlIDogdW5kZWZpbmVkLFxuICAgICAgaXNfdmFsaWQ6IHR5cGVvZiBkYXRhLmlzX3ZhbGlkID09PSBcImJvb2xlYW5cIiA/IGRhdGEuaXNfdmFsaWQgOiB1bmRlZmluZWQsXG4gICAgICBhdHRlc3RhdGlvbjogdHlwZW9mIGRhdGEuYXR0ZXN0YXRpb24gPT09IFwic3RyaW5nXCIgPyBkYXRhLmF0dGVzdGF0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgdGltZXN0YW1wX21zOiB0eXBlb2YgZGF0YS50aW1lc3RhbXBfbXMgPT09IFwibnVtYmVyXCIgPyBkYXRhLnRpbWVzdGFtcF9tcyA6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgd3JhcEF4aW9zRXJyb3IoZXJyLCBcIkZhaWxlZCB0byB1cGxvYWQgZGF0YXNldCB0byBXYWxydXMgdmlhIGJhY2tlbmRcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBEb3dubG9hZCBhIFdhbHJ1cyBibG9iIGZyb20gdGhlIGFnZ3JlZ2F0b3IuXG4gKiBSZXR1cm5zIGEgQmxvYiB3aXRoIGJlc3QtZWZmb3J0IGNvbnRlbnQgdHlwZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRnJvbVdhbHJ1cyhibG9iSWQ6IHN0cmluZyk6IFByb21pc2U8QmxvYj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGdldEJsb2JVcmwoYmxvYklkKTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgYXhpb3MuZ2V0PEFycmF5QnVmZmVyPih1cmwsIHtcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJhcnJheWJ1ZmZlclwiLFxuICAgICAgdGltZW91dDogNjBfMDAwLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtyZXNwLmRhdGFdLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyB3cmFwQXhpb3NFcnJvcihlcnIsIGBGYWlsZWQgdG8gZG93bmxvYWQgV2FscnVzIGJsb2IgJHtibG9iSWR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHB1YmxpYyBVUkwgdG8gYSBXYWxydXMgYmxvYiBvbiB0aGUgYWdncmVnYXRvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2JVcmwoYmxvYklkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBXYWxydXMgdGVzdG5ldCBhZ2dyZWdhdG9yIGV4cG9zZXMgYmxvYnMgdW5kZXIgL3YxL2Jsb2JzL3tibG9iX2lkfVxuICByZXR1cm4gYCR7V0FMUlVTX1VSTFMuYWdncmVnYXRvcn0vdjEvYmxvYnMvJHtlbmNvZGVVUklDb21wb25lbnQoYmxvYklkKX1gO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgV2FscnVzIGJsb2IgZXhpc3RzIHVzaW5nIEhFQUQ7IGZhbGxzIGJhY2sgdG8gR0VUIGlmIEhFQUQgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrQmxvYkV4aXN0cyhibG9iSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB1cmwgPSBnZXRCbG9iVXJsKGJsb2JJZCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgYXhpb3MuaGVhZCh1cmwsIHsgdGltZW91dDogMTBfMDAwIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgZXJyID0gZSBhcyBBeGlvc0Vycm9yO1xuICAgIC8vIFNvbWUgc2VydmVycyBtYXkgbm90IHN1cHBvcnQgSEVBRDsgZmFsbCBiYWNrIHRvIEdFVFxuICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBheGlvcy5nZXQodXJsLCB7IHRpbWVvdXQ6IDEwXzAwMCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIG5ldHdvcmsgZXJyb3JzLCByZXBvcnQgZmFsc2VcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyc1xuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjQoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBsZXQgYmluYXJ5ID0gXCJcIjtcbiAgY29uc3QgY2h1bmtTaXplID0gMHg4MDAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGkgKyBjaHVua1NpemUpO1xuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20oY2h1bmspIGFzIHVua25vd24gYXMgbnVtYmVyW10pO1xuICB9XG4gIHJldHVybiBidG9hKGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBeGlvc0Vycm9yKGVycjogdW5rbm93biwgcHJlZml4OiBzdHJpbmcpOiBFcnJvciB7XG4gIGlmIChheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkge1xuICAgIGNvbnN0IGNvZGUgPSBlcnIuY29kZSA/IGAgKCR7ZXJyLmNvZGV9KWAgOiBcIlwiO1xuICAgIGNvbnN0IHN0YXR1cyA9IGVyci5yZXNwb25zZT8uc3RhdHVzID8gYCBbSFRUUCAke2Vyci5yZXNwb25zZS5zdGF0dXN9XWAgOiBcIlwiO1xuICAgIGNvbnN0IG1zZyA9IGVyci5tZXNzYWdlIHx8IFwidW5rbm93biBheGlvcyBlcnJvclwiO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fTogJHttc2d9JHtjb2RlfSR7c3RhdHVzfWApO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fTogJHsoZXJyIGFzIEVycm9yKT8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKX1gKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB1cGxvYWRUb1dhbHJ1cyxcbiAgZG93bmxvYWRGcm9tV2FscnVzLFxuICBnZXRCbG9iVXJsLFxuICBjaGVja0Jsb2JFeGlzdHMsXG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuIl0sIm5hbWVzIjpbImF4aW9zIiwiQkFDS0VORF9VUkwiLCJXQUxSVVNfVVJMUyIsInVwbG9hZFRvV2FscnVzIiwiZmlsZSIsImFycmF5QnVmZmVyIiwiYmFzZTY0IiwiYnVmZmVyVG9CYXNlNjQiLCJVaW50OEFycmF5IiwiYm9keSIsIm9yaWdpbmFsRmlsZW5hbWUiLCJuYW1lIiwiY29udGVudFR5cGUiLCJ0eXBlIiwibWV0YWRhdGEiLCJkZXNjcmlwdGlvbiIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInByaWNlIiwidXJsIiwicmVzcCIsInBvc3QiLCJoZWFkZXJzIiwidGltZW91dCIsImRhdGEiLCJibG9iX2lkIiwiRXJyb3IiLCJyZXN1bHQiLCJkYXRhc2V0X2lkIiwic2VhbF9wb2xpY3lfaWQiLCJ1cGxvYWRfc2l6ZSIsIk51bWJlciIsInF1YWxpdHlfc2NvcmUiLCJ1bmRlZmluZWQiLCJpc192YWxpZCIsImF0dGVzdGF0aW9uIiwidGltZXN0YW1wX21zIiwiZXJyIiwid3JhcEF4aW9zRXJyb3IiLCJkb3dubG9hZEZyb21XYWxydXMiLCJibG9iSWQiLCJnZXRCbG9iVXJsIiwiZ2V0IiwicmVzcG9uc2VUeXBlIiwiQmxvYiIsImVuY29kZVVSSUNvbXBvbmVudCIsImFnZ3JlZ2F0b3IiLCJjaGVja0Jsb2JFeGlzdHMiLCJoZWFkIiwiZSIsInJlc3BvbnNlIiwic3RhdHVzIiwiYnl0ZXMiLCJiaW5hcnkiLCJjaHVua1NpemUiLCJpIiwibGVuZ3RoIiwiY2h1bmsiLCJzdWJhcnJheSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiQXJyYXkiLCJmcm9tIiwiYnRvYSIsInByZWZpeCIsImlzQXhpb3NFcnJvciIsImNvZGUiLCJtc2ciLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/walrus-client.ts\n"));

/***/ })

});